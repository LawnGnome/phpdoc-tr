<?xml version="1.0" encoding="iso-8859-9"?>
<!-- $Revision: 1.2 $ -->
 <chapter id="features.persistent-connections">
  <title>Kalýcý Veritabaný Baðlantýlarý</title>

  <simpara>
   Kalýcý baðlantýlar, betiðiniz sonlandýðýnda kapatýlmayan SQL baðlantýlarýna
   denir. Kalýcý bir baðlantý istendiðinde, PHP daha önceden tamamen ayný
   özelliklerde baþka bir kalýcý baðlantý açýlýp açýlmadýðýna bakar (daha
   önceden kalan) - ve eðer varsa, onu kullanýr. Eðer yoksa, yeni baðlantý
   kurar. 'Tamamen ayný' baðlantýlar, ayný sunucuya, ayný kullanýcý ismi ve
   (gerekliyse) þifreyle açýlmýþ baðlantýlardýr.
  </simpara>

  <simpara>
   HTTP sunucularýnýn çalýþma mantýðýna aþina olmayanlar, kalýcý baðlantýlarý
   gerçekte olmadýklarý þeyler sanabilirler. Özellikle, ayný SQL baðlantýsý
   üzerinde 'kullanýcý oturumlarý' <emphasis>açmazlar</emphasis>,
   transaction'larý daha etkili bir þekilde yapmanýzý
   <emphasis>saðlamazlar</emphasis> ve baþka pek çok þeyi gerçekleþtirmezler.
   Konu hakkýnda daha açýk olmak gerekirse, kalýcý baðlantýlar size kardeþleri
   kalýcý olmayan baðlantýlarýn sunmadýðý hiç bir ek özellik
   <emphasis>sunmazlar</emphasis>.
  </simpara>
  <simpara>
   Neden?
  </simpara> 
  <simpara>
   Bu daha çok HTTP sunucularýnýn çalýþma mantýðýyla alakalý. Sunucunun
   PHP'yi kullanarak web sayfalarý oluþturmasýnýn üç yöntemi var.
  </simpara>
  <simpara>
   <!-- dirge: wrapper => sargý -->
   Ýlk yöntem PHP'yi CGI "sargýsý" olarak kullanmak. Bu þekilde çalýþtýðýnda,
   sunucuya gelen her sayfa isteði için ayrý bir PHP yorumlayýcýsý yaratýlýr
   ve yokedilir (PHP sayfalarý için). Ýþlemler sonunda yokedildikleri için,
   yarattýklarý her kaynak da (SQL sunucusuna baðlantýlar gibi) onlarla
   birlikte yokolur. Bu durumda, kalýcý baðlantýlar kurmayý denemekle elinize
   hiçbirþey geçmez -- basitçe, kalýcý olamazlar.
  </simpara>
  <simpara> 
   <!-- dirge: multiprocess => çok iþlemli -->
   Ýkinci, ve en popüler, yöntem PHP'yi çok iþlemli (multiprocess) bir
   sunucuda modül olarak kullanmak, þu an sadece Apache'de olduðu gibi. Çok
   iþlemli bir sunucu genellikle bir ana iþlemden (parent) ve onun kontrolündeki
   gerçekte iþlemleri yapan çocuk iþlemlerden (children) oluþur. Ne zaman bir
   alýcýdan istek gelse, istek o anda baþka bir isteðe cevap vermeyen bir çocuk
   iþleme devredilir. Bu demektir ki, ayný alýcý ikinci bir istek yolladýðýnda,
   baþka bir çocuk iþlem tarafýndan karþýlanabilir. Kalýcý baðlantýlarýn
   sizin için burada yaptýðý iþ, her çocuk iþlemin sadece ilk seferde SQL
   sunucusuna baðlanmasýdýr. Baþka bir sayfanýn ayný baðlantýya ihtiyaç duymasý
   durumunda önceden kurulmuþ baðlantý kullanýlýr.
  </simpara>
  <simpara>
   <!-- dirge: thread => iþ parçacýðý -->
   Son yöntem PHP'yi çok iþ parçacýklý (multithreaded) sunucularda eklenti
   olarak kullanmak. Þu anda PHP 4'ün Netscape FastTrack (iPlanet), Microsoft
   Internet Information Server (IIS), ve O'Reilly Website Pro gibi çok iþ
   parçacýklý sunucularda çalýþmasýný saðlayan ISAPI, WSAIP, ve NSAPI
   (Windows'ta) için desteði var. Bu çalýþma þekli az önce anlatýlan çok
   iþlemli modelle ayný. SAPI desteðinin PHP 3'te olmadýðýna dikkat edin.
  </simpara>
  <simpara>
   Eðer kalýcý baðlantýlarýn ek özellikleri yoksa, neye yararlar?
  </simpara>
  <simpara>
   <!-- dige: efficiency => etkinlik -->
   Buradaki cevap oldukça basit -- etkinlik. Kalýcý baðlantýlar, SQL
   sunucunuza yeni baðlantý açmak performans açýsýndan hesaplý deðilse 
   çok iþe yararlar. Performans hesaplýlýðý pek çok þeye baðlýdýr. Örneðin, ne
   tür bir veritabaný olduðu, HTTP sunucusuyla ayný bilgisayarda olup
   olmayýþý, SQL sunucusunun çalýþtýðý bilgisayarýn iþlem yoðunluðu ve
   benzeri. Sonuç þu ki, yeni baðlantý performansý düþükse, kalýcý baðlantýlar
   iþe yarar. Her çocuk iþlemin her seferinde yeni baðlantý açmasý yerine
   hayatý boyunca sadece bir kere baðlantý yapmasýný ve sürekli onu kullanmasýný
   saðlarlar. Bu demektir ki, kalýcý baðlantý açan her çocuk iþlemin kendisine
   ait SQL sunucusuna kalýcý bir baðlantýsý olacaktýr. Örneðin, 20 tane
   kalýcý baðlantý açan betik çalýþtýrmýþ farklý çocuk iþlem varsa, SQL
   sunucusuna, her çocuk iþlemden bir tane olmak üzere, 20 tane baðlantý
   olacaktýr.
  </simpara>
  <simpara>
   Ancak dikkat edin ki, SQL sunucusunun baðlantý limiti kalýcý baðlantýlarla
   aþýldýðýnda bunun bir takým götürüleri olacaktýr. Eðer veritabaný
   sunucunuz ayni anda 16 baðlantýya izin veriyorsa, ve yoðun bir çalýþma
   anýnda 17 çocuk iþlem kalýcý baðlantý açmaya kalkarsa, bunlardan biri
   baðlantýyý açamaz. Eðer betiklerinizde baðlantýlarýn kapanabilmesine olanak
   tanýmayan hatalar varsa (kýsýr döngüler gibi), 32 baðlantýya izin veren bir
   veritabaný sunucusu çok çabuk bir þekilde kullaným dýþý olur. Boþ duran
   (idle) baðlantýlarla nasýl ilgileneceðiniz konusunda veritabanýnýzýn
   dökümanlarýna baþvurun.
  </simpara>
  <warning>
   <simpara>
    <!-- dirge: register => kaydetmek -->
    Kalýcý baðlantý kullanýrken akýlda tutulmasý gereken birkaç ek götürü daha
    var. Örneðin kalýcý bir baðlantý üzerinden bir tablo kitlendiyse (LOCK),
    ve betik herhangi bir sebepten dolayý kilidi kaldýramýyorsa, ardýsýra gelen
    ve ayný baðlantýyý kullanacak betikler süresiz olarak bloke olacak, ve
    sizin ya HTTP sunucusunu ya da veritabaný sunucusunu baþtan çalýþtýrmanýz
    gerekecektir. Baþka bir götürü transaction kullanýrken oluþabilir. Bir
    transaction bloðu, betiðin çalýþma süresi bloðun ömründen kisaysa, bir
    sonraki betiðe taþýnacaktýr. Ýki durumda da
    <function>register_shutdown_function</function> ile transaction'i geri
    alacak ya da tablo kilitlerini kaldýracak bir temizlik fonksiyonu
    kaydedebilirsiniz. Daha iyisi, problemleri tümüyle önlemek için tablo
    kilitleri veya transaction kullanan betiklerde kalýcý baðlantýlarý
    kullanmamaktýr (baþka yerlerde hala kullanabilirsiniz).
   </simpara>
  </warning>
  <simpara>
   Önemli bir özet. Kalýcý baðlantýlar normal baðlantýlarla birebir
   eþlenebilecek þekilde tasarlandý. Bu demektir ki <emphasis>her
    zaman</emphasis> kalýcý baðlantýlarý normal olanlarla deðiþtirebilirsiniz,
   ve bu betiklerin davranýþlarýný etkilemeyecektir. Betiklerin etkinliklerini
   <emphasis>belki</emphasis> deðiþtirebilirler, fakat davranýþýný
   deðiþtirmezler!
  </simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
