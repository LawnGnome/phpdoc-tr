<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.11 $ -->
<!-- EN-Revision: 1.172 Maintainer: nilgun Status: ready -->
<!-- CREDITS: tpug, sezer -->
 <chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Denetim Yapıları</title>

  <simpara>
    Bütün PHP betikleri bir dizi deyimden oluşur. Bir deyim; bir atama, bir
    işlev çağrısı, bir döngü, bir koşullu deyim hatta hiçbir şey yapmayan
    bir deyim (boş bir deyim) olabilir. Deyimler bir noktalı virgülle
    sonlandırılır. Ek olarak, deyimler kaşlı ayraçlar içine alınarak deyim
    grupları haline getirilebilirler. Bir deyim grubu da kendi başına bir
    deyim olarak kabul edilir. Bu fasılda deyim türlerinden bahsedeğiz.
  </simpara>

  <sect1 xml:id="control-structures.if">
   <title><code>if</code></title>
   <para>
    <command>if</command> oluşumu, PHP dahil olmak üzere birçok programlama
    dilindeki en önemli yapı taşlarından biri olup kod bölümlerinin koşullu
    olarak çalıştırılabilmelerini sağlar. PHP, C dilindekine benzer bir
    <command>if</command> yapısı sunar:
    <informalexample>
     <programlisting>
<![CDATA[
if (ifade)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <link linkend="language.expressions">İfadelerle ilgili bölüm</link>de de
    anlatıldığı gibi, <replaceable>ifade</replaceable> kendi mantıksal
    değeri üzerinden değerlendirilir. <replaceable>ifade</replaceable>'nin
    sonucu &true; ise, PHP <replaceable>deyim</replaceable>'i çalıştırır,
    &false; ise gözardı eder. Hangi değerlerin &false; olarak
    değerlendirildiği hakkında daha fazla bilgiyi <link
    linkend="language.types.boolean.casting">boolean türüne
    dönüşüm</link> bölümünde bulabilirsiniz.
   </simpara>
   <para>
    Aşağıdaki örnek, <varname>$a</varname> değeri <varname>$b</varname>
    değerinden büyük olduğu takdirde <code>a büyüktür b</code> metnini
    görüntüleyecektir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a büyüktür b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Çoğunlukla birden çok deyimin koşullu olarak çalıştırılmasını
    isteyeceksiniz. Elbette, her deyimi ayrı ayrı <command>if</command>
    cümlecikleri içine almanıza gerek yoktur. Birden çok deyimi tek bir
    deyim grubu içine toplayabilirsiniz. Örneğin, aşağıdaki kod
    <varname>$a</varname> değeri <varname>$b</varname> değerinden büyük
    olduğu takdirde <code>a büyüktür b</code> metnini görüntüleyecektir ve
    sonrasında <varname>$a</varname> değişkeninin değerini
    <varname>$b</varname> değişkenine atayacaktır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Sonsuz sayıda <command>if</command> deyimi bir başka
    <command>if</command> deyiminin içine gömülebilir. Bu, uygulamanızın
    çeşitli bölümlerine koşullu deyimler uygulayabilmeniz için tam bir
    esneklik sağlar.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><code>else</code></title>
   <para>
    Çoğu zaman belli bir koşul sağlandığında bir deyimin, o koşul
    sağlanmadığında başka bir deyimin çalıştırılmasını isteyeceksiniz. Bunun
    için <command>else</command> kullanılmaktadır. <command>Else</command>,
    bir <command>if</command> deyimini &false; döndürdüğü takdirde bir deyim
    çalıştırmak üzere genişletir. Örneğin, aşağıdaki kod
    <varname>$a</varname> değeri <varname>$b</varname> değerinden büyükse
    <code>a büyüktür b</code>, büyük değilse <code>a büyük değildir b</code>
    iletisini görüntüleyecektir:
   <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} else {
    echo "a büyük değildir b";
}
?>
]]>
     </programlisting>
    </informalexample>

      <command>Else</command> deyimi yalnızca <command>if</command> deyiminin
      &false; döndürdüğü durumda çalıştırılacaktır. Aynı durum, &false;
      döndüren herhangi bir <command>elseif</command> ifadesinin olması
      durumunda da geçerlidir (bakınız <link
      linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><code>elseif/else if</code></title>
   <para>
    <command>elseif</command>, isminden de anlaşılacağı gibi,
    <command>if</command> ve <command>else</command> deyimlerinin biraraya
    gelmesiyle oluşur. <command>else</command> gibi, orijinal
    <command>if</command> ifadesinin &false; döndürdüğü durumda farklı bir
    deyimin çalıştırılması için kullanılır. Ancak,
    <command>else</command>'ten farklı olarak, ilgili deyimi sadece
    kendisine ait koşullu ifade &true; değerini döndürdüğü takdirde
    çalıştıracaktır. Örneğin, aşağıdaki kod <code>a büyüktür b</code>,
    <code>a eşittir b</code> ya da <code>a küçüktür b</code> iletisini
    görüntüleyecektir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} elseif ($a == $b) {
    echo "a eşittir b";
} else {
    echo "a küçüktür b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Aynı <command>if</command> deyimine ait birden çok
    <command>elseif</command> bulunabilir. İlk önce hangi
    <command>elseif</command> deyimi &true; değerini döndürürse (eğer
    döndüren varsa) o deyim çalıştırılır. Bu deyimi 'elseif' biçiminde tek
    sözcük olarak kullanabileceğiniz gibi, 'else if' biçiminde iki sözcük
    olarak da kullanabilirsiniz, sonuç aynı olacaktır. Sözdiziminin
    anlamlandırılması açısından küçük bir farklılık olsa da (C diline
    aşinaysanız, onda da böyledir) sonuç olarak her ikisi de aynı sonucu
    üretecektir.
   </simpara>
   <simpara>
    <command>elseif</command> ifadesi yalnızca kendisinden önceki
    <command>if</command> ifadesi ve bu ifadeye bağlı kendisinden önce gelen
    diğer tüm <command>elseif</command> ifadeleri &false; ile
    sonuçlandığında çalıştırılır ve &true; olarak değerlendirilir.
   </simpara>
   <note>
    <simpara>
     <command>elseif</command> ve <command>else if</command>, yukarıdaki
     örnekten anlaşılacağı üzere sadece kaşlı ayraçlar kullanıldığı zaman
     tamamen aynı şekilde ele alınacaktır. <command>if</command> ve
     <command>elseif</command> için <link
     linkend="control-structures.alternative-syntax">iki noktalı
     sözdizimi</link> kullanıldığında <command>elseif</command>'i iki sözcüğe
     ayırmamanız gerekir, yoksa PHP bir çözümleme hatası vererek başarısız
     olur.
    </simpara>
   </note>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

/* Yanlış Yöntem: */
if($a > $b):
    echo $a." büyüktür ".$b;
else if($a == $b): // Bu derlenmez.
    echo "Üstteki satır bir çözümleme hatasına yol açar.";
endif;


/* Doğru Yöntem: */
if($a > $b):
    echo $a." büyüktür ".$b;
elseif($a == $b): // Sözcüklerin birleşik oluşuna dikkat!
    echo $a." eşittir ".$b;
else:
    echo $a." ne büyük ne de eşittir ".$b;
endif;

?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>Denetim yapıları için diğer sözdizimi</title>
   <para>
    PHP bazı denetim yapıları için farklı bir sözdizimi sağlar. Bu yapılar
    <command>if</command>, <command>while</command>, <command>for</command>,
    <command>foreach</command> ve <command>switch</command> yapılarıdır.
    Her durumda, bu farklı sözdiziminin basit şekli açılışta kullanılan
    kaşlı ayracın yerine iki nokta imi (:) ve kapanışta kullanılan kaşlı
    ayraç yerine de sırasıyla <command>endif;</command>,
    <command>endwhile;</command>, <command>endfor;</command>,
    <command>endforeach;</command> ya da <command>endswitch;</command>
    deyimlerinden birini kullanmaktır.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A eşittir 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Yukarıdaki örnekte, içeriği "A eşittir 5" olan HTML bloğu iki noktalı
    sözdimi kullanılarak yazılmış bir <command>if</command> deyiminin içine
    gömülmüştür. HTML bloğu yalnızca <varname>$a</varname> değişkeni 5'e
    eşit olduğunda gösterilecektir.
   </simpara>
   <para>
    İki noktalı sözdimi, <command>else</command> ve <command>elseif</command>
    için de kullanılabilir. Birazdan vereceğimiz örnek, iki noktalı
    sözdizimi ile yazılmış <command>elseif</command> ve
    <command>else</command> içeren bir <command>if</command> yapısıdır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a eşittir 5";
    echo "...";
elseif ($a == 6):
    echo "a eşittir 6";
    echo "!!!";
else:
    echo "a ne 5 ne de 6'dır";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Daha fazla örnek için <link linkend="control-structures.while"
    >while</link>, <link linkend="control-structures.for">for</link> ve <link
    linkend="control-structures.if">if</link> cümleciklerine bakabilirsiniz.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><code>while</code></title>
   <para>
    <command>while</command> döngüsü PHP'de yer alan en basit döngü türüdür.
    C'deki karşılığı ile aynı şekilde çalışır. Bir <command>while</command>
    deyiminin basit kullanımı:
    <informalexample>
     <programlisting>
<![CDATA[
while (ifade)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <command>While</command> deyiminin anlamı basittir.
    <command>while</command> deyimindeki ifade &true; olduğu müddetçe etki
    alanındaki deyimleri PHP tekrar tekrar çalıştırır. İfadenin değeri
    döngünün her yinelenişinde yeniden değerlendirilir, deyimlerin
    çalıştırılması sırasında bu ifadenin değeri &false; olsa bile, etki
    alanındaki deyimlerin tamamı çalıştırılıncaya kadar işlem devam eder.
    (PHP döngü içindeki deyimleri her yinelemede bir kere çalıştırır.)
    Bazen, <command>while</command> ifadesi daha başlangıçta &false;
    değerini verir, bu durumda <command>while</command> etki alanındaki
    deyimler tek bir defa bile çalıştırılmazlar.
   </simpara>
   <para>
    <command>if</command> deyiminde olduğu gibi, birden çok deyimi aynı
    <command>while</command> döngüsü içinde kaşlı ayraçlar arasında veya
    <link linkend="control-structures.alternative-syntax">iki noktalı
    sözdizimi</link>ni kullanarak gruplayabilirsiniz:
   <informalexample>
     <programlisting>
<![CDATA[
while (ifade):
    deyimler
    ...
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Aşağıdaki örnekler birbirleri ile aynıdırlar, her ikisi de sayıları
    1'den 10'a kadar yazacaktır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* yazdırılan değer $i
                    değerinin artıştan önceki
                    değeridir (sonda-arttırım) */
}

/* örnek 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><code>do-while</code></title>
   <simpara>
    <command>do-while</command> döngüsü, <command>while</command> döngüsüne
    çok benzer; farkı, doğrulama ifadesinin her yinelemenin başında değil
    sonunda değerlendiriliyor olmasıdır. <command>while</command> döngüsü
    ile temek farklılık, <command>do-while</command> kullanıldığında ilk
    yinelemenin daima yapılıyor olmasıdır (ifadenin doğruluğuna yalnızca
    yinelemenin sonunda bakılır); halbuki <command>while</command>
    döngüsünde, ifadenin doğruluğuna her yinelemenin öncesinde bakılmakta ve
    ifadenin sonucu doğru değilse yineleme hiç başlatılmadan döngü
    sonlandırılmaktadır.
   </simpara>
   <para>
    <command>do-while</command> döngüsü için yalnızca tek bir sözdizimi
    mevcuttur:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Yukarıdaki döngü tam olarak bir defa çalışacaktır, ilk tekrardan sonra
    ifadenin doğruluğuna bakıldığında &false; değerini verecek ($i sıfırdan
    büyük değildir) ve döngünün çalışması sonlanacaktır.
   </simpara>
   <para>
    İleri seviye C kullanıcıları <command>do-while</command> döngüsünün
    farklı kullanımlarına aşina olabilirler. Bu döngü, kod bloklarının
    çalıştırıldıkları esnada çalışmanın ortasında sonlandırılmalarını
    sağlamak için kullanılabilir. Bu işlem kod bloğunu
    <command>do-while</command> (0) döngüsü içine alıp <link
    linkend="control-structures.break"><command>break</command></link>
    deyimi kullanılarak yapılabilmektedir. Aşağıdaki kod parçası bu
    kullanımı örneklemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i yeterince büyük değil";
        break;
    }
    $i *= $çarpan;
    if ($i < $alt_sınır) {
        break;
    }
   echo "i uygun";

    /* i değerini işle */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Burada neler olup bittiğini anlamadıysanız endişelenmeyin. Bu 'özelliği'
    kullanmadan da oldukça gelişmiş ve güçlü uygulamalar geliştirebilirsiniz.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><code>for</code></title>
   <para>
    <command>for</command> döngüsü, PHP'deki en karmaşık döngü yapısıdır.
    C'deki karşılığıyla aynı biçimde çalışır. <command>for</command>
    döngüsünün sözdimi:
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    İlk ifade (<varname>ifade1</varname>) döngünün en başında bir kereliğine
    koşulsuz olarak çalıştırılır.
   </simpara>
   <simpara>
    Her yinelemenin başında <varname>ifade2</varname> yeniden
    değerlendirilir. Bu ifadeden &true; sonucu elde edilirse, döngüye devam
    edilir ve döngünün etki alanındaki deyimler çalıştırılır. Bu ifadeden
    &false; sonucu elde edildiğinde etki alanındaki deyimler
    çalıştırılmaksızın döngü sonlandırılır.
   </simpara>
   <simpara>
    <varname>ifade3</varname> ise her yinelemenin sonunda çalıştırılır.
   </simpara>
   <simpara>
    Bu ifadelerin herbirini boş bırakmak da mümkündür.
    <varname>ifade2</varname>nin boş olması, döngünün sonsuza kadar
    çalıştırılacağı anlamına gelir (PHP, C'deki gibi bu durumu &true; olarak
    değerlendirir). Döngülerden genellikle bir şarta bağlı olarak <link
    linkend="control-structures.break"><command>break</command></link>
    deyimi ile çıkmak isteyeceğiniz düşünüldüğünde, bu durum düşündüğünüz
    kadar kullanışsız değildir.
   </simpara>
   <para>
    Aşağıdaki örnekleri ele alalım. Hepsi de 1'den 10'a kadar sayıları
    görüntülemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* örnek 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* örnek 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* örnek 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Elbette, kullandığımız ilk örnek en güzel örnek olarak gözükmektedir (ya
    da belki dördüncü örnek), ancak birçok durumda <command>for</command>
    döngüsü içerisinde boş ifadeler kullanmayı oldukça kullanışlı
    bulabilirsiniz.
   </simpara>
   <para>
    PHP, <link
    linkend="control-structures.alternative-syntax">iki noktalı
    sözdizimi</link>ni <command>for</command> döngüleri için de
    desteklemektedir.
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3):
    deyimler
    ...
endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
   <simpara>
    Çoğu kullanıcının yaptığı gibi diziler üzerindeki yinelemeleri şöyle
    yapabilirsiniz:
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Diziye baştan bir kaç veri atıp daha sonra
 * döngü içinde verilerde değişiklik yapacağız.
 */
$bizimkiler = Array(
        Array('isim' => 'Ali', 'tuz' => 856412),
        Array('isim' => 'Veli', 'tuz' => 215863)
        );

for($i = 0; $i < sizeof($bizimkiler); ++$i)
{
    $bizimkiler[$i]['tuz'] = rand(000000, 999999);
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Sorun ikinci ifadede gizlidir. Her yinelemede dizinin boyutları yeniden
    hesaplandığından kod yavaş çalışabilir. Örnekte boyut değişmediğinden
    dizi boyutunu önce bir değişkene atıp ifadede bu değişken kullanılarak
    kod en iyilenebilir. Aşağıdaki bunun yapılışı örneklenmiştir:
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bizimkiler = Array(
        Array('isim' => 'Ali', 'tuz' => 856412),
        Array('isim' => 'Veli', 'tuz' => 215863)
        );

for($i = 0, $size = sizeof($bizimkiler); $i < $size; ++$i)
{
    $bizimkiler[$i]['salt'] = rand(000000, 999999);
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><code>foreach</code></title>
   <para>
    PHP 4 ile birlikte Perl ve bazı diğer dillerde mevcut olan
    <command>foreach</command> yapısı da kullanıma sunulmuştur. Bu deyim
    diziler üzerinde yineleme yapmayı kolaylaştırmaktadır.
    <command>foreach</command> yalnızca diziler için kullanılabilir; farklı
    veri türünde veya ilklendirilmemiş bir değişken ile kullanmak
    istediğinizde hata verir. İki sözdizimi mevcuttur; ikincisi birinciden
    biraz daha kullanışlıdır:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (dizi_ifadesi as $değer)
    deyim
foreach (dizi_ifadesi as $isim => $değer)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    İlk sözdizimi <command>dizi_ifadesi</command> ile belirtilen dizinin
    üzerinde döngü oluşturur. Her yinelemede, sırası gelen elemanın değeri
    <literal>$değer</literal> değişkenine atanır ve dizi göstericisi bir
    arttırılır (böylece bir sonraki yinelemede dizinin bir sonraki elemanına
    bakılması sağlanmış olur).
   </simpara>
   <simpara>
    İkinci yöntem de aynı şeyi yapar, ek olarak her yinelemede sırası gelen
    elemanın anahtarı <literal>$isim</literal> değişkenine atanır.
   </simpara>
   <simpara>
    PHP 5'den itibaren, <link linkend="language.oop5.iterations">nesneleri
    yinelemek</link> mümkün olmuştur.
   </simpara>
   <para>
    <note>
     <para>
      <command>foreach</command> ilk çalışmaya başladığında, dizi
      göstericisi özdevinimli olarak ilk elemanı gösterecek biçimde
      sıfırlanır. Bu sebeple, <command>foreach</command> deyiminden önce
      <function>reset</function> işlevini çalıştırmanıza gerek yoktur.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Dizi <link linkend="language.references">gönderimli</link> olmadıkça,
      <command>foreach</command> dizinin kendisi üzerinde değil, bir kopyası
      üzerinde çalışır. Bundan dolayı özgün dizi göstericisi değiştirilmez
      ve döndürülen dizi elemanı üzerinde yapılan değişiklikler özgün diziye
      yansıtılmaz.
     </para>
    </note>
   </para>
  <para>
    PHP 5'den itibaren, <literal>$değer</literal> değişkeninin önüne &amp;
    koyarak dizi elemanları üzerinde kolayca değişiklik yapılabilmektedir.
    Bu kullanımla değeri kopyalamak yerine kendisine bir <link
    linkend="language.references">gönderim</link> yapılması sağlanır.
    <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$dizi = array(1, 2, 3, 4);
foreach ($dizi as &$değer) {
    $value = $değer * 2;
}
// $dizi artık array(2, 4, 6, 8) olmuştur
unset($değer); // son eleman da işlendiğine göre gönderimi kaldıralım
?>
]]>
    </programlisting>
  </informalexample>
    Bu durum yalnızca yinelenen diziye gönderim yapılabiliyorsa
    mümkündür (örneğin, bir değişkense).
  </para>
   <warning>
    <para>
     <literal>$değer</literal> gönderim için kullanıldığından
     <literal>foreach</literal> döngüsünün sonunda son dizi elemanına
     gönderimli olarak kalır, bu bakımdan döngünün sonunda bu gönderimin
     <function>unset</function> işlevi kullanılarak kaldırılması önerilir.
    </para>
   </warning>
   <para>
    <note>
     <para>
      <command>foreach</command>, hata iletilerinin '@' kullanılarak
      gözardı edilmesi özelliğini desteklemez.
     </para>
    </note>
   </para>
   <para>
    Aşağıdaki iki döngünün aynı işi yaptığını farkedeceksiniz:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$dizi = array("bir", "iki", "üç");
reset($dizi);
while (list(, $değer) = each($dizi)) {
    echo "Değer: $değer<br />\n";
}

foreach ($dizi as $değer) {
    echo "Değer: $değer<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
      Aşağıdakiler de işlevsel olarak aynıdır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$dizi = array("bir", "iki", "üç");
reset($dizi);
while (list($isim, $değer) = each($dizi)) {
    echo "Anahtar: $isim; Değer: $değer<br />\n";
}

foreach ($dizi as $isim => $değer) {
    echo "Anahtar: $isim; Değer: $değer<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Değişik kullanımlara örnekler:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach örneği 1: yalnızca değer */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "\$a değişkeninin şu anki değeri: $v.\n";
}

/* foreach örneği 2: değer (örnek olması için anahtar
 *  ile birlikte yazdırılmıştır) */

$a = array(1, 2, 3, 17);

$i = 0; /* yalnızca örnekleme için */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach örneği 3: anahtar ve değer */

$a = array(
    "bir" => 1,
    "iki" => 2,
    "üç"  => 3,
    "on yedi" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach örneği 4: çok boyutlu diziler */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach örneği 5: devingen diziler */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><code>break</code></title>
   <simpara>
    <command>break</command> deyimi, <command>for</command>,
    <command>foreach</command>, <command>while</command>,
    <command>do-while</command> ve <command>switch</command> yapılarının
    çalışmasını sonlandırmak için kullanılır.
   </simpara>
   <simpara>
    <command>break</command> deyiminde istenirse bir sayısal ifade
    belirtilebilir. Bu sayı iç içe yapılardan içten dışa kaç yapının aynı
    anda durdurulacağını belirler.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('sıfır', 'bir', 'iki', 'üç', 'dur', 'dört', 'beş');
while (list(, $val) = each($arr)) {
    if ($val == 'dur') {
        break;    /* Burada 'break 1;' de yazabilirsiniz. */
    }
    echo "$val<br />\n";
}

/* Sayısal değer kullanımı. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "5'de<br />\n";
        break 1;  /* Yalnızca switch'ten çıkar. */
    case 10:
        echo "10'da; çıkılıyor<br />\n";
        break 2;  /* switch ve while'dan aynı anda çıkılır. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><code>continue</code></title>
   <simpara>
    <command>continue</command> deyimi döngü yapılarının içinde kullanılır.
    Bu deyim kullanıldığında, döngünün kalan kısmı atlanır ve
    sonraki yineleme başlatılır.
   </simpara>
   <note>
    <simpara>
      PHP'de <link linkend="control-structures.switch">switch</link> deyimi
      <command>continue</command> deyiminin kullanılabileceği döngülerden
      biri olarak kabul edilmektedir.
    </simpara>
   </note>
   <simpara>
    <command>continue</command> deyimi ile seçime bağlı sayısal bir değer
    kullanılarak, atlama işleminin kaç seviye üstteki döngüye kadar
    uygulanacağı belirtilebilir.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // tek sayıları atla
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Dış<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Orta<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;İç<br />\n";
            continue 3;
        }
        echo "Bu hiçbir zaman çıktı vermez.<br />\n";
    }
    echo "Bundan da çıktı alamazsınız.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
    <command>continue</command> deyiminden sonra noktalı virgül konmazsa
    bu durum karışıklığa yol açabilir. Yapmamanız gereken ile ilgili bir
    örnek:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Şu biçimde bir çıktı almayı bekleyebilirsiniz:
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       Ancak çıktı şu şekilde olacaktır:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
      Bunun sebebi <function>print</function> işlevinden dönen
      değerin <command>int(1)</command> olması ve bu dönen değerin
      PHP tarafından yukarıda bahsedilen seçime sağlı sayısal değer
      olarak algılanmasıdır.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><code>switch</code></title>
   <simpara>
    <command>switch</command> deyimi, aynı ifade içersinde yer alan bir dizi
    IF deyimine benzer. Birçok durumda, aynı değişkeni (ya da ifadeyi)
    birden çok değerle karşılaştırmak ve her karşılaştırmanın sonucunu
    ayrı bir kod parçası çalıştırarak değerlendirmek istersiniz. İşte bu,
    <command>switch</command> deyiminin varlık sebebidir.
   </simpara>
   <note>
    <simpara>
      Başka bazı dillerden farklı olarak, <link
      linkend="control-structures.continue">continue</link> deyimi
      <command>switch</command> ile uygulanabilir ve
      <command>break</command> ile benzerlik gösterir. Bir döngü içerisinde
      <command>switch</command> kullandıysanız ve kodun yürütülmesine
      dıştaki döngünün sonraki yinelemeden devam etmesini istiyorsanız,
      <command>continue 2</command> kullanabilirsiniz.
    </simpara>
   </note>
   <note>
    <para>
     <command>switch</command> ve <command>case</command>
     <link linkend="types.comparisions-loose">gevşek karşılaştırma</link>
     yapar.
    </para>
   </note>
   <para>
    Aşağıdaki iki örnek aynı şeyi yazmanın iki farklı yolunu göstermektedir.
    Birincisi bir dizi <command>if</command> ve  <command>elseif</command>
    deyiminin kullanımını, ikincisi ise <command>switch</command> deyiminin
    kullanımını örneklemektedir:
    <example>
     <title>- <code>switch</code> yapısı</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i eşittir 0";
} elseif ($i == 1) {
    echo "i eşittir 1";
} elseif ($i == 2) {
    echo "i eşittir 2";
}

switch ($i) {
case 0:
    echo "i eşittir 0";
    break;
case 1:
    echo "i eşittir 1";
    break;
case 2:
    echo "i eşittir 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>- <code>switch</code> ile dizge kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "elma":
    echo "i bir elmadır";
    break;
case "çikolata":
    echo "i bir çikolatadır";
    break;
case "kek":
    echo "i bir kektir";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Hatalardan kaçınmak için <command>switch</command> deyiminin nasıl
    çalıştığını anlamak önemlidir. <command>switch</command> deyimi satır
    satır ele alınır (aslında deyim deyim). Başlangıçta, hiçbir kod
    çalıştırılmaz. Yalnızca <command>switch</command> ifadesiyle birlikte
    verilen değer ile uyuşan <command>case</command> deyimi bulunduğunda PHP
    ilgili deyimleri çalıştırmaya başlar. PHP <command>switch</command>
    bloğu sonlanana kadar ya da ilk <command>break</command> deyimi ile
    karşılaşıncaya kadar çalışmasına devam eder. Bir case bloğunun sonuna
    <command>break</command> koymazsanız, PHP sonraki
    <command>case</command> deyiminden kodları çalıştırmaya devam eder.
    Örnek:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eşittir 0";
case 1:
    echo "i eşittir 1";
case 2:
    echo "i eşittir 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
     Burada, <varname>$i</varname> 0'a eşit ise, PHP tüm <code>echo</code>
     deyimlerini çalıştıracaktır! <varname>$i</varname> 1'e eşit ise, PHP
     son iki <code>echo</code> deyimini çalıştıracaktır! Beklediğiniz sonucu
     ('i eşittir 2' metninin görüntülenmesi) yalnızca <varname>$i</varname>
     2'ye eşitse almanız mümkün olacaktır. Bu durumun oluşmaması için,
     <command>break</command> deyimini kullanmayı unutmamanız önemlidir
     (yine de, bazı durumlarda <command>break</command> deyimini kullanmak
     istemeyebilirsiniz).
   </simpara>
   <simpara>
    Bir <command>switch</command> deyiminde, koşul yalnızca bir defa
    sorgulanır ve sonuç her bir <command>case</command> deyimi ile
    karşılaştırılır. Bir <command>elseif</command> deyiminde ise, koşul
    tekrar sorgulanır. Kullanmak istediğiniz koşul basit bir karşılaştırma
    işleminden daha karmaşıksa ve/veya bir döngü içerisindeyse,
    <command>switch</command> kullanmak daha hızlı olabilir.
   </simpara>
   <para>
    <command>case</command> bloğu kod içermeyebilir ve amacı yalnızca
    denetimi bir sonraki <command>case</command> bloğuna geçirmek olabilir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i 3'ten küçüktür ama negatif değildir";
    break;
case 3:
    echo "i eşittir 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   <command>default</command> durumu özel bir durumdur. Bu durum diğer
   hiçbir <command>case</command> ile uyuşmayan değerler için kullanılır ve
   en sonda yer almalıdır. Örneğin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eşittir 0";
    break;
case 1:
    echo "i eşittir 1";
    break;
case 2:
    echo "i eşittir 2";
    break;
default:
    echo "i ne 0, ne 1 ne de 2'ye eşittir";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <command>case</command> ifadesi bir basit tür olarak
    değerlendirilebilecek herhangi bir tür olabilir; yani, tam sayı
    (<type>integer</type>), gerçel sayı (<type>float</type>) veya dizge
    (<type>string</type>) olabilir. Diziler (<type>array</type>) ya da
    nesneler (<type>object</type>), bir basit türe indirgenmedikleri sürece
    kullanılamazlar.
   </para>
   <para>
    İki noktalı sözdizimi <command>switch</command> deyimi için de
    desteklenmektedir. Daha fazla bilgi için, <link
    linkend="control-structures.alternative-syntax">Denetim yapıları için
    diğer söz dizimi</link> bölümünü inceleyebilirsiniz.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i eşittir 0";
    break;
case 1:
    echo "i eşittir 1";
    break;
case 2:
    echo "i eşittir 2";
    break;
default:
    echo "i ne 0, ne 1 ne de 2'ye eşittir;
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <command>case</command>’ten sonraki iki nokta yerine aşağıdaki gibi
    deyim sonunda noktalı virgül kullanmak da mümkündür:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch($içecek)
{
    case 'su';
    case 'süt';
    case 'ayran';
        echo 'İyi seçim';
    default;
        echo 'Lütfen yeniden seçiniz...';
    break;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><code>declare</code></title>
   <para>
   <command>declare</command> yapısı bir kod bloğunun çalıştırılması
   esnasında uygulanacak yönergeleri belirlemek için kullanılır.
   <command>declare</command> yapısının sözdizimi diğer akış denetim
   yapılarının söz dizimi ile benzerdir:
    <informalexample>
     <programlisting>
<![CDATA[
declare (yönerge)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <replaceable>yönerge</replaceable> bölümü, <command>declare</command>
    bloğunun davranışını belirlemek için kullanılır. Şimdilik yalnızca iki
    yönerge kullanılabilmektedir: <command>ticks</command> yönergesi (Daha
    fazla bilgi edinmek için aşağıya, <link
    linkend="control-structures.declare.ticks">ticks</link> yönergesine
    bakınız.) ve <command>encoding</command> yönergesi.
   </para>
   <note>
    <simpara>
     <command>encoding</command> yönergesi PHP 5.3.0'da eklenmiştir.
    </simpara>
   </note>
   <para>
    <command>declare</command> bloğunun <replaceable>deyim</replaceable>
    bölümünün nasıl çalıştırılacağı ve çalışma esnasındaki yan etkilerinin
    ne olacağı <replaceable>yönerge</replaceable> bölümünde belirtilen
    yönergeye bağlı olabilir.
   </para>
   <para>
    <command>declare</command> bloğu kendinden sonra gelen tüm kodu
    etkilemesi için genel betik kapsamında da kullanılabilir. Bununla
    birlikte, <command>declare</command> bloğu dahil edilen bir dosyanın
    içindeyse ebeveyn dosya bundan etkilenmez.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// aşağıdaki iki örnek aynıdır:

// bunu kullanabilirsiniz:
declare(ticks=1) {
    // betiğin tamamı burada
}

// ya da bunu kullanabilirsiniz:
declare(ticks=1);
    // betiğin tamamı burada
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title><code>ticks</code></title>
    <caution>
     <simpara>
      PHP 5.3.0'dan itibaren <code>ticks</code> kullanımı önerilmemektedir
      ve PHP 6.0.0'da kaldırılacaktır.
     </simpara>
    </caution>
    <para>Bir "tik", <command>declare</command> bloğu içersinde çözümleyici
    tarafından çalıştırılan her <varname>N</varname> deyimde bir ortaya
    çıkan bir olaydır. <varname>N</varname> değeri,
    <command>declare</command> bloğunun <replaceable>yönerge</replaceable>
    bölümünde <code>ticks=<varname>N</varname></code> kullanılarak
    belirtilir.
   </para>
   <para>
    Her tik ile oluşturulacak eylem
    <function>register_tick_function</function> işlevi ile belirtilir. Daha
    ayrıntılı bilgi için aşağıdaki örneğe bakınız. Her tik için birden fazla
    olayın oluşabileceğini gözardı etmeyiniz.
   </para>
   <para>
    <example>
     <title>- PHP kodunun bir bölümünün profili</title>
     <programlisting role="php">
<![CDATA[
<?php
// Çağrıldığında zamanı kaydeden bir işlev
function profile($dump = FALSE)
{
    static $profile;

    // Profilde saklanmış zamanı döndürür, sonra siler
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// Tik eylemcisini belirtelim
register_tick_function("profile");

// Declare bloğundan önce işlevi ilklendirelim
profile();

// Bir kod bloğu çalıştır, her iki deyimde bir tik oluştur
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Profilcide saklanan veriyi göster
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
      Örnekte, 'declare' bloğu içindeki alt seviye deyimler çalıştırılarak
      ve her çalıştırılan iki deyimden sonra zaman kaydedilerek bloğun
      içindeki PHP kodunun profili çıkarılmaktadır. Bu bilgi incelenerek,
      kod içinde yavaşlamaya sebep olan bölümlerin saptanmasında
      kullanılabilir. Bu işlem başka yöntemler kullanılarak da yapılabilir,
      ancak tikleri kullanmak daha basit ve kullanışlı bir yöntemdir.
   </para>
   <simpara>
    Tikler hata ayıklama, basit çok görevliliği gerçekleme, artalanda G/Ç
    işlemleri ve benzeri amaçlar için oldukça uygundur.
   </simpara>
   <simpara>
    Ayrıca, <function>register_tick_function</function> ve
    <function>unregister_tick_function</function> işlevlerini de inceleyin.
   </simpara>
   </sect2>
   <sect2 xml:id="control-structures.declare.encoding">
    <title><code>encoding</code></title>
     <para>
      Her betiğin karakter kodlaması betiğin başında <code>encoding</code>
      yönergesi ile belirtilebilir.
      <example>
        <title>- Betik için kodlama belirtmek</title>
        <programlisting role="php">
<![CDATA[
<?php
declare(encoding='ISO-8859-9');
// kodlar burada
?>
]]>
      </programlisting>
     </example>
    </para>

    <caution>
     <simpara>
      İsim alanları ile birlikte kullanıldığında, tek geçerli sözdizimi
      <literal>declare(encoding='...');</literal> olup, buradaki
      <literal>...</literal> kodlama değeridir.
      <literal>declare(encoding='...') {}</literal> sözdizimi isim alanları
      ile birlikte kullanıldığında bir çözümleme hatası ile sonuçlanacaktır.
     </simpara>
    </caution>
    <para>
     Karakter kodlaması bildirim değeri, PHP,
     <literal>--enable-zend-multibyte</literal> yapılandırma seçeneği ile
     derlenmediği takdirde PHP 5.3'te yoksayılır. PHP 6.0'da
     <code>encoding</code> yönergesi, dosya oluşturulurken hangi kodlamanın
     kullanıldığını tarayıcıya bildirmek için kullanılır. Meşru değerler,
     UTF-8 gibi karakter kodlaması isimleridir.
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
    Bir işlevin içinde kullanıldığında, <function>return</function>
    deyimi çalışmakta olan işlevi hemen sonlandırıp değiştirgesini çağrılan
    işlevin değeri olarak döndürür. <function>return</function> ayrıca, bir
    betiğin veya bir <function>eval</function> deyiminin çalışmasını
    sonlandırmak için de kullanılabilir.
   </simpara>
   <simpara>
    Betik genelinde çağrıldığında, betik dosyasının çalışmasını
    sonlandırılır. Eğer dosya <function>include</function> ya da
    <function>require</function> ile betik dosyasına dahil edilmiş bir dosya
    ise, <function>return</function> deyimi akış denetiminin ana dosyaya
    aktarılmasını sağlar. Dahası, <function>return</function> deyiminin
    çağrıldığı dosya <function>include</function> ile dahil edilmişse
    <function>return</function> değeri  <function>include</function>
    çağrısının değeri olarak dönecektir. <function>return</function> ana
    betik dosyasının içinden çağrıldığı takdirde, betiğin çalışması
    sonlandırılacaktır. Eğer <function>return</function> deyiminin
    çağrıldığı dosya, ismi &php.ini; içindeki <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> veya <link
    linkend="ini.auto-append-file">auto_append_file</link> yapılandırma
    seçenekleri ile atanan bir dosya ise bu betik dosyasının da çalışmasını
    sonlandıracaktır.
   </simpara>
   <simpara>
    Daha fazla bilgi için, <link linkend="functions.returning-values">Dönüş
    değerleri</link> bölümüne bakınız.
   </simpara>
   <para>
    <note>
     <simpara>
      <function>return</function> bir işlev değil bir dil oluşumu
      olduğundan, değiştirgesini içeren parantez
      <emphasis>yalnızca</emphasis> değiştirge bir ifade içeriyorsa
      zorunludur. Bir değişken döndürürken genellikle parantez kullanılmaz.
      Böyle bir durumda, PHP'nin daha az işlem yapması için bu yöntemi
      izlemeniz gerekir.
     </simpara>
    </note>
    <note>
     <simpara>
      Bir değişkeni gönderimli olarak döndürüyorsanız,
      <emphasis>asla</emphasis> parantez kullanmamalısınız, bu
      çalışmayacaktır. Bir deyimin sonucunu gönderimli olarak
      döndüremezsiniz, yalnızca değişkenler gönderimli olarak
      döndürülebilir. <literal>return ($a);</literal> kullanıyorsanız, bir
      değişken değil, bir ifadenin sonucunu <literal>($a)</literal>
      döndürüyorsunuz demektir (bu da elbette, <literal>$a</literal>
      değişkeninin değeridir).
      </simpara>
     </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><code>require</code></title>
   <simpara>
    <function>require</function> deyimi belirtilen dosyayı betiğe ekler ve
    çalıştırır.
   </simpara>
   <simpara>
     <function>require</function> belirtilen dosyayı betiğe ekler ve
     çalıştırır. Ekleme işleminin nasıl gerçekleştiğine dair ayrıntılı
     bilgiyi <function>include</function> bölümünde bulabilirsiniz.
   </simpara>
   <simpara>
     <function>require</function> ve <function>include</function>
     birçok yönden birbirine benzer. Tek farkları, başarısızlık
     durumunda ne yaptıklarıyla ilgilidir. <function>include</function> bir
     <link linkend="errorfunc.constants.errorlevels.e-warning">Uyarı</link>
     üretirken, <function>require</function> bir <link
     linkend="errorfunc.constants.errorlevels.e-error">Ölümcül Hata</link>
     üretir. Başka bir deyişle, kayıp bir dosyanın tüm işleyişi
     durdurmasını istiyorsanız <function>require</function> işlevini
     kullanmaktan çekinmeyin. <function>include</function> bu şekilde
     davranmayarak betiğin çalışmaya devam etmesine izin vermektedir.
     Uygun bir <link linkend="ini.include-path">include_path</link> ayarının
     yapılması yararlı olacaktır.
   </simpara>
   <para>
    <example>
     <title>- Basit <function>require</function> örnekleri</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Daha fazla örnek için kılavuzun <function>include</function> bölümüne
    bakabilirsiniz.
   </simpara>
   <para>
    <note>
     <simpara>
     PHP 4.0.2'den önce, kullanım şu şekildeydi:
     <function>require</function> betiğe dahil edeceği dosyayı, dosyadaki
     satır asla çalıştırılmayacak olsa bile okumaya çalışırdı. Şarta bağlı
     deyimler <function>require</function> deyimini etkilemez. Ancak,
     <function>require</function> deyiminin bulunduğu satır çalıştırılmazsa,
     hedef dosya içindeki hiçbir kod çalıştırılmazdı. Benzer şekilde,
     döngüsel yapılar da <function>require</function> işlevinin davranışını
     etkilemez. Hedef dosyanın içerisindeki kod döngüye konu olsa bile
     <function>require</function> işlevinin kendisi yalnızca bir defa
     çalıştırılırdı.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
    Bakabileceğiniz diğer kaynaklar:
    <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> ve <link
    linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><code>include</code></title>
   <simpara>
    <function>include</function> deyimi belirtilen dosyayı betiğe ekler ve
    içeriğini değerlendirir.
   </simpara>
   <simpara>
    Aşağıdaki belgeleme aynı zamanda <function>require</function> için de
    geçerlidir. <function>include</function> ile
    <function>require</function> arasındaki fark, okunacak ve işlenecek
    dosya bulunamadığında, <function>include</function> tarafından <link
    linkend="errorfunc.constants.errorlevels.e-warning">Uyarı</link>,
    <function>require</function> tarafından <link
    linkend="errorfunc.constants.errorlevels.e-warning">Ölümcül Hata</link>
    üretilmesidir. Başka bir deyişle, okunup işlenmek istenen dosya
    bulunamıyorsa, betiğin durdurulması için <function>require</function>
    kullanmanız gerekmektedir. <function>include</function> bu şekilde
    davranmaz ve betiğin çalışmaya devam etmesine izin verir. Bu deyimi
    kullanmadan önce <link linkend="ini.include-path">include_path</link>
    ayarınızın doğru olduğundan emin olun. PHP 4.3.5'den önceki sürümlerde,
    dahil edilen dosyadaki okuma hatası bir uyarıya sebep oluyor ama betiğin
    çalışmasını durdurmuyordu. Bu sürümden itibaren, betiğin çalışması
    durdurulmaktadır.
   </simpara>
   <simpara>
    Betiğe dahil edilecek dosyalar için öncelikle bulunulan dizine göreli
    olarak <code>include_path</code> yönergesinde belirtilmiş dosya
    yollarına sonra da içinde bulunulan dizine bakılır. Örneğin,
    <code>include_path</code> yönergesinde <literal>belgeler</literal>
    bulunuyor olsun; içinde bulunduğunuz dizin de /siteler/ olsun;
    <filename>altbetikler/a.php</filename> dosyasını dahil ediyorsanız ve bu
    dosyada da <literal>include "b.php"</literal> varsa,
    <filename>b.php</filename> dosyası için önce <filename
    class="directory">/siteler/belgeler/</filename> dizinine sonra da
    <filename class="directory">/siteler/altbetikler/</filename> dizinine
    bakılacaktır. Dosya ismi <command>./</command> ile ya da
    <command>../</command> ile başlıyorsa, dosya yalnızca içinde bulunulan
    dizine göre aranır.
   </simpara>
   <simpara>
    Bir dosya bir betiğe dahil edildiğinde, bu dosyanın içerdiği kod,
    dosyanın dahil edildiği satır itibariyle ana betikte geçerli olan <link
    linkend="language.variables.scope">değişken uzayını</link> miras alır.
    Yani, dosyanın dahil edildiği satıra kadar mevcut değişkenlerin hepsi
    dahil edilen dosyanın içinde kullanılabilir olacaktır. Bunun yanında,
    dahil edilen dosyada tanımlanmış işlevlerin ve sınıfların tamamı ana
    betiğin genelinde tanımlanmış sayılır.
   </simpara>
   <para>
     <example>
      <title>- Basit bir <function>include</function> örneği</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$renk = 'yeşil';
$meyve = 'elma';

?>

dnm.php
<?php

echo "Bir $renk $meyve"; // -> Bir

include 'vars.php';

echo "Bir $renk $meyve"; // -> Bir yeşil elma

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
    <command>include</command> deyimi, bir işlevin içinde kullanılırsa dahil
    edilmek istenen dosyanın içindeki tüm kodlar sanki o işlev içinde
    tanımlanmış gibi çalıştırılacaktır. Bu durumda dahil edilen dosyadaki
    kodlar, işlevin, dosyanın dahil edildiği noktadaki değişken uzayını
    miras alacaktır. Bu kuralın istisnası dosya dahil edilmeden önce
    çözümleyici tarafından işleme sokulan  <link
    linkend="language.constants.predefined">sihirli sabitler</link>dir.
   </simpara>
   <para>
     <example>
     <title>- İşlev içi <code>include</code> kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $renk;

    include 'vars.php';

    echo 'Bir $renk $meyve';
}

/* vars.php, foo() işlevinin etki alanındadır
 * dolayısıyla $meyve bu alanın dışında
 * kullanılamamaktadır. $renk ise global olarak
 * tanımlandığından kullanılabilir
 */
foo();                      // Bir yeşil elma
echo 'Bir $renk $meyve';    // Bir yeşil

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Bir dosya bir betiğe dahil edildiğinde, çözümleme işlemi PHP kipinden
    çıkıp hedef dosyanın başlangıcında HTML kipine geçer ve dosyanın sonuna
    kadar HTML kipinde kalır. Bu sebeple, hedef dosyanın içindeki kodlardan
    PHP kodları olarak çalıştırılacaklar <link
    linkend="language.basic-syntax.phpmode">PHP başlangıç ve bitiş
    etiketleri</link> arasına alınmalıdır.
   </simpara>
   <simpara>
    "<link linkend="ini.allow-url-fopen">URL fopen sarmalayıcıları</link>"
    PHP'de etkinleştirilmiş ise (öntanımlı yapılandırmada etkindirler),
    <command>include</command> deyiminde yerel dosya yolu belirtmek yerine
    (HTTP ya da desteklenen başka bir sarmalayıcı üzerinden - <xref
    linkend="wrappers"/> bölümününe bakınız) bir URL kullanabilirsiniz.
    Hedef sunucu, hedef dosyayı PHP kodu olarak çalıştırabiliyorsa, ana
    betikteki değişkenler dahil edilen dosyaya  bir URL istek dizgesi olarak
    HTTP GET ile aktarılabilir. Bu durum dahil edilen dosyaya ana dosyanın
    değişken uzayını miras olarak bırakmaktan biraz farklı bir şeydir; betik
    aslında uzak sunucuda çalıştırılıp yerel betiğe sonuçlar dahil
    edilmektedir.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>- HTTP üzerinden <code>include</code></title>
     <programlisting role="php">
<![CDATA[
<?php

/* Bu örnekte  mesela.dom sitesinin .php uzantılı dosyaları
 * çalıştırabildiği ama .txt uzantılıları çalıştırmadığı
 * varsayılmıştır. Ayrıca, buradaki 'Çalışır'ın manası
 * $foo ve $bar değişkenlerinin dahil edilen dosyada kullanılabilir
 * olduğudur. */

// Çalışmaz; dosya.txt dosyası mesela.dom sitesinde çalıştırılmaz
include 'http://mesela.dom/dosya.txt?foo=1&bar=2';

// Çalışmaz; yerel dosya sisteminde 'dosya.php?foo=1&bar=2'
// adında bir dosya olarak aranır.
include 'dosya.php?foo=1&bar=2';

// Çalışır.
include 'http://mesela.dom/dosya.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'dosya.txt';  // Çalışır.
include 'dosya.php';  // Çalışır.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Güvenlik uyarısı</title>
    <para>
    Uzaktaki dosya uzaktaki sunucu tarafından işlenebilir (dosyanın
    uzantısına ve uzaktaki sunucunun PHP çalıştırıp çalıştırmadığına bağlı
    olarak). Ancak, elde edilecek çıktı yerel sunucuda çalıştırılacağından
    bu işlemin sonucu mutlaka geçerli bir PHP betiği üretmek olmalıdır.
    Dosyanın uzaktaki sunucuda işlenip sadece sonucun çıktılanmasını
    istiyorsanız <function>readfile</function> işlevi daha iyi bir seçim
    olacaktır. Aksi takdirde, uzakta çalıştırılan betiğin geçerli ve istenen
    kodu üretebilmesini güvence altına alabilmek için özel bir çaba harcamak
    gerekir.
    </para>
   </warning>
   <para>
    Ayrıca, bu konuyla ilgili olarak <link linkend="features.remote-files"
    >Uzaktaki dosyaların kullanımı</link> belgesiyle
    <function>fopen</function> ve <function>file</function> işlevlerine de
    bakınız.
   </para>
   <simpara>
    <command>return</command> kullanımı: Dahil edilen dosyanın içersinde, bu
    dosyanın işlenmesi durdurmak ve dahil eden betiğe geri dönmek için
    <function>return</function> kullanılabilir. Ayrıca, dahil edilen
    dosyalardan değer döndürmek de mümkündür. Normal bir işlevde olduğu
    gibi, <command>include</command> çağrısından elde edilen değeri bir
    değişkene atayabilirsiniz. Ancak bu durum, uzaktaki dosyalar için,
    sadece uzaktaki dosyanın çıktısı <link
    linkend="language.basic-syntax.phpmode">geçerli PHP başlangıç ve bitiş
    etiketlerine</link> sahipse (herhangi yerel bir dosyada olduğu gibi),
    kullanılabilir. Gerekli değişkenler bu etiketlerin arasında
    tanımlandığında dosyanın dahil edildiği noktadan itibaren kullanılabilir
    olacaklardır.
   </simpara>
   <para>
    <command>include</command> özel bir dil oluşumu olduğundan,
    değiştirgesinin parantez içine alınması gerekmez. Dönüş değerini
    karşılaştırırken buna dikkat edin.
    <example>
     <title>- <code>include</code> dönüş değerinin karşılaştırılması</title>
     <programlisting role="php">
<![CDATA[
<?php
// çalışmaz, include(('vars.php') == 'TAMAM') olarak değerlendirilir,
// sonuç include('') olur
if (include('vars.php') == 'TAMAM') {
    echo 'TAMAM';
}

// çalışır
if ((include 'vars.php') == 'TAMAM') {
    echo 'TAMAM';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>- <code>include</code> ve <code>return</code> deyimleri</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // 'PHP' basar

$bar = include 'noreturn.php';

echo $bar; // 1 basar

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <command>include</command> işlemi başarılı olduğundan
    <literal>$bar</literal>, <literal>1</literal> değerine sahiptir.
    Yukarıdaki örnekler arasındaki farklara dikkat edin. Birincisi
    <function>return</function> deyimini dahil edilen dosyada kullanırken
    ikincisi kullanmıyor. Dosya dahil edilemediği durumda, &false;
    döndürülüyor ve bir <code>E_WARNING</code> üretiliyor.
   </simpara>
   <para>
    Dahil edilen dosyanın içinde tanımlanmış işlevler varsa,
    <function>return</function> deyiminden önce ya da sonra olduğundan
    bağımsız olarak ana betik içersinde kullanılabilirler. Dosya iki defa
    dahil edilmişse, PHP 5 ölümcül hata verir çünkü bildirilmiş işlevler
    tekrar bildirilmeye calışılmış olur. PHP 4 ise
    <function>return</function>'den sonra tanımlanmış işlevler için
    şikayetçi olmayacaktır. Dosyanın halihazırda dahil edilip edilmediğini
    kendiniz tespit edip koşula bağlı <function>return</function>
    çalıştırmak yerine, <function>include_once</function> kullanmanız
    önerilir.
   </para>
   <simpara>
    Bir PHP dosyasını bir değişkene "dahil" etmenin diğer bir yolu, çıktıyı
    <link linkend="ref.outcontrol">Çıktı Denetim İşlevleri</link>ni
    <function>include</function> ile birlikte kullanarak yakalamaktır. Örnek:
   </simpara>
   <para>
    <example>
     <title>- Bir PHP dosyasını bir dizgeye dahil etmek için tampon
     kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
      </programlisting>
    </example>
   </para>
   <para>
    Betiğinize dosyaları özdevinimli olarak dahil etmek için, &php.ini;
    içersindeki <link linkend="ini.auto-prepend-file"
    >auto_prepend_file</link> ve <link linkend="ini.auto-append-file"
    >auto_append_file</link> yapılandırma seçeneklerini inceleyebilirsiniz.
   </para>

   &note.language-construct;

   <simpara>
      Ayrıca, <function>require</function>,
      <function>require_once</function>, <function>include_once</function>,
      <function>readfile</function>, <function>virtual</function> ve
      <link linkend="ini.include-path">include_path</link>'a da bakınız.
   </simpara>
 </sect1>

 <sect1 xml:id="function.require-once">
   <title><code>require_once</code></title>
   <para>
    <function>require_once</function> deyimi belirtilen dosyayı betiğin
    çalışması esnasında okur ve çalıştırır. Bu deyimin çalışma biçimi
    <function>require</function> deyimi ile benzerdir, tek fark kendisiyle
    dahil edilmiş bir dosya betiğin başka bir yerinde tekrar dahil edilmek
    istenirse buna izin vermemesidir. Daha fazla bilgi için
    <function>require</function> belgesine bakabilirsiniz.
   </para>
   <para>
    <function>require_once</function> deyimi, bir betiğin çalışması
    esnasında aynı dosyanın bir kereden fazla dahil edilme ihtimaline karşı,
    bu dosyanın yalnızca bir kere dahil edileceğinden emin olunmak istenirse
    kullanılmalıdır. Bu sayede işlev bildirimlerinin yinelenmesi,
    değişkenlere tekrar değer atanması gibi sorunlar ortaya çıkmaz.
   </para>
   <para>
    <function>require_once</function> ve
    <function>include_once</function> ile ilgili örnekler için, PHP'nin en
    son kaynak kodu dağıtımında yer alan <link xlink:href="&url.php.pear;"
    >PEAR</link> kodlarını inceleyebilirsiniz.
   </para>
   <para>
    Dönen değerlerin yönetimi <function>include</function> ile aynıdır.
    Dosya dahil edilebilmişse, bu işlev &true; değerini döndürür.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> PHP 4.0.1 ile eklenmiştir.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Büyük-küçük harf duyarlı olmayan işletim sistemlerinde (Windows gibi),
      <function>require_once</function> ve <function>include_once</function>
      deyimlerinin beklediğiniz sonucu üretmeyebileceğine dikkat edin.
      <example>
       <title>- <function>require_once</function> Windows'ta büyük-küçük harf duyarsızdır</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // bu a.php dosyasını dahil eder
require_once("A.php"); // bu Windows altında yine a.php
                       // dosyasını dahil edecektir! (yalnızca PHP 4)
?>
]]>
        </programlisting>
      </example>
        Bu davranış PHP 5'te değişmiştir - öncelikle yol normalleştirilir,
        böylece <filename>C:\PROGRA~1\A.php</filename> ile
        <filename>C:\Program Files\a.php</filename> aynı kabul edilir ve
        dosya yalnızca bir defa işlenir.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Ayrıca bakınız: <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function> ve
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function> deyimi belirtilen dosyayı betiğin
    çalışması esnasında okur ve çalıştırır. Bu deyimin çalışma biçimi
    <function>include</function> deyimi ile benzerdir, kendisiyle dahil
    edilmiş bir dosya betiğin başka bir yerinde tekrar dahil edilmek
    istenirse buna izin vermemesidir. Daha fazla bilgi için
    <function>include</function> belgesine bakabilirsiniz.
   </para>
   <para>
    <function>include_once</function> deyimi, bir betiğin çalışması
    esnasında aynı dosyanın bir kereden fazla dahil edilme ihtimaline karşı,
    bu dosyanın yalnızca bir kere dahil edileceğinden emin olunmak istenirse
    kullanılmalıdır. Bu sayede işlev bildirimlerinin yinelenmesi,
    değişkenlere tekrar değer atanması gibi sorunlar ortaya çıkmaz.
   </para>
   <para>
    <function>require_once</function> ve <function>include_once</function>
    kullanımı ile ilgili daha fazla örnek için, PHP'nin en son kaynak kodu
    dağıtımında yer alan <link xlink:href="&url.php.pear;">PEAR</link>
    kodlarını inceleyebilirsiniz.
   </para>
   <para>
   Dönen değerlerin yönetimi <function>include</function> ile aynıdır.
   Dosya dahil edilebilmişse, bu işlev &true; değerini döndürür.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> PHP 4.0.1 sürümü ile eklenmiştir.
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
     Büyük-küçük harf duyarlı olmayan işletim sistemlerinde (Windows gibi),
     <function>require_once</function> ve <function>include_once</function>
     deyimlerinin beklediğiniz sonucu üretmeyebileceğine dikkat edin.
      <example>
       <title>- <function>include_once</function> Windows'ta büyük-küçük
       harf duyarsızdır</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // bu a.php dosyasını include edecektir
include_once("A.php"); // bu Windows altında yine a.php dosyasını include edecektir! (yalnızca PHP 4)
?>
]]>
        </programlisting>
      </example>
      Bu davranış PHP 5'te değişmiştir - öncelikle yol normalleştirilir,
      böylece <filename>C:\PROGRA~1\A.php</filename> ile
      <filename>C:\Program Files\a.php</filename> aynı kabul edilir ve dosya
      yalnızca bir defa işlenir.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Ayrıca bakınız: <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>
    ve <function>virtual</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
