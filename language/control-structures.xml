<?xml version="1.0" encoding="iso-8859-9"?>
<!-- $Revision: 1.3 $ -->
 <chapter id="language.control-structures">
  <title>Kontrol Yapýlarý</title>

  <simpara>
  Bütün PHP betikleri bir dizi deyimden (statement) oluþur. Bir deyim;
  bir atama, bir fonksiyonun çaðrýlmasý, bir döngü, bir koþullu deyim hatta
  hiçbir þey yapmayan bir deyim (boþ bir deyim) olabilir. Deyimler bir
  noktalý virgülle sonlandýrýlýr. Ek olarak, deyimler köþeli parantez içine
  alýnarak deyim gruplarý haline getirilebilirler. Bir deyim grubu da
  kendi baþýna bir deyim olarak kabul edilir. Bu bölümde çeþitli tiplerdeki
  deyimlerin anlatýmýný yapacaðýz.
  </simpara>

  <sect1 id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>If</literal> yapýsý, PHP dahil olmak üzere birçok programlama
    dilindeki en önemli özelliklerden biridir. Bu yapý, kod bölümlerinin koþullu
    olarak çalýþtýrýlabilmelerini saðlar. PHP, C dilindekine benzer bir
    <literal>if</literal> yapýsý sunar.
    <informalexample>
     <programlisting>
<![CDATA[
if (ifade)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   <link linkend="language.expressions">Ýfadelerle ilgili bölüm</link>de
   anlatýldýðý gibi, <replaceable>ifade</replaceable> kendi ikili deðeri (boolean value) üzerinden
   deðerlendirilir. <replaceable>Ýfade</replaceable> &true; deðerini oluþturuyorsa,
   PHP <replaceable>deyimi</replaceable> çalýþtýrýr, eðer &false; deðerini oluþturuyorsa gözardý eder.
   Hangi deðerlerin &false; olarak deðerlendirildiði hakkýnda daha fazla bilgi için <link
    linkend="language.types.boolean.casting">'Ýkili deðere dönüþtürmek'</link> bölümünden
    faydalanabilirsiniz.
   </simpara>
   <para>
   Buradaki örnek, <varname>$a</varname> deðeri <varname>$b</varname>
   deðerinden büyük olduðu takdirde <computeroutput>a büyüktür
    b</computeroutput> metnini görüntüleyecektir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a büyüktür b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Sýklýkla birden çok deyimin koþullu olarak çalýþtýrýlmasýný isteyeceksiniz.
   Elbette, her bir deyimi ayrý ayrý <literal>if</literal> yantümcelerine (clause)
   almanýza gerek yoktur. Birden çok deyimi biraraya getirerek tek bir deyim grubu
   oluþturabilirsiniz. Örneðin, Bu kod <varname>$a</varname> deðeri
   <varname>$b</varname> deðerinden büyük olduðu takdirde
   <computeroutput>a büyüktür b</computeroutput> metnini görüntüleyecektir ve
   sonrasýnda <varname>$a</varname> deðiþkeninin deðerini 
   <varname>$b</varname> deðiþkenine atayacaktýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal> deyimleri sonsuz sayýda diðer
    <literal>if</literal> deyiminin içine gömülebilir. Bu size
    uygulamanýzýn çeþitli bölümlerinde koþullu deyimler
    uygulayabilmeniz için tam bir esneklik saðlar.
   </simpara>
  </sect1>

  <sect1 id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
   Çoðu zaman belli bir koþul saðlandýðýnda bir deyimin, o koþul saðlanmadýðýnda
   baþka bir deyimin çalýþtýrýlmasýný isteyeceksiniz. Bu yapýyý saðlamak için
   <literal>else</literal> kullanýlmaktadýr. <literal>Else</literal>,
   bir <literal>if</literal> deyiminin geniþleyerek, belirtilen koþul saðlanmadýðý
   ve &false; döndürdüðü takdirde ne yapýlacaðýný belirtmek için kullanýlýr.
   Örneðin, buradaki kod <varname>$a</varname>
   deðeri <varname>$b</varname> deðerinden büyükse
   <computeroutput>a büyüktür b</computeroutput> mesajýný,
   büyük deðilse <computeroutput>a büyük deðildir b</computeroutput>
   mesajýný görüntüleyecektir:
   <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} else {
    echo "a büyük deðildir b";
}
?>
]]>
     </programlisting>
    </informalexample>

    <literal>Else</literal> deyimi yalnýzca <literal>if</literal> deyiminin
    &false; döndürdüðü durumda çalýþtýrýlacaktýr. Ayný durum, &false;
    döndüren herhangi bir <literal>elseif</literal> ifadesinin olmasý durumunda da
    geçerlidir (bakýnýz <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>

  <sect1 id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, isminden de anlaþýlacaðý gibi, <literal>if</literal> ve
    <literal>else</literal> deyimlerinin biraraya gelmesiyle oluþur. 
    <literal>else</literal> gibi, orijinal <literal>if</literal> ifadesinin
    &false; döndürdüðü durumda farklý bir deyimin çalýþtýrýlmasý için kullanýlýr.
    Ancak, <literal>else</literal>'ten faklý olarak, bu deyim alternatif ifadeyi
    yalnýzca kendisine ait koþullu ifade &true; deðerini döndürdüðü durumda çalýþtýracaktýr.
    Örneðin, buradaki kod <computeroutput>a büyüktür b</computeroutput>,
    <computeroutput>a eþittir b</computeroutput> ya da 
    <computeroutput>a küçüktür b</computeroutput> mesajýný görüntüleyecektir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} elseif ($a == $b) {
    echo "a eþittir b";
} else {
    echo "a küçüktür b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Ayný <literal>if</literal> deyimine ait birden çok <literal>elseif</literal>
   bulunabilir. Ýlk önce hangi <literal>elseif</literal> deyimi &true; deðerini
   döndürürse (eðer döndüren varsa) o deyim çalýþtýrýlýr. Bu deyimi 'elseif'
   biçiminde tek sözcük olarak kullanabileceðiniz gibi, 'else if' biçiminde iki
   sözcük olarak da kullanabilirsiniz, sonuç ayný olacaktýr. Sözdimi anlamý açýsýndan
   küçük bir farklýlýk olsa da (C diline aþinaysanýz, ayný fark) sonuç olarak her ikisi
   de ayný sonucu üretecektir.
   </simpara>
   <simpara>
   <literal>elseif</literal> ifadesi yalnýzca kendisinden önceki <literal>if</literal> ifadesi
   ve bu ifadeye baðlý kendisinden önce gelen diðer tüm <literal>elseif</literal> ifadeleri &false; olduðunda
   çalýþtýrýlýr ve &true; deðerini döndürür.
   </simpara>
  </sect1>

  <sect1 id="control-structures.alternative-syntax">
   <title>Kontrol yapýlarý için alternatif sözdizimi</title>
   <para>
   PHP bazý kontrol yapýlarý için alternatif sözdizimi imkanlarý sunar.
   Bunlar <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> ve <literal>switch</literal> yapýlarýdýr.
    Her bir durumda, alternatif sözdiziminin basit þekli açýlýþta kullanýlan köþeli parantez
    yerine iki nokta üst üste (:) kullanmak ve kapanýþta kullanýlan köþeli parantez yerine
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal> ya da
    <literal>endswitch;</literal> deyimlerinden birini kullanmaktýr.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A eþittir 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Yukarýdaki örnekte, içeriði "A eþittir 5" olan HTML bloðu alternatif sözdimi
   kullanýlarak yazýlmýþ bir <literal>if</literal> deyiminin içine gömülmüþtür.
   HTML bloðu yalnýzca <varname>$a</varname> deðiþkeni 5'e eþit olduðunda
   gösterilecektir.
   </simpara>
   <para>
   Alternatif sözdimi, <literal>else</literal> ve <literal>elseif</literal>
   için de kullanýlabilir. Birazdan vereceðimiz örnek, alternatif format ile yazýlmýþ
   ve <literal>elseif</literal> ile <literal>else</literal> içeren bir
   <literal>if</literal> yapýsýdýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a eþittir 5";
    echo "...";
elseif ($a == 6):
    echo "a eþittir 6";
    echo "!!!";
else:
    echo "a ne 5 ne de 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Daha fazla örnek için <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, ve <link
    linkend="control-structures.if">if</link> bölümlerine bakabilirsiniz.
   </para>
  </sect1>

  <sect1 id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal> döngüsü PHP'de yer alan en basit döngü tipidir.
    C'deki karþýlýðý ile ayný þekilde çalýþýr. Bir <literal>while</literal> deyiminin
    basit kullanýmý:
    <informalexample>
     <programlisting>
<![CDATA[
while (ifade)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   <literal>While</literal> deyiminin anlamý basittir. Kendi kapsama
   alaný içinde tanýmlanmýþ deyimlerin tekrar tekrar çalýþtýrýlmasýný
   saðlar. Tekrar çalýþtýrma iþlemi <literal>while</literal> deyimine
   ait ifadenin karþýlýðý &true; oldukça devam eder. Ýfadenin deðeri döngü
   her tekrarlandýðýnda yeniden hesaplanýr, deyimlerin çalýþtýrýlmasý
   sýrasýnda bu ifadenin deðeri deðiþse bile, döngü içindeki deyimler
   en son adýma kadar çalýþtýrýlmaya devam edilir (PHP'nin döngü içindeki
   deyimleri her çalýþtýrýþý bir döngüyü ifade etmektedir). Bazen,
   <literal>while</literal> ifadesi daha ilk tekrardan önce &false; deðerini
   verir, bu durumda <literal>while</literal> kapsamýndaki deyimler
   tek bir defa bile çalýþtýrýlmazlar.
   </simpara>
   <para>
   <literal>If</literal> deyiminde olduðu gibi, birden çok deyimi ayný
   <literal>while</literal> döngüsü içinde köþeli parantez kullanarak ya da
   alternatif sözdimi yönteminden faydalanarak gruplayabilirsiniz:
   <informalexample>
     <programlisting>
<![CDATA[
while (ifade):
    deyimler
    ...
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Aþaðýdaki örnekler birbirleri ile aynýdýrlar, her ikisi de 1'den 10'a kadar
   rakamlarý yazacaktýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* yazdýrýlan deðer $i
                    deðerinin artýþtan önceki
                    deðeridir (sonda-arttýrým) */
}

/* örnek 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    <literal>do-while</literal> döngüsü,
    <literal>while</literal> döngüsü ile oldukça benzerdir.
    <literal>do-while</literal> döngüsünün farký, kontrol edilecek
    ifadenin tekrarlarýn baþýnda deðil sonunda kontrol ediliyor olmasýdýr.
    <literal>while</literal> döngüsü ile temek farklýlýk, <literal>do-while</literal>
    kullanýldýðýnda ilk tekrarýn çalýþmasýnýn garanti altýna alýnýyor olmasýdýr
    (ifadenin doðruluðu yalnýzca tekrarýn sonunda kontrol edilecektir). 
    <literal>while</literal> döngüsü, ifadenin kontrolünü her bir tekrardan önce
    yapmaktadýr, ilk tekrar öncesinde &false; deðeri alýndýðý takdirde, döngü daha
    baþlamadan sona erecektir.
   </simpara>
   <para>
   <literal>do-while</literal> döngüsü için yalnýzca tek bir sözdizimi mevcuttur:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Yukarýdaki döngü tam olarak bir defa çalýþacaktýr, ilk tekrardan sonra ifadenin
   doðruluðu kontrol edildiðinde, &false; deðerini verecek ($i büyük deðildir 0) ve
   döngünün çalýþmasý sonlanacaktýr.
   </simpara>
   <para>
   Ýleri seviye C kullanýcýlarý <literal>do-while</literal> döngüsünün
   farklý kullanýmlarýna aþina olabilirler. Bu döngü, kod bloklarýnýn çalýþtýrýldýklarý
   esnada çalýþmanýn ortasýnda sonlandýrýlmalarýný saðlamak için kullanýlabilir.
   Bu iþlem kod bloðunu <literal>do-while</literal> (0) döngüsü içine alýp
   <link linkend="control-structures.break"><literal>break</literal> deyimi
   kullanýlarak yapýlabilmektedir. Aþaðýdaki kod parçasý bu durumu örneklemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i yeterince büyük deðil";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "i uygun";

    /* i deðerini iþle */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Bu yöntemi anlamadýysanýz endiþelenmeyin. Bu 'özelliði' kullanmadan
   da oldukça geliþmiþ ve güçlü uygulamalar geliþtirebilirsiniz.
   </simpara>
  </sect1>

  <sect1 id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal> döngüsü, PHP dahilindeki en karmaþýk döngü
    yapýsýdýr. C'deki karþýlýðý ile ayný biçimde çalýþýr. <literal>for</literal>
    döngüsünün sözdimi þu þekildedir:
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Ýlk ifade (<varname>expr1</varname>) döngünün en baþýnda
   tek bir defa koþulsuz olarak çalýþtýrýlýr.
   </simpara>
   <simpara>
   Her bir tekrarýn baþýnda, <varname>expr2</varname> çalýþtýrýlýr.
   Bu ifadeden &true; sonucu elde edilirse, döngüye devam edilir ve döngü
   dahilindeki deyimler çalýþtýrýlýr. Bu ifadeden &false; sonucu elde edilirse,
   döngünün çalýþmasý sonlandýrýlýr.
   </simpara>
   <simpara>
   Her bir tekrarýn sonunda, <varname>expr3</varname>
   çalýþtýrýlýr.
   </simpara>
   <simpara>
   Ýfadelerin herbiri için boþ kullaným mümkündür.
   <varname>expr2</varname> ifadesinin boþ olmasý, döngünün
   sonsuza kadar çalýþtýrýlacaðý anlamýna gelir (PHP C'deki gibi bu durumu
   &true; olarak deðerlendirir). Döngüleri sýklýkla bir þarta baðlý olarak
   <link linkend="control-structures.break"><literal>break</literal>
   deyimi ile sonlandýrmak isteyeceðiniz düþünüldüðünde, bu durum
   düþündüðünüz kadar kullanýþsýz deðildir. Bu kullaným size
   <literal>for</literal> deyiminin imkanlarýndan daha fazla esneklik
   saðlayabilir.
   </simpara>
   <para>
   Aþaðýdaki örnekleri inceleyin ve karþýlaþtýrýn. Hepsi de 1'den 10'a kadar
   rakamlarý görüntülemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* örnek 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* örnek 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* örnek 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Elbette, kullandýðýmýz ilk örnek en güzel örnek olarak gözükmektedir (
   ya da belki dördüncü örnek), ancak birçok durumda <literal>for</literal>
   döngüsü içerisinde boþ ifadeler kullanmanýn oldukça kullanýþlý olduðu
   sonucuna varabilirsiniz.
   </simpara>
   <para>
   PHP, alternatif "iki nokta üst üste" sözdimi þeklini
   <literal>for</literal> döngüleri için de desteklemektedir.
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3):
    deyimler
    ...
endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
   PHP 4 ile birlikte Perl ve bazý diðer dillerde mevcut olan
   <literal>foreach</literal> yapýsý da kullanýma sunulmuþtur.
   Bu deyimi dizi-deðiþkenler üzerinde tekrar iþlemleri yapmayý
   kolaylaþtýrmaktadýr. <literal>foreach</literal> yalnýzca
   diziler için kullanýlabilir; farklý bir deðiþken veri tipi ile ya da henüz
   oluþturulmamýþ bir deðiþken ile kullanmak istediðinizde hata oluþturacaktýr.
   Ýki türlü sözdizimi mevcuttur; ikinci kullaným þekli birinciden biraz daha uzun
   ama biraz daha kullanýþlýdýr:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value)
    deyimler
foreach (array_expression as $key => $value)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Ýlk yöntem <literal>array_expression</literal> ile belirtilen
   dizinin üzerinde döngü oluþturur. Her tekrarda, mevcut elemanýn
   deðeri <literal>$value</literal> deðiþkenine atanýr ve dizinin
   iç imleci bir ilerletilir (böylece sonraki tekrarda, son elemana
   bakýlýyor olmasý saðlanýr).
   </simpara>
   <simpara>
   Ýkinci yöntem ayný þeyi yapar, yalnýzca her tekrarda mevcut elemanýn
   anahtar deðeri <literal>$key</literal> deðiþkenine atanýr.
   </simpara>
   <simpara>
   PHP 5'den itibaren, <link linkend="language.oop5.iterations">nesneler üzerinde tekrar yapmak</link>
   mümkün olmuþtur.
   </simpara>
   <para>
    <note>
     <para>
     <literal>foreach</literal> ilk çalýþmaya baþladýðýnda, dizinin iç imleci
     otomatik olarak ilk elemaný gösterecek biçimde sýfýrlanýr. Bu sebeple
     <literal>foreach</literal> deyiminden önce <function>reset</function>
     fonksiyonunu çalýþtýrmanýza gerek yoktur.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
     Dizi <link linkend="language.references">referans edilmiþ</link> olmadýðý
     sürece, <literal>foreach</literal> dizinin kendisi üzerinde çalýþmaz,
     bir kopyasý üzerinde çalýþýr. Bundan dolayý dizi imleci <function>each</function>
     yapýsýnda olduðu gibi deðiþtirilmez, ve döndürülen dizi elemaný üzerinde yapýlan
     deðiþiklikler orijinal diziye yansýtýlmaz. Öte yandan, orijinal dizinin imleci
     dizi üzerinde iþlem yapýldýkça <emphasis>ilerler</emphasis>. foreach döngüsünün
     çalýþmasý tamamlandýðýnda, dizinin iç imleci de dizinin sonuna gelmiþ olacaktýr.
     </para>
     <para>
     PHP 5'den itibaren, dizinin elemanlarý üzerinde <literal>$value</literal> deðiþkeninin
     önüne &amp; koyarak deðiþiklik yapabilirsiniz. Bu kullaným deðerin bir kopyasýný kullanmak
     yerine kendisine bir <link linkend="language.references">referans</link> atanmasýný
     saðlayacaktýr:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr þimdi array(2, 4, 6, 8) olmuþtur
?>
]]>
       </programlisting>
      </informalexample>
      Bu durum yalnýzca üzerinde çalýþýlan dizi referans oluþturulabilir
      türde ise mümkündür (örn. bir deðiþkense).
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal> ile hata mesajlarýnýn '@' kullanýlarak
      gözardý edilmesi mümkün deðildir.
     </para>
    </note>
   </para>
   <para>
   Ýþlevsel olarak aþaðýdakilerin birbirleri ile ayný olduðunu tespit
   etmiþ olabilirsiniz:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("bir", "iki", "üç");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Deðer: $value<br />\n";
}

foreach ($arr as $value) {
    echo "Deðer: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Aþaðýdakiler de iþlevsel olarak aynýdýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("bir", "iki", "üç");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Anahtar: $key; Deðer: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Anahtar: $key; Deðer: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Deðiþik kullanýmlara örnekler:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach örnek 1: yalnýzca deðer */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "\$a deðiþkeninin þu anki deðeri: $v.\n";
}

/* foreach örnek 2: deðer (örnek olmasý için anahtar ile birlikte yazdýrýlmýþtýr) */

$a = array(1, 2, 3, 17);

$i = 0; /* for yalnýzca örnekleme için */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach örnek 3: anahtar ve deðer */

$a = array(
    "bir" => 1,
    "iki" => 2,
    "üç" => 3,
    "on yedi" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach örnek 4: çok boyutlu diziler */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach örnek 5: dinamik diziler */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> deyimi,
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal> veya
    <literal>switch</literal> yapýlarýnýn çalýþmasýný durdurmak için kullanýlýr.
   </simpara>
   <simpara>
    <literal>break</literal> deyimi ile seçime baðlý bir sayýsal argüman
    kullanýlabilir. Bu argüman iç içe kaç tane yapýnýn ayný anda durdurulacaðýný
    belirler.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('sifir', 'bir', 'iki', 'üç', 'dur', 'dört', 'beþ');
while (list(, $val) = each($arr)) {
    if ($val == 'dur') {
        break;    /* Ayný zamanda 'break 1;' de yazabilirsiniz. */
    }
    echo "$val<br />\n";
}

/* Seçime baðlý argümanýn kullanýmý. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "5'de<br />\n";
        break 1;  /* Yalnýzca switch'ten çýkar. */
    case 10:
        echo "10'da; çýkýlýyor<br />\n";
        break 2;  /* switch ve while'dan birlikte çýkýlýr. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> deyimi döngü yapýlarýnýn arasýnda kullanýlýr.
    Bu deyim kullanýldýðýnda, döngünün kalan kýsmý atlanýr ve
    sonraki döngü tekrarýna baþlanýlýr.
   </simpara>
   <note>
    <simpara>
    PHP'de
     <link linkend="control-structures.switch">switch</link> deyimi
     <literal>continue</literal> deyiminin kullanýlabileceði döngülerden
     biri olarak kabul edilmektedir.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> deyime ile seçime baðlý sayýsal bir argüman
    kullanýlarak, kaç seviye üstteki döngüye kadar atlama iþleminin uygulanacaðý
    belirtilebilir.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // tek sayýlarý atla
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Dýþ<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Orta<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Ýç<br />\n";
            continue 3;
        }
        echo "Bu hiçbir zaman çýktý vermez.<br />\n";
    }
    echo "Bundan da çýktý alamazsýnýz.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
    <literal>continue</literal> deyiminden sonra noktalý virgül konmazsa
    bu durum karýþýklýða yol açabilir. Yapmamanýz gereken ile ilgili bir örnek:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Þu biçimde bir çýktý almayý bekleyebilirsiniz:
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       Ancak beklenen çýktý þu þekilde olacaktýr:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
      Bunun sebebi <function>print</function> fonksiyonundan dönen
      deðerin <literal>int(1)</literal> olmasý ve bu dönen deðerin
      PHP tarafýndan yukarýda bahsedilen seçime saðlý sayýsal argüman
      olarak algýlanmasýdýr.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal> deyimi, ayný ifade içersinde yer alan bir dizi
    IF deyimine benzer. Birçok durumda, ayný deðiþkeni (ya da ifadeyi)
    birden çok deðerle karþýlaþtýrmak ve her karþýlaþtýrmanýn sonucunu
    ayrý bir kod parçasý çalýþtýrarak deðerlendirmek istersiniz. Bu tam olarak
    <literal>switch</literal> deyiminin varlýk sebebidir.
   </simpara>
   <note>
    <simpara>
    Baþka bazý dillerden farklý olarak, <link linkend="control-structures.continue">continue</link>
    deyimi switch ile uygulanabilir ve <literal>break</literal> ile benzerlik
    gösterir. Bir döngü içerisinde switch kullandýysanýz ve kodun yürütülmesine
    dýþtaki döngünün tekrarlanmasýyla devam etmek istiyorsanýz, <literal>continue 2</literal>
    sözdizimini kullanabilirsiniz.
    </simpara>
   </note>
   <para>
   Aþaðýdaki iki örnek ayný þeyi yazmanýn iki farklý yolunu göstermektedir.
   Birincisi bir dizi <literal>if</literal> ve  <literal>elseif</literal>
   deyiminin kullanýmýný, ikincisi ise <literal>switch</literal>
   deyiminin kullanýmýný örneklemektedir:
    <example>
     <title><literal>switch</literal> yapýsý</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i eþittir 0";
} elseif ($i == 1) {
    echo "i eþittir 1";
} elseif ($i == 2) {
    echo "i eþittir 2";
}

switch ($i) {
case 0:
    echo "i eþittir 0";
    break;
case 1:
    echo "i eþittir 1";
    break;
case 2:
    echo "i eþittir 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>switch</literal> ile karakter dizisi kullanýmý</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "elma":
    echo "i bir elmadýr";
    break;
case "çikolata":
    echo "i bir çikolatadýr";
    break;
case "kek":
    echo "i bir kektir";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
   Hatalardan kaçýnmak için <literal>switch</literal> deyiminin
   nasýl çalýþtýðýný anlamak önemlidir. <literal>Switch</literal>
   deyimi satýr satýr çalýþýr (yani deyim deyim). Baþlangýçta,
   hiçbir kod çalýþtýrýlmaz. Yalnýzca <literal>switch</literal> 
   ifadesiyle birlikte verilen deðer ile uyuþan <literal>case</literal>
   deyimi bulunduðunda PHP ilgili deyimleri çalýþtýrmaya baþlar.
   PHP <literal>switch</literal> bloðu sonlanana kadar ya da
   ilk <literal>break</literal> deyimi ile karþýlaþýncaya kadar
   çalýþmasýna devam eder. Bir case bloðunun sonuna
   <literal>break</literal> koymazsanýz, PHP bu bloktan sonra
   gelen kodlarý çalýþtýrmaya devam eder. Örneðin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eþittir 0";
case 1:
    echo "i eþittir 1";
case 2:
    echo "i eþittir 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Burada, <varname>$i</varname> 0'a eþit ise, PHP tüm echo deyimlerini
   çalýþtýracaktýr! <varname>$i</varname> 1'e eþit ise, PHP sondaki iki echo
   deyimini çalýþtýracaktýr! Beklediðiniz sonucu ('i eþittir 2' metninin görüntülenmesi) yalnýzca
   <varname>$i</varname> 2'ye eþitse almanýz mümkün olacaktýr. Bu durumu engellemek
   için, <literal>break</literal> deyimini kullanmayý unutmamanýz önemlidir (bazý durumlarda
   break deyimini kullanmak istemeyebilirsiniz).
   </simpara>
   <simpara>
    Bir <literal>switch</literal> deyiminde, koþul yalnýzca bir defa sorgulanýr
    ve sonuç her bir <literal>case</literal> deyimi ile karþýlaþtýrýlýr. Bir
    <literal>elseif</literal> deyiminde, koþul tekrar sorgulanýr. Kullanmak istediðiniz
    koþul basit bir karþýlaþtýrma iþleminden daha karmaþýksa ve/veya bir döngü
    içerisindeyse, <literal>switch</literal> kullanmak daha hýzlý olabilir.
   </simpara>
   <para>
   Case bloðu kod içermeyebilir ve amacý yalnýzca kontrolü bir sonraki case
   bloðuna geçirmek olabilir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i 3'ten küçüktür ama negatif deðildir";
    break;
case 3:
    echo "i eþittir 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   <literal>Default</literal> durumu özel bir durumdur. Bu durum diðer
   hiçbir <literal>case</literal> ile uyuþmayan deðerle için kullanýlýr ve
   en sonda yer almalýdýr. Örneðin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eþittir 0";
    break;
case 1:
    echo "i eþittir 1";
    break;
case 2:
    echo "i eþittir 2";
    break;
default:
    echo "i eþit deðildir 0, 1 ya da 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>Case</literal> ile kullanýlan ifade, basit tip olmasý kaydýyla herhangi
    bir tip olabilir, tam sayý (integer), kayan noktalý sayý (floating point) ve karakter dizisi (string) gibi.
    Diziler ya da objeler, basit tipte bir deðere indirgenmedikleri sürece kullanýlamazlar.
   </para>
   <para>
   Kontrol yapýlarý için alternatif söz dizimi, switch deyimi için de desteklenmektedir.
   Daha fazla bilgi için, <link
    linkend="control-structures.alternative-syntax">Kontrol yapýlarý için alternatif
    söz dizimi</link> bölümünü inceleyebilirsiniz.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i eþittir 0";
    break;
case 1:
    echo "i eþittir 1";
    break;
case 2:
    echo "i eþittir 2";
    break;
default:
    echo "i eþit deðildir 0'a, 1'e ya da 2'ye";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
    The <literal>declare</literal> construct is used to
    set execution directives for a block of code.
    The syntax of <literal>declare</literal> is similar to
    the syntax of other flow control constructs:
    <informalexample>
     <programlisting>
<![CDATA[
declare (directive)
    statement
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    The <literal>directive</literal> section allows the
    behavior of the <literal>declare</literal> block to
    be set.
    Currently only one directive is recognized: the
    <literal>ticks</literal> directive. (See below for more
    information on the
    <link linkend="control-structures.declare.ticks">ticks</link>
    directive)
   </para>
   <para>
    The <literal>statement</literal> part of the
    <literal>declare</literal> block will be executed -- how
    it is executed and what side effects occur during execution
    may depend on the directive set in the
    <literal>directive</literal> block.
   </para>
   <para>
    The <literal>declare</literal> construct can also be used in the global
    scope, affecting all code following it.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// these are the same:

// you can use this:
declare(ticks=1) {
    // entire script here
}

// or you can use this:
declare(ticks=1);
// entire script here
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 id="control-structures.declare.ticks">
    <title>Ticks</title>
    <para>A tick is an event that occurs for every
    <varname>N</varname> low-level statements executed
    by the parser within the <literal>declare</literal> block.
    The value for <varname>N</varname> is specified
    using <literal>ticks=<varname>N</varname></literal>
    within the <literal>declare</literal> blocks's
    <literal>directive</literal> section.
   </para>
   <para>
    The event(s) that occur on each tick are specified using the
    <function>register_tick_function</function>. See the example
    below for more details. Note that more than one event can occur
    for each tick.
   </para>
   <para>
    <example>
     <title>Profile a section of PHP code</title>
     <programlisting role="php">
<![CDATA[
<?php
// A function that records the time when it is called
function profile($dump = FALSE)
{
    static $profile;

    // Return the times stored in profile, then erase it
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// Set up a tick handler
register_tick_function("profile");

// Initialize the function before the declare block
profile();

// Run a block of code, throw a tick every 2nd statement
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Display the data stored in the profiler
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
    The example profiles the PHP code within the 'declare'
    block, recording the time at which every second low-level
    statement in the block was executed. This information can
    then be used to find the slow areas within particular
    segments of code. This process can be performed using other
    methods: using ticks is more convenient and easier to
    implement.
   </para>
   <simpara>
    Ticks are well suited for debugging, implementing simple
    multitasking, background I/O and many other tasks.
   </simpara>
   <simpara>
    See also <function>register_tick_function</function> and
    <function>unregister_tick_function</function>.
   </simpara>
   </sect2>
  </sect1>

  <sect1 id="function.return">
   <title>return</title>
   <simpara>
    If called from within a function, the <function>return</function>
    statement immediately ends execution of the current function, and
    returns its argument as the value of the function
    call. <function>return</function> will also end the execution of
    an <function>eval</function> statement or script file.
   </simpara>
   <simpara>
    If called from the global scope, then execution of the current
    script file is ended. If the current script file was
    <function>include</function>ed or <function>require</function>ed,
    then control is passed back to the calling file. Furthermore, if
    the current script file was <function>include</function>ed, then
    the value given to <function>return</function> will be returned as
    the value of the <function>include</function> call. If
    <function>return</function> is called from within the main script
    file, then script execution ends. If the current script file was
    named by the <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> or <link
    linkend="ini.auto-append-file">auto_append_file</link>
    configuration options in &php.ini;,
    then that script file's execution is ended.
   </simpara>
   <simpara>For more information, see <link
   linkend="functions.returning-values">Returning values</link>.
   </simpara>
   <para>
    <note>
     <simpara>
      Note that since <function>return</function> is a language
      construct and not a function, the parentheses surrounding its
      arguments are <emphasis>only</emphasis> required if the argument
      contains an expression. It is common to leave them out while returning a
      variable, and you actually should as PHP has less work to do in this
      case.
     </simpara>
    </note>
    <note>
     <simpara>
      You should <emphasis>never</emphasis> use parentheses around your return
      variable when returning by reference, as this will not work. You can
      only return variables by reference, not the result of a statement. If
      you use <literal>return ($a);</literal> then you're not returning a
      variable, but the result of the expression <literal>($a)</literal>
      (which is, of course, the value of <varname>$a</varname>).
      </simpara>
     </note>
   </para>
  </sect1>


 <sect1 id="function.require">
   <title><function>require</function></title>

   <simpara>
    The <function>require</function> statement includes and evaluates
    the specific file.
   </simpara>
   <simpara>
     <function>require</function> includes and evaluates a specific file.
     Detailed information on how this inclusion works is described in the
     documentation for <function>include</function>.
   </simpara>
   <simpara>
     <function>require</function> and <function>include</function>
     are identical in every way except how they handle failure.
     <function>include</function> produces a
     <link linkend="internal.e-warning">Warning</link> while
     <function>require</function> results in a <link linkend="internal.e-error">
     Fatal Error</link>.  In other words, don't hesitate to use
     <function>require</function> if you want a missing file to halt processing
     of the page.  <function>include</function> does not behave this way, the
     script will continue regardless.  Be sure to have an appropriate
     <link linkend="ini.include-path">include_path</link> setting as well.
   </simpara>
   <para>
    <example>
     <title>Basic <function>require</function> examples</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    See the <function>include</function> documentation for more examples.
   </simpara>
   <para>
    <note>
     <simpara>
      Prior to PHP 4.0.2, the following applies: <function>require</function>
      will always attempt to read the target file, even if the line it's on
      never executes.  The conditional statement won't affect
      <function>require</function>. However, if the line on which the
      <function>require</function> occurs is not executed, neither will any of
      the code in the target file be executed.  Similarly, looping structures
      do not affect the behaviour of <function>require</function>. Although
      the code contained in the target file is still subject to the loop, the
      <function>require</function> itself happens only once.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
    See also <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> and <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 id="function.include">
   <title><function>include</function></title>
   <simpara>
    The <function>include</function> statement includes and evaluates
    the specified file.
   </simpara>
   <simpara>
     The documentation below also applies to <function>require</function>.
     The two constructs are identical in every way except how they handle
     failure.  <function>include</function> produces a
     <link linkend="internal.e-warning">Warning</link> while <function>require</function>
     results in a <link linkend="internal.e-error">Fatal Error</link>.
     In other words, use <function>require</function> if you want
     a missing file to halt processing of the page.  <function>include</function> does
     not behave this way, the script will continue regardless.  Be sure to have an
     appropriate <link linkend="ini.include-path">include_path</link> setting as well.
     Be warned that parse error in included file doesn't cause processing halting
     in PHP versions prior to PHP 4.3.5. Since this version, it does.
   </simpara>
   <simpara>
    Files for including are first looked in include_path relative to the current working directory
    and then in include_path relative to the directory of current script. E.g. if your include_path
    is <literal>.</literal>, current working directory is <filename class="directory">/www/</filename>,
    you included <filename>include/a.php</filename> and there is <literal>include "b.php"</literal>
    in that file, <filename>b.php</filename> is first looked in <filename class="directory">/www/</filename>
    and then in <filename class="directory">/www/include/</filename>.
    If filename begins with <literal>./</literal> or <literal>../</literal>, it
    is looked only in include_path relative to the current working directory.
   </simpara>
   <simpara>
     When a file is included, the code it contains inherits the
     <link linkend="language.variables.scope">variable scope</link> of the
     line on which the include occurs.  Any variables available at that line
     in the calling file will be available within the called file, from that
     point forward.
     However, all functions and classes defined in the included file have the
     global scope.
   </simpara>
   <para>
     <example>
      <title>Basic <function>include</function> example</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$color = 'green';
$fruit = 'apple';

?>

test.php
<?php

echo "A $color $fruit"; // A

include 'vars.php';

echo "A $color $fruit"; // A green apple

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
     If the include occurs inside a function within the calling file,
     then all of the code contained in the called file will behave as
     though it had been defined inside that function.  So, it will follow
     the variable scope of that function.
   </simpara>
   <para>
     <example>
     <title>Including within functions</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $color;

    include 'vars.php';

    echo "A $color $fruit";
}

/* vars.php is in the scope of foo() so     *
 * $fruit is NOT available outside of this  *
 * scope.  $color is because we declared it *
 * as global.                               */

foo();                    // A green apple
echo "A $color $fruit";   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
     When a file is included, parsing drops out of PHP mode and
     into HTML mode at the beginning of the target file, and resumes
     again at the end.  For this reason, any code inside the target
     file which should be executed as PHP code must be enclosed within
     <link linkend="language.basic-syntax.phpmode">valid PHP start
     and end tags</link>.
   </simpara>
   <simpara>
     If "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
     are enabled in PHP (which they are in the default configuration),
     you can specify the file to be included using a URL (via HTTP or
     other supported wrapper - see <xref linkend="wrappers"/> for a list
     of protocols) instead of a local pathname.  If the target server interprets
     the target file as PHP code, variables may be passed to the included
     file using a URL request string as used with HTTP GET.  This is
     not strictly speaking the same thing as including the file and having
     it inherit the parent file's variable scope; the script is actually
     being run on the remote server and the result is then being
     included into the local script.
   </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title><function>include</function> through HTTP</title>
     <programlisting role="php">
<![CDATA[
<?php

/* This example assumes that www.example.com is configured to parse .php
 * files and not .txt files. Also, 'Works' here means that the variables
 * $foo and $bar are available within the included file. */

// Won't work; file.txt wasn't handled by www.example.com as PHP
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Won't work; looks for a file named 'file.php?foo=1&bar=2' on the
// local filesystem.
include 'file.php?foo=1&bar=2';

// Works.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Works.
include 'file.php';  // Works.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Security warning</title>
    <para>
     Remote file may be processed at the remote server (depending on the file
     extension and the fact if the remote server runs PHP or not) but it still
     has to produce a valid PHP script because it will be processed at the
     local server. If the file from the remote server should be processed
     there and outputted only, <function>readfile</function> is much better
     function to use. Otherwise, special care should be taken to secure the
     remote script to produce a valid and desired code.
    </para>
   </warning>
   <para>
    See also <link linkend="features.remote-files">Remote files</link>,
    <function>fopen</function> and <function>file</function> for related
    information.
   </para>
   <para>
     Because <function>include</function> and <function>require</function>
     are special language constructs, you must enclose them within a statement
     block if it's inside a conditional block.
   </para>
   <para>
    <example>
     <title>include() and conditional blocks</title>
     <programlisting role="php">
<![CDATA[
<?php

// This is WRONG and will not work as desired.
if ($condition)
    include $file;
else
    include $other;


// This is CORRECT.
if ($condition) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Handling Returns: It is possible to execute a <function>return</function>
    statement inside an included file in order to terminate processing in that
    file and return to the script which called it.  Also, it's possible to return
    values from included files.  You can take the value of the include call as
    you would a normal function.  This is not, however, possible when including
    remote files unless the output of the remote file has
    <link linkend="language.basic-syntax.phpmode">valid PHP start
    and end tags</link> (as with any local file).  You can declare the needed
    variables within those tags and they will be introduced at whichever point
    the file was included.
   </simpara>
   <para>
    Because <function>include</function> is a special language construct,
    parentheses are not needed around its argument. Take care when comparing
    return value.
    <example>
     <title>Comparing return value of include</title>
     <programlisting role="php">
<![CDATA[
<?php
// won't work, evaluated as include(('vars.php') == 'OK'), i.e. include('')
if (include('vars.php') == 'OK') {
    echo 'OK';
}

// works
if ((include 'vars.php') == 'OK') {
    echo 'OK';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
      In PHP 3, the return may not appear inside a block unless it's
      a function block, in which case the <function>return</function> applies
      to that function and not the whole file.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function> and the <function>return</function> statement</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // prints 'PHP'

$bar = include 'noreturn.php';

echo $bar; // prints 1

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal> is the value <literal>1</literal> because the include
    was successful.  Notice the difference between the above examples.  The first uses
    <function>return</function> within the included file while the other does not.
    If the file can't be included, &false; is returned and
    <literal>E_WARNING</literal> is issued.
   </simpara>
   <para>
    If there are functions defined in the included file, they can be used in the
    main file independent if they are before <function>return</function> or after.
    If the file is included twice, PHP 5 issues fatal error because functions
    were already declared, while PHP 4 doesn't complain about functions
    defined after <function>return</function>.
    It is recommended to use <function>include_once</function> instead of
    checking if the file was already included and conditionally return inside
    the included file.
   </para>
   <simpara>
    Another way to "include" a PHP file into a variable is to capture the
    output by using the <link linkend="ref.outcontrol">Output Control
    Functions</link> with <function>include</function>. For example:
   </simpara>
   <para>
    <example>
     <title>Using output buffering to include a PHP file into a string</title>
      <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
      </programlisting>
    </example>
   </para>
   <para>
    In order to automatically include files within scripts, see also the
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> and
    <link linkend="ini.auto-append-file">auto_append_file</link>
    configuration options in &php.ini;.
   </para>

   &note.language-construct;

   <simpara>
    See also <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, and
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    The <function>require_once</function> statement includes and evaluates
    the specified file during the execution of the script.
    This is a behavior similar to the <function>require</function> statement,
    with the only difference being that if the code from a file has already
    been included, it will not be included again.  See the documentation for
    <function>require</function> for more information on how this statement
    works.
   </para>
   <para>
    <function>require_once</function> should be used in cases where
    the same file might be included and evaluated more than once during a
    particular execution of a script, and you want to be sure that it is
    included exactly once to avoid problems with function redefinitions,
    variable value reassignments, etc.
   </para>
   <para>
     For examples on using <function>require_once</function> and
     <function>include_once</function>, look at the
     <ulink url="&url.php.pear;">PEAR</ulink> code included in the
     latest PHP source code distributions.
   </para>
   <para>
    Return values are the same as with <function>include</function>. If the file
    was already included, this function returns &true;
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> was added in PHP 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      Be aware, that the behaviour of <function>require_once</function>
      and <function>include_once</function> may not be what you expect
      on a non case sensitive operating system (such as Windows).
      <example>
       <title><function>require_once</function> is case insensitive on Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // this will include a.php
require_once("A.php"); // this will include a.php again on Windows! (PHP 4 only)
?>
]]>
        </programlisting>
      </example>
      This behaviour changed in PHP 5 - the path is normalized first so that
      <filename>C:\PROGRA~1\A.php</filename> is realized the same as
      <filename>C:\Program Files\a.php</filename> and the file is required just once.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    See also <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>, and
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    The <function>include_once</function> statement includes and evaluates
    the specified file during the execution of the script.
    This is a behavior similar to the <function>include</function> statement,
    with the only difference being that if the code from a file has already
    been included, it will not be included again.  As the name suggests,
    it will be included just once.
   </para>
   <para>
    <function>include_once</function> should be used in cases where
    the same file might be included and evaluated more than once during a
    particular execution of a script, and you want to be sure that it is
    included exactly once to avoid problems with function redefinitions,
    variable value reassignments, etc.
   </para>
   <para>
    For more examples on using <function>require_once</function> and
    <function>include_once</function>, look at the
    <ulink url="&url.php.pear;">PEAR</ulink> code included in the latest
    PHP source code distributions.
   </para>
   <para>
    Return values are the same as with <function>include</function>. If the file
    was already included, this function returns &true;
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> was added in PHP 4.0.1pl2
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
      Be aware, that the behaviour of <function>include_once</function>
      and <function>require_once</function> may not be what you expect
      on a non case sensitive operating system (such as Windows).
      <example>
       <title><function>include_once</function> is case insensitive on Windows</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // this will include a.php
include_once("A.php"); // this will include a.php again on Windows! (PHP 4 only)
?>
]]>
        </programlisting>
      </example>
      This behaviour changed in PHP 5 - the path is normalized first so that
      <filename>C:\PROGRA~1\A.php</filename> is realized the same as
      <filename>C:\Program Files\a.php</filename> and the file is included just once.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    See also <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    and <function>virtual</function>.
   </para>
  </sect1>
  
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
