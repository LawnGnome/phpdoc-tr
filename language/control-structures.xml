<?xml version="1.0" encoding="iso-8859-9"?>
<!-- $Revision: 1.6 $ -->
 <chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Kontrol Yapýlarý</title>

  <simpara>
  Bütün PHP betikleri bir dizi deyimden (statement) oluþur. Bir deyim;
  bir atama, bir fonksiyonun çaðrýlmasý, bir döngü, bir koþullu deyim hatta
  hiçbir þey yapmayan bir deyim (boþ bir deyim) olabilir. Deyimler bir
  noktalý virgülle sonlandýrýlýr. Ek olarak, deyimler köþeli parantez içine
  alýnarak deyim gruplarý haline getirilebilirler. Bir deyim grubu da
  kendi baþýna bir deyim olarak kabul edilir. Bu bölümde çeþitli tiplerdeki
  deyimlerin anlatýmýný yapacaðýz.
  </simpara>

  <sect1 xml:id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>If</literal> yapýsý, PHP dahil olmak üzere birçok programlama
    dilindeki en önemli özelliklerden biridir. Bu yapý, kod bölümlerinin koþullu
    olarak çalýþtýrýlabilmelerini saðlar. PHP, C dilindekine benzer bir
    <literal>if</literal> yapýsý sunar.
    <informalexample>
     <programlisting>
<![CDATA[
if (ifade)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   <link linkend="language.expressions">Ýfadelerle ilgili bölüm</link>de
   anlatýldýðý gibi, <replaceable>ifade</replaceable> kendi ikili deðeri (boolean value) üzerinden
   deðerlendirilir. <replaceable>Ýfade</replaceable> &true; deðerini oluþturuyorsa,
   PHP <replaceable>deyimi</replaceable> çalýþtýrýr, eðer &false; deðerini oluþturuyorsa gözardý eder.
   Hangi deðerlerin &false; olarak deðerlendirildiði hakkýnda daha fazla bilgi için <link
    linkend="language.types.boolean.casting">'Ýkili deðere dönüþtürmek'</link> bölümünden
    faydalanabilirsiniz.
   </simpara>
   <para>
   Buradaki örnek, <varname>$a</varname> deðeri <varname>$b</varname>
   deðerinden büyük olduðu takdirde <computeroutput>a büyüktür
    b</computeroutput> metnini görüntüleyecektir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a büyüktür b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Sýklýkla birden çok deyimin koþullu olarak çalýþtýrýlmasýný isteyeceksiniz.
   Elbette, her bir deyimi ayrý ayrý <literal>if</literal> yantümcelerine (clause)
   almanýza gerek yoktur. Birden çok deyimi biraraya getirerek tek bir deyim grubu
   oluþturabilirsiniz. Örneðin, Bu kod <varname>$a</varname> deðeri
   <varname>$b</varname> deðerinden büyük olduðu takdirde
   <computeroutput>a büyüktür b</computeroutput> metnini görüntüleyecektir ve
   sonrasýnda <varname>$a</varname> deðiþkeninin deðerini 
   <varname>$b</varname> deðiþkenine atayacaktýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal> deyimleri sonsuz sayýda diðer
    <literal>if</literal> deyiminin içine gömülebilir. Bu size
    uygulamanýzýn çeþitli bölümlerinde koþullu deyimler
    uygulayabilmeniz için tam bir esneklik saðlar.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
   Çoðu zaman belli bir koþul saðlandýðýnda bir deyimin, o koþul saðlanmadýðýnda
   baþka bir deyimin çalýþtýrýlmasýný isteyeceksiniz. Bu yapýyý saðlamak için
   <literal>else</literal> kullanýlmaktadýr. <literal>Else</literal>,
   bir <literal>if</literal> deyiminin geniþleyerek, belirtilen koþul saðlanmadýðý
   ve &false; döndürdüðü takdirde ne yapýlacaðýný belirtmek için kullanýlýr.
   Örneðin, buradaki kod <varname>$a</varname>
   deðeri <varname>$b</varname> deðerinden büyükse
   <computeroutput>a büyüktür b</computeroutput> mesajýný,
   büyük deðilse <computeroutput>a büyük deðildir b</computeroutput>
   mesajýný görüntüleyecektir:
   <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} else {
    echo "a büyük deðildir b";
}
?>
]]>
     </programlisting>
    </informalexample>

    <literal>Else</literal> deyimi yalnýzca <literal>if</literal> deyiminin
    &false; döndürdüðü durumda çalýþtýrýlacaktýr. Ayný durum, &false;
    döndüren herhangi bir <literal>elseif</literal> ifadesinin olmasý durumunda da
    geçerlidir (bakýnýz <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, isminden de anlaþýlacaðý gibi, <literal>if</literal> ve
    <literal>else</literal> deyimlerinin biraraya gelmesiyle oluþur. 
    <literal>else</literal> gibi, orijinal <literal>if</literal> ifadesinin
    &false; döndürdüðü durumda farklý bir deyimin çalýþtýrýlmasý için kullanýlýr.
    Ancak, <literal>else</literal>'ten faklý olarak, bu deyim alternatif ifadeyi
    yalnýzca kendisine ait koþullu ifade &true; deðerini döndürdüðü durumda çalýþtýracaktýr.
    Örneðin, buradaki kod <computeroutput>a büyüktür b</computeroutput>,
    <computeroutput>a eþittir b</computeroutput> ya da 
    <computeroutput>a küçüktür b</computeroutput> mesajýný görüntüleyecektir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} elseif ($a == $b) {
    echo "a eþittir b";
} else {
    echo "a küçüktür b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Ayný <literal>if</literal> deyimine ait birden çok <literal>elseif</literal>
   bulunabilir. Ýlk önce hangi <literal>elseif</literal> deyimi &true; deðerini
   döndürürse (eðer döndüren varsa) o deyim çalýþtýrýlýr. Bu deyimi 'elseif'
   biçiminde tek sözcük olarak kullanabileceðiniz gibi, 'else if' biçiminde iki
   sözcük olarak da kullanabilirsiniz, sonuç ayný olacaktýr. Sözdimi anlamý açýsýndan
   küçük bir farklýlýk olsa da (C diline aþinaysanýz, ayný fark) sonuç olarak her ikisi
   de ayný sonucu üretecektir.
   </simpara>
   <simpara>
   <literal>elseif</literal> ifadesi yalnýzca kendisinden önceki <literal>if</literal> ifadesi
   ve bu ifadeye baðlý kendisinden önce gelen diðer tüm <literal>elseif</literal> ifadeleri &false; olduðunda
   çalýþtýrýlýr ve &true; deðerini döndürür.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>Kontrol yapýlarý için alternatif sözdizimi</title>
   <para>
   PHP bazý kontrol yapýlarý için alternatif sözdizimi imkanlarý sunar.
   Bunlar <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> ve <literal>switch</literal> yapýlarýdýr.
    Her bir durumda, alternatif sözdiziminin basit þekli açýlýþta kullanýlan köþeli parantez
    yerine iki nokta üst üste (:) kullanmak ve kapanýþta kullanýlan köþeli parantez yerine
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal> ya da
    <literal>endswitch;</literal> deyimlerinden birini kullanmaktýr.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A eþittir 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Yukarýdaki örnekte, içeriði "A eþittir 5" olan HTML bloðu alternatif sözdimi
   kullanýlarak yazýlmýþ bir <literal>if</literal> deyiminin içine gömülmüþtür.
   HTML bloðu yalnýzca <varname>$a</varname> deðiþkeni 5'e eþit olduðunda
   gösterilecektir.
   </simpara>
   <para>
   Alternatif sözdimi, <literal>else</literal> ve <literal>elseif</literal>
   için de kullanýlabilir. Birazdan vereceðimiz örnek, alternatif format ile yazýlmýþ
   ve <literal>elseif</literal> ile <literal>else</literal> içeren bir
   <literal>if</literal> yapýsýdýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a eþittir 5";
    echo "...";
elseif ($a == 6):
    echo "a eþittir 6";
    echo "!!!";
else:
    echo "a ne 5 ne de 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Daha fazla örnek için <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, ve <link
    linkend="control-structures.if">if</link> bölümlerine bakabilirsiniz.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal> döngüsü PHP'de yer alan en basit döngü tipidir.
    C'deki karþýlýðý ile ayný þekilde çalýþýr. Bir <literal>while</literal> deyiminin
    basit kullanýmý:
    <informalexample>
     <programlisting>
<![CDATA[
while (ifade)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   <literal>While</literal> deyiminin anlamý basittir. Kendi kapsama
   alaný içinde tanýmlanmýþ deyimlerin tekrar tekrar çalýþtýrýlmasýný
   saðlar. Tekrar çalýþtýrma iþlemi <literal>while</literal> deyimine
   ait ifadenin karþýlýðý &true; oldukça devam eder. Ýfadenin deðeri döngü
   her tekrarlandýðýnda yeniden hesaplanýr, deyimlerin çalýþtýrýlmasý
   sýrasýnda bu ifadenin deðeri deðiþse bile, döngü içindeki deyimler
   en son adýma kadar çalýþtýrýlmaya devam edilir (PHP'nin döngü içindeki
   deyimleri her çalýþtýrýþý bir döngüyü ifade etmektedir). Bazen,
   <literal>while</literal> ifadesi daha ilk tekrardan önce &false; deðerini
   verir, bu durumda <literal>while</literal> kapsamýndaki deyimler
   tek bir defa bile çalýþtýrýlmazlar.
   </simpara>
   <para>
   <literal>If</literal> deyiminde olduðu gibi, birden çok deyimi ayný
   <literal>while</literal> döngüsü içinde köþeli parantez kullanarak ya da
   alternatif sözdimi yönteminden faydalanarak gruplayabilirsiniz:
   <informalexample>
     <programlisting>
<![CDATA[
while (ifade):
    deyimler
    ...
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Aþaðýdaki örnekler birbirleri ile aynýdýrlar, her ikisi de 1'den 10'a kadar
   rakamlarý yazacaktýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* yazdýrýlan deðer $i
                    deðerinin artýþtan önceki
                    deðeridir (sonda-arttýrým) */
}

/* örnek 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    <literal>do-while</literal> döngüsü,
    <literal>while</literal> döngüsü ile oldukça benzerdir.
    <literal>do-while</literal> döngüsünün farký, kontrol edilecek
    ifadenin tekrarlarýn baþýnda deðil sonunda kontrol ediliyor olmasýdýr.
    <literal>while</literal> döngüsü ile temek farklýlýk, <literal>do-while</literal>
    kullanýldýðýnda ilk tekrarýn çalýþmasýnýn garanti altýna alýnýyor olmasýdýr
    (ifadenin doðruluðu yalnýzca tekrarýn sonunda kontrol edilecektir). 
    <literal>while</literal> döngüsü, ifadenin kontrolünü her bir tekrardan önce
    yapmaktadýr, ilk tekrar öncesinde &false; deðeri alýndýðý takdirde, döngü daha
    baþlamadan sona erecektir.
   </simpara>
   <para>
   <literal>do-while</literal> döngüsü için yalnýzca tek bir sözdizimi mevcuttur:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Yukarýdaki döngü tam olarak bir defa çalýþacaktýr, ilk tekrardan sonra ifadenin
   doðruluðu kontrol edildiðinde, &false; deðerini verecek ($i büyük deðildir 0) ve
   döngünün çalýþmasý sonlanacaktýr.
   </simpara>
   <para>
   Ýleri seviye C kullanýcýlarý <literal>do-while</literal> döngüsünün
   farklý kullanýmlarýna aþina olabilirler. Bu döngü, kod bloklarýnýn çalýþtýrýldýklarý
   esnada çalýþmanýn ortasýnda sonlandýrýlmalarýný saðlamak için kullanýlabilir.
   Bu iþlem kod bloðunu <literal>do-while</literal> (0) döngüsü içine alýp
   <link linkend="control-structures.break"><literal>break</literal></link> deyimi
   kullanýlarak yapýlabilmektedir. Aþaðýdaki kod parçasý bu durumu örneklemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i yeterince büyük deðil";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "i uygun";

    /* i deðerini iþle */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Bu yöntemi anlamadýysanýz endiþelenmeyin. Bu 'özelliði' kullanmadan
   da oldukça geliþmiþ ve güçlü uygulamalar geliþtirebilirsiniz.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal> döngüsü, PHP dahilindeki en karmaþýk döngü
    yapýsýdýr. C'deki karþýlýðý ile ayný biçimde çalýþýr. <literal>for</literal>
    döngüsünün sözdimi þu þekildedir:
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Ýlk ifade (<varname>expr1</varname>) döngünün en baþýnda
   tek bir defa koþulsuz olarak çalýþtýrýlýr.
   </simpara>
   <simpara>
   Her bir tekrarýn baþýnda, <varname>expr2</varname> çalýþtýrýlýr.
   Bu ifadeden &true; sonucu elde edilirse, döngüye devam edilir ve döngü
   dahilindeki deyimler çalýþtýrýlýr. Bu ifadeden &false; sonucu elde edilirse,
   döngünün çalýþmasý sonlandýrýlýr.
   </simpara>
   <simpara>
   Her bir tekrarýn sonunda, <varname>expr3</varname>
   çalýþtýrýlýr.
   </simpara>
   <simpara>
   Ýfadelerin herbiri için boþ kullaným mümkündür.
   <varname>expr2</varname> ifadesinin boþ olmasý, döngünün
   sonsuza kadar çalýþtýrýlacaðý anlamýna gelir (PHP C'deki gibi bu durumu
   &true; olarak deðerlendirir). Döngüleri sýklýkla bir þarta baðlý olarak
   <link linkend="control-structures.break"><literal>break</literal></link>
   deyimi ile sonlandýrmak isteyeceðiniz düþünüldüðünde, bu durum
   düþündüðünüz kadar kullanýþsýz deðildir. Bu kullaným size
   <literal>for</literal> deyiminin imkanlarýndan daha fazla esneklik
   saðlayabilir.
   </simpara>
   <para>
   Aþaðýdaki örnekleri inceleyin ve karþýlaþtýrýn. Hepsi de 1'den 10'a kadar
   rakamlarý görüntülemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* örnek 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* örnek 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* örnek 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Elbette, kullandýðýmýz ilk örnek en güzel örnek olarak gözükmektedir (
   ya da belki dördüncü örnek), ancak birçok durumda <literal>for</literal>
   döngüsü içerisinde boþ ifadeler kullanmanýn oldukça kullanýþlý olduðu
   sonucuna varabilirsiniz.
   </simpara>
   <para>
   PHP, alternatif "iki nokta üst üste" sözdimi þeklini
   <literal>for</literal> döngüleri için de desteklemektedir.
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3):
    deyimler
    ...
endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
   PHP 4 ile birlikte Perl ve bazý diðer dillerde mevcut olan
   <literal>foreach</literal> yapýsý da kullanýma sunulmuþtur.
   Bu deyimi dizi-deðiþkenler üzerinde tekrar iþlemleri yapmayý
   kolaylaþtýrmaktadýr. <literal>foreach</literal> yalnýzca
   diziler için kullanýlabilir; farklý bir deðiþken veri tipi ile ya da henüz
   oluþturulmamýþ bir deðiþken ile kullanmak istediðinizde hata oluþturacaktýr.
   Ýki türlü sözdizimi mevcuttur; ikinci kullaným þekli birinciden biraz daha uzun
   ama biraz daha kullanýþlýdýr:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value)
    deyimler
foreach (array_expression as $key => $value)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Ýlk yöntem <literal>array_expression</literal> ile belirtilen
   dizinin üzerinde döngü oluþturur. Her tekrarda, mevcut elemanýn
   deðeri <literal>$value</literal> deðiþkenine atanýr ve dizinin
   iç imleci bir ilerletilir (böylece sonraki tekrarda, son elemana
   bakýlýyor olmasý saðlanýr).
   </simpara>
   <simpara>
   Ýkinci yöntem ayný þeyi yapar, yalnýzca her tekrarda mevcut elemanýn
   anahtar deðeri <literal>$key</literal> deðiþkenine atanýr.
   </simpara>
   <simpara>
   PHP 5'den itibaren, <link linkend="language.oop5.iterations">nesneler üzerinde tekrar yapmak</link>
   mümkün olmuþtur.
   </simpara>
   <para>
    <note>
     <para>
     <literal>foreach</literal> ilk çalýþmaya baþladýðýnda, dizinin iç imleci
     otomatik olarak ilk elemaný gösterecek biçimde sýfýrlanýr. Bu sebeple
     <literal>foreach</literal> deyiminden önce <function>reset</function>
     fonksiyonunu çalýþtýrmanýza gerek yoktur.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
     Dizi <link linkend="language.references">referans edilmiþ</link> olmadýðý
     sürece, <literal>foreach</literal> dizinin kendisi üzerinde çalýþmaz,
     bir kopyasý üzerinde çalýþýr. Bundan dolayý dizi imleci <function>each</function>
     yapýsýnda olduðu gibi deðiþtirilmez, ve döndürülen dizi elemaný üzerinde yapýlan
     deðiþiklikler orijinal diziye yansýtýlmaz. Öte yandan, orijinal dizinin imleci
     dizi üzerinde iþlem yapýldýkça <emphasis>ilerler</emphasis>. foreach döngüsünün
     çalýþmasý tamamlandýðýnda, dizinin iç imleci de dizinin sonuna gelmiþ olacaktýr.
     </para>
     <para>
     PHP 5'den itibaren, dizinin elemanlarý üzerinde <literal>$value</literal> deðiþkeninin
     önüne &amp; koyarak deðiþiklik yapabilirsiniz. Bu kullaným deðerin bir kopyasýný kullanmak
     yerine kendisine bir <link linkend="language.references">referans</link> atanmasýný
     saðlayacaktýr:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr þimdi array(2, 4, 6, 8) olmuþtur
?>
]]>
       </programlisting>
      </informalexample>
      Bu durum yalnýzca üzerinde çalýþýlan dizi referans oluþturulabilir
      türde ise mümkündür (örn. bir deðiþkense).
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal> ile hata mesajlarýnýn '@' kullanýlarak
      gözardý edilmesi mümkün deðildir.
     </para>
    </note>
   </para>
   <para>
   Ýþlevsel olarak aþaðýdakilerin birbirleri ile ayný olduðunu tespit
   etmiþ olabilirsiniz:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("bir", "iki", "üç");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Deðer: $value<br />\n";
}

foreach ($arr as $value) {
    echo "Deðer: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Aþaðýdakiler de iþlevsel olarak aynýdýr:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("bir", "iki", "üç");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Anahtar: $key; Deðer: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Anahtar: $key; Deðer: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Deðiþik kullanýmlara örnekler:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach örnek 1: yalnýzca deðer */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "\$a deðiþkeninin þu anki deðeri: $v.\n";
}

/* foreach örnek 2: deðer (örnek olmasý için anahtar ile birlikte yazdýrýlmýþtýr) */

$a = array(1, 2, 3, 17);

$i = 0; /* for yalnýzca örnekleme için */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach örnek 3: anahtar ve deðer */

$a = array(
    "bir" => 1,
    "iki" => 2,
    "üç" => 3,
    "on yedi" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach örnek 4: çok boyutlu diziler */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach örnek 5: dinamik diziler */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> deyimi,
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal> veya
    <literal>switch</literal> yapýlarýnýn çalýþmasýný durdurmak için kullanýlýr.
   </simpara>
   <simpara>
    <literal>break</literal> deyimi ile seçime baðlý bir sayýsal argüman
    kullanýlabilir. Bu argüman iç içe kaç tane yapýnýn ayný anda durdurulacaðýný
    belirler.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('sifir', 'bir', 'iki', 'üç', 'dur', 'dört', 'beþ');
while (list(, $val) = each($arr)) {
    if ($val == 'dur') {
        break;    /* Ayný zamanda 'break 1;' de yazabilirsiniz. */
    }
    echo "$val<br />\n";
}

/* Seçime baðlý argümanýn kullanýmý. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "5'de<br />\n";
        break 1;  /* Yalnýzca switch'ten çýkar. */
    case 10:
        echo "10'da; çýkýlýyor<br />\n";
        break 2;  /* switch ve while'dan birlikte çýkýlýr. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> deyimi döngü yapýlarýnýn arasýnda kullanýlýr.
    Bu deyim kullanýldýðýnda, döngünün kalan kýsmý atlanýr ve
    sonraki döngü tekrarýna baþlanýlýr.
   </simpara>
   <note>
    <simpara>
    PHP'de
     <link linkend="control-structures.switch">switch</link> deyimi
     <literal>continue</literal> deyiminin kullanýlabileceði döngülerden
     biri olarak kabul edilmektedir.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> deyime ile seçime baðlý sayýsal bir argüman
    kullanýlarak, kaç seviye üstteki döngüye kadar atlama iþleminin uygulanacaðý
    belirtilebilir.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // tek sayýlarý atla
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Dýþ<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Orta<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;Ýç<br />\n";
            continue 3;
        }
        echo "Bu hiçbir zaman çýktý vermez.<br />\n";
    }
    echo "Bundan da çýktý alamazsýnýz.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
    <literal>continue</literal> deyiminden sonra noktalý virgül konmazsa
    bu durum karýþýklýða yol açabilir. Yapmamanýz gereken ile ilgili bir örnek:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Þu biçimde bir çýktý almayý bekleyebilirsiniz:
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       Ancak beklenen çýktý þu þekilde olacaktýr:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
      Bunun sebebi <function>print</function> fonksiyonundan dönen
      deðerin <literal>int(1)</literal> olmasý ve bu dönen deðerin
      PHP tarafýndan yukarýda bahsedilen seçime saðlý sayýsal argüman
      olarak algýlanmasýdýr.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal> deyimi, ayný ifade içersinde yer alan bir dizi
    IF deyimine benzer. Birçok durumda, ayný deðiþkeni (ya da ifadeyi)
    birden çok deðerle karþýlaþtýrmak ve her karþýlaþtýrmanýn sonucunu
    ayrý bir kod parçasý çalýþtýrarak deðerlendirmek istersiniz. Bu tam olarak
    <literal>switch</literal> deyiminin varlýk sebebidir.
   </simpara>
   <note>
    <simpara>
    Baþka bazý dillerden farklý olarak, <link linkend="control-structures.continue">continue</link>
    deyimi switch ile uygulanabilir ve <literal>break</literal> ile benzerlik
    gösterir. Bir döngü içerisinde switch kullandýysanýz ve kodun yürütülmesine
    dýþtaki döngünün tekrarlanmasýyla devam etmek istiyorsanýz, <literal>continue 2</literal>
    sözdizimini kullanabilirsiniz.
    </simpara>
   </note>
   <para>
   Aþaðýdaki iki örnek ayný þeyi yazmanýn iki farklý yolunu göstermektedir.
   Birincisi bir dizi <literal>if</literal> ve  <literal>elseif</literal>
   deyiminin kullanýmýný, ikincisi ise <literal>switch</literal>
   deyiminin kullanýmýný örneklemektedir:
    <example>
     <title><literal>switch</literal> yapýsý</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i eþittir 0";
} elseif ($i == 1) {
    echo "i eþittir 1";
} elseif ($i == 2) {
    echo "i eþittir 2";
}

switch ($i) {
case 0:
    echo "i eþittir 0";
    break;
case 1:
    echo "i eþittir 1";
    break;
case 2:
    echo "i eþittir 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>switch</literal> ile karakter dizisi kullanýmý</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "elma":
    echo "i bir elmadýr";
    break;
case "çikolata":
    echo "i bir çikolatadýr";
    break;
case "kek":
    echo "i bir kektir";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
   Hatalardan kaçýnmak için <literal>switch</literal> deyiminin
   nasýl çalýþtýðýný anlamak önemlidir. <literal>Switch</literal>
   deyimi satýr satýr çalýþýr (yani deyim deyim). Baþlangýçta,
   hiçbir kod çalýþtýrýlmaz. Yalnýzca <literal>switch</literal> 
   ifadesiyle birlikte verilen deðer ile uyuþan <literal>case</literal>
   deyimi bulunduðunda PHP ilgili deyimleri çalýþtýrmaya baþlar.
   PHP <literal>switch</literal> bloðu sonlanana kadar ya da
   ilk <literal>break</literal> deyimi ile karþýlaþýncaya kadar
   çalýþmasýna devam eder. Bir case bloðunun sonuna
   <literal>break</literal> koymazsanýz, PHP bu bloktan sonra
   gelen kodlarý çalýþtýrmaya devam eder. Örneðin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eþittir 0";
case 1:
    echo "i eþittir 1";
case 2:
    echo "i eþittir 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Burada, <varname>$i</varname> 0'a eþit ise, PHP tüm echo deyimlerini
   çalýþtýracaktýr! <varname>$i</varname> 1'e eþit ise, PHP sondaki iki echo
   deyimini çalýþtýracaktýr! Beklediðiniz sonucu ('i eþittir 2' metninin görüntülenmesi) yalnýzca
   <varname>$i</varname> 2'ye eþitse almanýz mümkün olacaktýr. Bu durumu engellemek
   için, <literal>break</literal> deyimini kullanmayý unutmamanýz önemlidir (bazý durumlarda
   break deyimini kullanmak istemeyebilirsiniz).
   </simpara>
   <simpara>
    Bir <literal>switch</literal> deyiminde, koþul yalnýzca bir defa sorgulanýr
    ve sonuç her bir <literal>case</literal> deyimi ile karþýlaþtýrýlýr. Bir
    <literal>elseif</literal> deyiminde, koþul tekrar sorgulanýr. Kullanmak istediðiniz
    koþul basit bir karþýlaþtýrma iþleminden daha karmaþýksa ve/veya bir döngü
    içerisindeyse, <literal>switch</literal> kullanmak daha hýzlý olabilir.
   </simpara>
   <para>
   Case bloðu kod içermeyebilir ve amacý yalnýzca kontrolü bir sonraki case
   bloðuna geçirmek olabilir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i 3'ten küçüktür ama negatif deðildir";
    break;
case 3:
    echo "i eþittir 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   <literal>Default</literal> durumu özel bir durumdur. Bu durum diðer
   hiçbir <literal>case</literal> ile uyuþmayan deðerle için kullanýlýr ve
   en sonda yer almalýdýr. Örneðin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eþittir 0";
    break;
case 1:
    echo "i eþittir 1";
    break;
case 2:
    echo "i eþittir 2";
    break;
default:
    echo "i eþit deðildir 0, 1 ya da 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>Case</literal> ile kullanýlan ifade, basit tip olmasý kaydýyla herhangi
    bir tip olabilir, tam sayý (integer), kayan noktalý sayý (floating point) ve karakter dizisi (string) gibi.
    Diziler ya da objeler, basit tipte bir deðere indirgenmedikleri sürece kullanýlamazlar.
   </para>
   <para>
   Kontrol yapýlarý için alternatif söz dizimi, switch deyimi için de desteklenmektedir.
   Daha fazla bilgi için, <link
    linkend="control-structures.alternative-syntax">Kontrol yapýlarý için alternatif
    söz dizimi</link> bölümünü inceleyebilirsiniz.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i eþittir 0";
    break;
case 1:
    echo "i eþittir 1";
    break;
case 2:
    echo "i eþittir 2";
    break;
default:
    echo "i eþit deðildir 0'a, 1'e ya da 2'ye";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
   <literal>Declare</literal> yapýsý bir kod bloðunun
   çalýþtýrýlmasý esnasýnda uygulanacak direktifleri belirlemek
   için kullanýlýr. <literal>Declare</literal> yapýsýnýn söz dizimi
   diðer akýþ kontrol yapýlarýnýn söz dizimi ile benzerdir:
    <informalexample>
     <programlisting>
<![CDATA[
declare (direktif)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   <literal>Directive</literal> bölümü, <literal>declare</literal>
   bloðunun nasýl davranacaðýný belirlemek için kullanýlýr.
   Þu an için yalnýzca bir direktif kullanýlabilmektedir:
    <literal>Ticks</literal> direktifi. (<link linkend="control-structures.declare.ticks">Ticks</link>
    hakkýnda daha fazla bilgi edinmek istiyorsanýz aþaðýya gözatýn.
   </para>
   <para>
   <literal>Declare</literal> bloðunun <literal>deyim</literal>
   bölümünün nasýl çalýþtýrýlacaðý ve çalýþma esnasýndaki yan
   etkilerinin ne olacaðý <literal>directive</literal> bloðunda
   belirtilir.
   </para>
   <para>
   <literal>Declare</literal> yapýsý global kapsamda kullanýlabilir ve
   kendisinden sonra gelen tüm kodu etkilemesi saðlanabilir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// aþaðýdaki iki örnek aynýdýr:

// bunu kullanabilirsiniz:
declare(ticks=1) {
    // bütün uygulama kodunuz
}

// ya da bunu kullanabilirsiniz:
declare(ticks=1);
// bütün uygulama kodunuz
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title>Tick'ler</title>
    <para>Tick, <literal>declare</literal>
    bloðu içerisinde tanýmlanmýþ kodun
    PHP tarayýcýsý tarafýndan her bir
    <varname>N</varname>  alt-seviye deyimi için
    çalýþtýrýldýðý eyleme verilen isimdir. <varname>N</varname>
    için belirlenen deðer 
    <literal>ticks=N</literal>
    biçiminde <literal>declare</literal> bloðunun
    <literal>directive</literal> bölümünde tanýmlanýr.
   </para>
   <para>
   Her bir tick ile oluþturulacak eylem <function>register_tick_function</function>
   fonksiyonu ile belirtilir. Aþaðýdaki örneði inceleyerek daha detaylý bilgi
   edilenebilirsiniz. Her bir tick için birden fazla eylem oluþturulabilir.
   </para>
   <para>
    <example>
     <title>PHP kodunun bir bölümünün profili</title>
     <programlisting role="php">
<![CDATA[
<?php
// Çaðrýldýðýnda saati kaydeden bir fonksiyon
function profile($dump = FALSE)
{
    static $profile;

    // Profilde saklanmýþ saati döndürür, sonra siler
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// Tick yönlendiricisini kur
register_tick_function("profile");

// Declare bloðundan önce fonksiyonu kur
profile();

// Bir kod bloðu çalýþtýr, her iki deyimde bir, bir tick çalýþtýr
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Profil verisini görüntüle
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
    Örnekte, 'declare' bloðu içindeki kod incelenerek,
    kaç saniyede bir deyim içerisindeki alt-seviye bir bloðun
    çalýþtýrýldýðý görüntülenmektedir. Bu bilgi daha sonra
    belli bir kod parçacýðýnda yavaþlýða sebep olan bölümlerin
    tespit edilmesi amacýyla kullanýlabilir. Bu proses baþka
    yöntemler kullanýlarak da uygulanabilir: Tick kullanýmý
    daha basit ve kullanýþlý bir yöntemdir.
   </para>
   <simpara>
   Tickler hata ayýklama, basit çokgörevli uygulamalar geliþtirme,
   arkaplanda çalýþan I/O (input/output - girdi/çýktý) ve benzeri
   birçok iþlem için kullanýlabilir.
   </simpara>
   <simpara>
   <function>register_tick_function</function> ve
   <function>unregister_tick_function</function> fonksiyonlarýný
   da inceleyin.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
   Bir fonksiyonun içinden çaðrýldýðýnda, <function>return</function>
   deyimi çalýþmakta olan fonksiyonu hemen sonlandýrýr ve kendisine
   ait argümaný fonksiyonun deðeri olarak döndürür. <function>return</function>
   ayný zamanda <function>eval</function> fonksiyonu ile çalýþtýrýlan
   bir deyimi ya da betiði de sonlandýrýr.
   </simpara>
   <simpara>
   Global kapsamda çaðrýldýðýnda, mevcut çalýþmakta olan betik dosyasýnýn
   çalýþmasý sonlandýrýlýr. Mevcut betik dosyasý <function>include</function>
   ya da <function>require</function> ile çaðrýlmýþ bir dosya ise, kontrol tekrar
   bu dosyayý çaðýran ana dosyaya geçirilir. Dahasý, mevcut betik dosyasý
   <function>include</function> edilmiþse, <function>return</function>
   ile birlikte döndürülen deðer <function>include</function> çaðrýsýnýn
   deðeri olarak döndürülecektir. <function>return</function> ana betik
   dosyasýnýn içinden çaðrýldýðý takdirde, betiðin çalýþmasý sonlandýrýlacaktýr.
   Mevcut betik dosyasý &php.ini; içerisindeki <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> ya da
    <link
    linkend="ini.auto-append-file">auto_append_file</link> yapýlandýrma
    seçenekleri içinde belirtilmiþse, bu betik dosyasýnýn çalýþmasý sonlandýrýlýr.
   </simpara>
   <simpara>Daha fazla bilgi için, <link
   linkend="functions.returning-values">Dönüþ deðerleri</link> bölümünü
   ziyaret edin.
   </simpara>
   <para>
    <note>
     <simpara>
     <function>return</function> bir fonksiyon deðil bir dil yapýsý olduðundan,
     argümanlarýný çevreleyen parantez <emphasis>yalnýzca</emphasis>
     argüman bir ifade içeriyorsa zorunludur. Bir deðiþken döndürürken genellikle
     parantez kullanýlmaz, PHP'de de bu yöntemi izlemeniz gerekir.
     </simpara>
    </note>
    <note>
     <simpara>
     Bir deðiþkeni referans olarak döndürüyorsanýz, <emphasis>asla</emphasis>
     parantez kullanmamalýsýnýz, bu çalýþmayacaktýr. Bir deyimin sonucunu referans olarak
     döndüremezsiniz, yalnýzca deðiþkenler referans olarak döndürülebilir.
     <literal>return ($a);</literal> kullanýyorsanýz, bir deðiþken döndürmüyor ama bir ifadenin
     sonucunu <literal>($a)</literal> döndürüyorsunuz demektir (bu da elbette, <varname>$a</varname>
     deðiþkeninin deðeridir).
      </simpara>
     </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function> deyimi belirtilen dosyayý ekler ve çalýþtýrýr.
   </simpara>
   <simpara>
     <function>require</function> istenen dosyayý ekler ve çalýþtýrýr.
     Ekleme iþleminin nasýl gerçekleþtiðine dair detaylý bilgilendirme
     <function>include</function> bölümünde anlatýlmýþtýr.
   </simpara>
   <simpara>
     <function>require</function> ve <function>include</function>
     birçok yönden birbirlerinin aynýsýdýrlar. Farklý olduklarý yön, baþarýsýzlýk
     durumunda ne yaptýklarýdýr. <function>include</function> bir
     <link linkend="internal.e-warning">Uyarý</link> üretirken,
     <function>require</function> bir <link linkend="internal.e-error">
     Ölümcül Hata</link> üretir. Baþka bir deyiþle, kayýp bir dosyanýn tüm iþleyiþi
     durdurmasýný istiyorsanýz <function>require</function> fonksiyonunu
     kullanmaktan çekinmeyin. <function>include</function> bu þekilde
     davranmayarak betiðin çalýþmaya devam etmesine izin vermektedir.
     <link linkend="ini.include-path">include_path</link> ayarýnýn doðru
     yapýldýðýndan emin olmanýz faydalý olacaktýr.
   </simpara>
   <para>
    <example>
     <title>Temel <function>require</function> örnekleri</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Daha fazla örnek için kýlavuzun <function>include</function> bölümüne bakabilirsiniz.
   </simpara>
   <para>
    <note>
     <simpara>
     PHP 4.0.2'den önce, kullaným þu þekildeydi: <function>require</function>
     komutunun bulunduðu satýþ çalýþtýrýlacak satýrlar arasýnda olmasa bile
     hedef dosyanýn okunmasý mutlaka denenir. 
     Koþula baðlý deyimler <function>require</function> deyimini etkilemeyecektir.
     Ancak, <function>require</function> deyiminin bulunduðu satýr çalýþtýrýlmazsa,
     hedef dosya içindeki hiçbir kod çalýþtýrýlmayacaktýr.Benzer þekilde,
     döngüsel yapýlar <function>require</function> fonksiyonunun bu çalýþma
     þeklini deðiþtirmemektedir. Hedef dosyanýn içerisindeki kod halen döngü tarafýndan
     çalýþtýrýlacak olsa da, <function>require</function> deyiminin kendisi yalnýzca
     bir defa çalýþtýrýlýr.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
   Bakabileceðiniz diðer kaynaklar:
    <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> ve <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><function>include</function></title>
   <simpara>
    <function>include</function> deyimi belirtilen dosyayý okur ve iþler.
   </simpara>
   <simpara>
   Aþaðýdaki dokümantasyon ayný zamanda<function>require</function> için de
   geçerlidir. <function>include</function> ile <function>require</function>
   arasýndaki fark, okunacak ve iþlenecek dosya bulunamadýðýnda,
   <function>include</function> tarafýndan <link linkend="internal.e-warning">Uyarý</link>,
   <function>require</function> tarafýndan <link linkend="internal.e-warning">Ölümcül Hata</link>
   sonucunun üretilmesidir. Baþka bir deyiþle, okunup iþlenmek istenen dosya bulunamýyorsa,
   sayfanýn iþlenmesini durdurmak için <function>require</function> kullanmanýz gerekmektedir.
   <function>include</function> bu þekilde hareket etmez ve betiðin çalýþmaya devam etmesine
   izin verir. Bu deyimi kullanmadan önce <link linkend="ini.include-path">include_path</link>
   ayarýnýzýn doðru olduðundan emin olun. PHP 4.3.5'den önceki sürümlerde, include edilen dosyadaki
   okuma hatasý uygulamanýn çalýþmasýný durdurmuyordu. Bu sürümden itibaren, uygulamanýn
   çalýþmasý durdurulmaktadýr.
   </simpara>
   <simpara>
   Include edilecek dosyalar için öncelikle include_path direktifinin mevcut çalýþma klasörüne göreceli
   konumuna bakýlýr, istenen dosya bulunamazsa mevcut betiðin bulunduðu klasöre göreceli konumda
   dosya aranýr. Örneðin, include_path direktifinizin deðeri <literal>.</literal>, mevcut çalýþma klasörü
   <filename class="directory">/www/</filename>, <filename>include/a.php</filename> include
   edilmiþ ve bu dosyanýn içinde <literal>include "b.php"</literal> komutu var ise, <filename>b.php</filename>
   dosyasý için önce <filename class="directory">/www/</filename> klasörüne bakýlýr ve ardýndan
   <filename class="directory">/www/include/</filename> klasörü taranýr. Dosya ismi <literal>./</literal>
   ile ya da <literal>../</literal> ile baþlýyorsa, dosya yalnýzca mevcut çalýþma klasörüne göreceli include_path
   içersinde aranýr.
   </simpara>
   <simpara>
   Bir dosya include edildiðinde, bu dosyanýn içerdiði kod include deyiminin
   kullanýldýðý satýr itibariyle geçerli olan
   <link linkend="language.variables.scope">deðiþken kapsamýný</link>
   miras alýr. Include komutunun çalýþtýrýldýðý satýra kadar olan tüm deðiþkenler,
   include edilen dosyada da kullanýlabilir olacaktýr.
   </simpara>
   <para>
     <example>
      <title>Temel <function>include</function> örneði</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$renk = 'yeþil';
$meyve = 'elma';

?>

test.php
<?php

echo "Bir $color $fruit"; // A

include 'vars.php';

echo "Bir $color $fruit"; // Bir yeþil elma

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
   Include deyimi, deyimin kullanýldýðý dosya içindeki bir fonksiyonda
   kullanýlýrsa, include edilen dosyanýn içindeki tüm kodlar sanki o fonksiyon
   içinde tanýmlanmýþ gibi çalýþtýrýlacaktýr. Özetle, fonksiyonun deðiþken
   kapsamýna dahil olacaklardýr.
   </simpara>
   <para>
     <example>
     <title>Fonksiyon içi Include kullanýmý</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $renk;

    include 'vars.php';

    echo 'Bir $color $fruit';
}

/* vars.php foo() fonksiyonunun kapsamý
 * içindedir, dolayýsýyla $fruit bu kapsamýn
 * dýþýnda kullanýlamamaktadýr. $color
 * kullanýlabilir çünkü global olarak tanýmlanmýþtýr
 
foo();                    // Bir yeþil elma
echo 'Bir $color $fruit';   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
   Bir dosya include edildiðinde, PHP kipinden çýkýlýr ve HTML kipine
   geçilir. Bu sebeple hedef dosyada çalýþtýrýlmak istenen PHP kodu varsa
   <link linkend="language.basic-syntax.phpmode">
   geçerli bir PHP baþlangýç ve sonlandýrma etiketi</link> arasýna
   konmasý gereklidir. Include edilen dosya sonlandýðýnda, okuyucu
   tekrar HTML kipinden PHP kipine geçmektedir.
   </simpara>
   <simpara>
   "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
   PHP'de etkinleþtirilmiþ ise (öntanýmlý yapýlandýrmada etkindirler),
   yerel dosya yolu belirtmek yerine
   URL (HTTP ya da desteklenen baþka bir protokol üzerinden - 
   protokol listesi için <xref linkend="wrappers"/> bölümünü inceleyin)
   kullanarak include iþlemini gerçekleþtirebilirsiniz. Hedef sunucu
   hedef dosyayý PHP kodu olarak çalýþtýrabiliyorsa, deðiþkenler include
   edilen dosyaya bir URL karakter dizisi olarak HTTP GET ile aktarýlabilir.
   Bu durum dosyayý include edip ana dosyanýn deðiþken kapsamýný miras
   almaktan çok farklý deðildir; betik gerçekte uzaktaki sunucuda çalýþmakta
   ve sonuçlarý yereldeki betiðe include edilmektedir.
      </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>HTTP üzerinden <function>include</function></title>
     <programlisting role="php">
<![CDATA[
<?php

/* Bu örnek www.example.com sitesinin .php uzantýlý dosyalarý çalýþtýrabildiðini
 * ve .txt uzantýlýlarý çalýþtýrmadýðýný kabul eder. Ayrýca, 'Çalýþýr' ifadesi burada 
 * $foo ve $bar deðiþkenlerinin include edilen dosyada kullanýlabilir olup
 * olmadýðýný ifade eder. */

// Çalýþmaz; file.txt dosyasý www.example.com sitesinde PHP tarafýndan iþlenmez
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Çalýþmaz; yerel dosya sisteminde 'file.php?foo=1&bar=2' isminde bir dosya arar
include 'file.php?foo=1&bar=2';

// Çalýþýr.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Çalýþýr.
include 'file.php';  // Çalýþýr.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Güvenlik uyarýsý</title>
    <para>
    Uzaktaki dosya uzaktaki sunucu tarafýndan iþlenebilir (dosyanýn uzantýsýna
    ve uzaktaki sunucunun PHP çalýþtýrýp çalýþtýrmadýðýna baðlý olarak).
    Ancak bu iþlemenin sonucu yine mutlaka geçerli bir PHP betiði olmalýdýr
    çünkü elde edilen çýktý yine yerel sunucu tarafýndan iþlenecektir. Dosyanýn
    uzaktaki sunucuda iþlenmesini ve iþlemlerin o sunucu üzerinde kalmasýný
    istiyorsanýz, <function>readfile</function> daha iyi bir seçim olacaktýr.
    Aksi takdirde, uzakta çalýþtýrýlan betiðin geçerli ve istenen kodu üretebilmesini
    güvence altýna alabilmek için özel çaba harcamak gerekir.
    </para>
   </warning>
   <para>
   Ayrýca bakýn <link linkend="features.remote-files">Uzaktaki dosyalar</link>,
    <function>fopen</function> ve <function>file</function>.
   </para>
   <para>
   <function>include</function> ve <function>require</function> özel
   dil yapýlarý olduklarýndan, koþula baðlý bir blok içinde kullandýðýnýzda bu deyimleri
   deyim bloðu parantezleri ile kapatmanýz gerekmektedir.
   </para>
   <para>
    <example>
     <title>include() ve koþula baðlý bloklar</title>
     <programlisting role="php">
<![CDATA[
<?php

// Bu YANLIÞTIR ve istenildiði gibi çalýþmayacaktýr.
if ($kosul)
    include $file;
else
    include $other;


// Bu DOÐRUDUR.
if ($kosul) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
   Return kullanýmý: Include edilmiþ bir dosyanýn içersinde, bu dosyanýn iþlenmesi
   durdurmak ve include eden betiðe geri dönmek için <function>return</function>
   fonksiyonu kullanýlabilir. Ayrýca, include edilen dosyalardan deðer döndürmek
   de mümkündür. Normal fonksiyonda olduðu gibi, include çaðrýsýndan elde edilen
   deðeri bir deðiþkene atayabilirsiniz. Ancak bu durum, uzaktaki dosyalar için
   tek bir koþul dýþýnda mümkün deðildir: Uzaktaki dosyanýn çýktýsý
   <link linkend="language.basic-syntax.phpmode">geçerli PHP baþlangýç
   ve sonlandýrma etiketlerine</link> sahipse (herhangi yerel bir dosyada olduðu
   gibi), bu özellik uzaktaki dosyalar için de kullanýlabilir. Gerekli deðiþkenleri
   bu etiketlerin arasýnda tanýmlayabilirsiniz, bu þekilde dosyanýn include edildiði
   andan itibaren kullanýlabilir olacaklardýr.
   </simpara>
   <para>
    <function>include</function> özel bir dil yapýsý olduðundan,
    bu argümanýn etrafýnda parantez bulunmasýna gerek yoktur. Dönen deðerle
    ilgili bir karþýlaþtýrma yaparken dikkatli olmalýsýnýz.
    <example>
     <title>Include iþleminden dönen deðerin karþýlaþtýrýlmasý</title>
     <programlisting role="php">
<![CDATA[
<?php
// Çalýþmaz, include(('vars.php') == 'TAMAM') olarak deðerlendirilir, örn. include('')
if (include('vars.php') == 'TAMAM') {
    echo 'TAMAM';
}

// Çalýþýr
if ((include 'vars.php') == 'TAMAM') {
    echo 'TAMAM';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
     PHP 3 sürümünde, sözkonusu blok bir fonksiyon bloðu olmadýðý sürece
     return deyiminin blok içinde kullanýlmasý gerekli deðildir, bu durumda
     <function>return</function> yalnýzca ilgili fonksiyona uygulanýr ve
     dosyanýn tümüne uygulanmaz.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function> ve <function>return</function> deyimleri</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // 'PHP' yazdýrýr

$bar = include 'noreturn.php';

echo $bar; // 1 yazdýrýr

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal>, <literal>1</literal> deðerini taþýyor çünkü
    include iþlemi baþarýyla sonuçlandý. Yukarýdaki örnekler arasýndaki farklara
    dikkat edin. Birincisi <function>return</function> deyimini include
    edilen dosyada kullanýrken ikincisi kullanmýyor. Dosya include edilemediði durumda,
    &false; döndürülüyor ve <literal>E_WARNING</literal> üretiliyor.
   </simpara>
   <para>
   Include edilen dosyanýn içinde tanýmlanmýþ fonksiyonlar varsa, 
   <function>return</function>'den önce ya da sonra olduðundan baðýmsýz olarak
   ana dosya içersinde kullanýlabilirler. Dosya iki defa include edilmiþse, PHP 5
   ölümcül hata üretir çünkü fonksiyonlar halihazýrda deklare edilmiþtir, PHP 4 ise
   <function>return</function>'den sonra tanýmlanmýþ fonksiyonlar için
   þikayet etmeyecektir. Dosyanýn halihazýrda include edilip edilmediðini kendiniz
   tespit edip koþula baðlý return çalýþtýrmak yerine, <function>include_once</function>
   fonksiyonunu kullanmanýz önerilir.
   </para>
   <simpara>
   Bir PHP dosyasýný bir deðiþkene "include" etmenin diðer bir yolu, çýktýyý
   <link linkend="ref.outcontrol">Çýktý Kontol Fonksiyonlarý</link>
   ile yakalamak ve <function>include</function> ile birlikte kullanmaktýr.
   Örneðin:
   </simpara>
   <para>
    <example>
     <title>Include ve Çýktý Tamponlama Kullanýmý</title>
      <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
      </programlisting>
    </example>
   </para>
   <para>
   Uygulamanýzda dosyalarý otomatik include etmek için,
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> ve
    <link linkend="ini.auto-append-file">auto_append_file</link>
    &php.ini; içersindeki yapýlandýrma seçeneklerini inceleyebilirsiniz.
   </para>

   &note.language-construct;

   <simpara>
    Ayrýca bakýn <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, ve
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 xml:id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    <function>require_once</function> deyimi belirtilen dosyayý betiðin çalýþmasý
    esnasýnda okur ve çalýþtýrýr. Bu deyimin çalýþma biçimi
    <function>require</function> deyimi ile benzerdir,tek fark ilgili dosya içerisindeki
    kod tekrar include edilmek isteniyorsa, tekrar include etme iþleminin yapýlmamasýdýr.
    Daha fazla bilgi için <function>require</function> dokümantasyonuna bakabilirsiniz.
   </para>
   <para>
    <function>require_once</function> deyimi, bir betiðin çalýþmasý esnasýnda ayný
    dosyanýn birden fazla defa include edilme ihtimaline karþýlýk, bu dosyanýn yalnýzca
    bir defa include edileceðinden emin olmak istediðinizde kullanýlmalýdýr. Bu sayede
    fonksiyonlarýn yeniden tanýmlanmaya çalýþýlmasý, deðiþkenlere tekrar deðer atanmasý
    gibi sorunlardan korunmuþ olursunuz.
   </para>
   <para>
    <function>require_once</function> ve
     <function>include_once</function> ile ilgili örnekler için, PHP'nin en son
     kaynak kodu daðýtýmýnda yer alan
     <link xlink:href="&url.php.pear;">PEAR</link> kodlarýný inceleyebilirsiniz.
   </para>
   <para>
   Dönen deðerlerin yönetimi <function>include</function> fonksiyonu ile aynýdýr.
   Dosya halihazýrda include edilmiþse, bu fonksiyon &true; deðerini döndürür.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> PHP 4.0.1pl2 ile eklenmiþtir.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
     Büyük-küçük harf duyarlý olmayan iþletim sistemlerinde (Windows gibi),
     <function>require_once</function> ve <function>include_once</function>
     deyimlerinin beklediðiniz sonucu üretmeyebileceðine dikkat edin.
      <example>
       <title><function>require_once</function> Windows'ta büyük-küçük harf duyarsýzdýr</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // bu a.php dosyasýný include edecektir
require_once("A.php"); // bu Windows altýnda yine a.php dosyasýný include edecektir! (yalnýzca PHP 4)
?>
]]>
        </programlisting>
      </example>
      Bu davranýþ PHP 5'te deðiþmiþtir - öncelikle yol normalize edilir, böylece
      <filename>C:\PROGRA~1\A.php</filename> ile <filename>C:\Program Files\a.php</filename>
      ayný kapsamda deðerlendirilir ve dosya yalnýzca bir defa iþlenir.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Ayrýca bakýn <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>, ve
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function> betiðin çalýþmasý esnasýnda belirtilen
    dosyayý okur ve iþler.
    Bu çalýþma biçimi <function>include</function> deyimi ile benzerdir,
    tek fark dosyanýn içindeki kod halihazýrda include edilmiþse, include iþlemi
    tekrarlanmaz. Ýsimden de anlaþýlabileceði gibi, dosya yalnýzca bir defa
    include edilir.
   </para>
   <para>
    <function>include_once</function> deyimi, bir betiðin çalýþmasý esnasýnda ayný
    dosyanýn birden fazla defa include edilme ihtimaline karþýlýk, bu dosyanýn yalnýzca
    bir defa include edileceðinden emin olmak istediðinizde kullanýlmalýdýr. Bu sayede
    fonksiyonlarýn yeniden tanýmlanmaya çalýþýlmasý, deðiþkenlere tekrar deðer atanmasý
    gibi sorunlardan korunmuþ olursunuz.
   </para>
   <para>
   <function>require_once</function> ve <function>include_once</function>
   kullanýmý ile ilgili daha fazla örnek için, PHP'nin en son
     kaynak kodu daðýtýmýnda yer alan
     <link xlink:href="&url.php.pear;">PEAR</link> kodlarýný inceleyebilirsiniz.
   </para>
   <para>
   Dönen deðerlerin yönetimi <function>include</function> fonksiyonu ile aynýdýr.
   Dosya halihazýrda include edilmiþse, bu fonksiyon &true; deðerini döndürür.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> PHP 4.0.1pl2 sürümü ile eklenmiþtir.
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
     Büyük-küçük harf duyarlý olmayan iþletim sistemlerinde (Windows gibi),
     <function>require_once</function> ve <function>include_once</function>
     deyimlerinin beklediðiniz sonucu üretmeyebileceðine dikkat edin.
      <example>
       <title><function>include_once</function> Windows'ta büyük-küçük harf duyarsýzdýr</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // bu a.php dosyasýný include edecektir
include_once("A.php"); // bu Windows altýnda yine a.php dosyasýný include edecektir! (yalnýzca PHP 4)
?>
]]>
        </programlisting>
      </example>
      Bu davranýþ PHP 5'te deðiþmiþtir - öncelikle yol normalize edilir, böylece
      <filename>C:\PROGRA~1\A.php</filename> ile <filename>C:\Program Files\a.php</filename>
      ayný kapsamda deðerlendirilir ve dosya yalnýzca bir defa iþlenir.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Ayrýca bakýn <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    ve <function>virtual</function>.
   </para>
  </sect1>
  
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
