<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.8 $ -->
<!-- $Header: /home/svn/phpsvn_tmp/cvsrepo/phpdoc/tr/language/control-structures.xml,v 1.8 2008-01-11 08:02:21 sezer Exp $ -->
 <chapter xml:id="language.control-structures" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Kontrol Yapıları</title>

  <simpara>
  Bütün PHP betikleri bir dizi deyimden (statement) oluşur. Bir deyim;
  bir atama, bir fonksiyonun çağrılması, bir döngü, bir koşullu deyim hatta
  hiçbir şey yapmayan bir deyim (boş bir deyim) olabilir. Deyimler bir
  noktalı virgülle sonlandırılır. Ek olarak, deyimler köşeli parantez içine
  alınarak deyim grupları haline getirilebilirler. Bir deyim grubu da
  kendi başına bir deyim olarak kabul edilir. Bu bölümde çeşitli tiplerdeki
  deyimlerin anlatımını yapacağız.
  </simpara>

  <sect1 xml:id="control-structures.if">
   <title><literal>if</literal></title>
   <para>
    <literal>If</literal> yapısı, PHP dahil olmak üzere birçok programlama
    dilindeki en önemli özelliklerden biridir. Bu yapı, kod bölümlerinin koşullu
    olarak çalıştırılabilmelerini sağlar. PHP, C dilindekine benzer bir
    <literal>if</literal> yapısı sunar.
    <informalexample>
     <programlisting>
<![CDATA[
if (ifade)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   <link linkend="language.expressions">İfadelerle ilgili bölüm</link>de
   anlatıldığı gibi, <replaceable>ifade</replaceable> kendi ikili değeri (boolean value) üzerinden
   değerlendirilir. <replaceable>İfade</replaceable> &true; değerini oluşturuyorsa,
   PHP <replaceable>deyimi</replaceable> çalıştırır, eğer &false; değerini oluşturuyorsa gözardı eder.
   Hangi değerlerin &false; olarak değerlendirildiği hakkında daha fazla bilgi için <link
    linkend="language.types.boolean.casting">'İkili değere dönüştürmek'</link> bölümünden
    faydalanabilirsiniz.
   </simpara>
   <para>
   Buradaki örnek, <varname>$a</varname> değeri <varname>$b</varname>
   değerinden büyük olduğu takdirde <computeroutput>a büyüktür
    b</computeroutput> metnini görüntüleyecektir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b)
    echo "a büyüktür b";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Sıklıkla birden çok deyimin koşullu olarak çalıştırılmasını isteyeceksiniz.
   Elbette, her bir deyimi ayrı ayrı <literal>if</literal> yantümcelerine (clause)
   almanıza gerek yoktur. Birden çok deyimi biraraya getirerek tek bir deyim grubu
   oluşturabilirsiniz. Örneğin, Bu kod <varname>$a</varname> değeri
   <varname>$b</varname> değerinden büyük olduğu takdirde
   <computeroutput>a büyüktür b</computeroutput> metnini görüntüleyecektir ve
   sonrasında <varname>$a</varname> değişkeninin değerini 
   <varname>$b</varname> değişkenine atayacaktır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
    $b = $a;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    <literal>If</literal> deyimleri sonsuz sayıda diğer
    <literal>if</literal> deyiminin içine gömülebilir. Bu size
    uygulamanızın çeşitli bölümlerinde koşullu deyimler
    uygulayabilmeniz için tam bir esneklik sağlar.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.else">
   <title><literal>else</literal></title>
   <para>
   Çoğu zaman belli bir koşul sağlandığında bir deyimin, o koşul sağlanmadığında
   başka bir deyimin çalıştırılmasını isteyeceksiniz. Bu yapıyı sağlamak için
   <literal>else</literal> kullanılmaktadır. <literal>Else</literal>,
   bir <literal>if</literal> deyiminin genişleyerek, belirtilen koşul sağlanmadığı
   ve &false; döndürdüğü takdirde ne yapılacağını belirtmek için kullanılır.
   Örneğin, buradaki kod <varname>$a</varname>
   değeri <varname>$b</varname> değerinden büyükse
   <computeroutput>a büyüktür b</computeroutput> mesajını,
   büyük değilse <computeroutput>a büyük değildir b</computeroutput>
   mesajını görüntüleyecektir:
   <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} else {
    echo "a büyük değildir b";
}
?>
]]>
     </programlisting>
    </informalexample>

    <literal>Else</literal> deyimi yalnızca <literal>if</literal> deyiminin
    &false; döndürdüğü durumda çalıştırılacaktır. Aynı durum, &false;
    döndüren herhangi bir <literal>elseif</literal> ifadesinin olması durumunda da
    geçerlidir (bakınız <link
    linkend="control-structures.elseif">elseif</link>).
   </para>
  </sect1>

  <sect1 xml:id="control-structures.elseif">
   <title><literal>elseif</literal></title>
   <para>
    <literal>elseif</literal>, isminden de anlaşılacağı gibi, <literal>if</literal> ve
    <literal>else</literal> deyimlerinin biraraya gelmesiyle oluşur. 
    <literal>else</literal> gibi, orijinal <literal>if</literal> ifadesinin
    &false; döndürdüğü durumda farklı bir deyimin çalıştırılması için kullanılır.
    Ancak, <literal>else</literal>'ten faklı olarak, bu deyim alternatif ifadeyi
    yalnızca kendisine ait koşullu ifade &true; değerini döndürdüğü durumda çalıştıracaktır.
    Örneğin, buradaki kod <computeroutput>a büyüktür b</computeroutput>,
    <computeroutput>a eşittir b</computeroutput> ya da 
    <computeroutput>a küçüktür b</computeroutput> mesajını görüntüleyecektir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a > $b) {
    echo "a büyüktür b";
} elseif ($a == $b) {
    echo "a eşittir b";
} else {
    echo "a küçüktür b";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Aynı <literal>if</literal> deyimine ait birden çok <literal>elseif</literal>
   bulunabilir. İlk önce hangi <literal>elseif</literal> deyimi &true; değerini
   döndürürse (eğer döndüren varsa) o deyim çalıştırılır. Bu deyimi 'elseif'
   biçiminde tek sözcük olarak kullanabileceğiniz gibi, 'else if' biçiminde iki
   sözcük olarak da kullanabilirsiniz, sonuç aynı olacaktır. Sözdimi anlamı açısından
   küçük bir farklılık olsa da (C diline aşinaysanız, aynı fark) sonuç olarak her ikisi
   de aynı sonucu üretecektir.
   </simpara>
   <simpara>
   <literal>elseif</literal> ifadesi yalnızca kendisinden önceki <literal>if</literal> ifadesi
   ve bu ifadeye bağlı kendisinden önce gelen diğer tüm <literal>elseif</literal> ifadeleri &false; olduğunda
   çalıştırılır ve &true; değerini döndürür.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.alternative-syntax">
   <title>Kontrol yapıları için alternatif sözdizimi</title>
   <para>
   PHP bazı kontrol yapıları için alternatif sözdizimi imkanları sunar.
   Bunlar <literal>if</literal>,
    <literal>while</literal>, <literal>for</literal>,
    <literal>foreach</literal> ve <literal>switch</literal> yapılarıdır.
    Her bir durumda, alternatif sözdiziminin basit şekli açılışta kullanılan köşeli parantez
    yerine iki nokta üst üste (:) kullanmak ve kapanışta kullanılan köşeli parantez yerine
    <literal>endif;</literal>, <literal>endwhile;</literal>,
    <literal>endfor;</literal>, <literal>endforeach;</literal> ya da
    <literal>endswitch;</literal> deyimlerinden birini kullanmaktır.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php if ($a == 5): ?>
A eşittir 5
<?php endif; ?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Yukarıdaki örnekte, içeriği "A eşittir 5" olan HTML bloğu alternatif sözdimi
   kullanılarak yazılmış bir <literal>if</literal> deyiminin içine gömülmüştür.
   HTML bloğu yalnızca <varname>$a</varname> değişkeni 5'e eşit olduğunda
   gösterilecektir.
   </simpara>
   <para>
   Alternatif sözdimi, <literal>else</literal> ve <literal>elseif</literal>
   için de kullanılabilir. Birazdan vereceğimiz örnek, alternatif format ile yazılmış
   ve <literal>elseif</literal> ile <literal>else</literal> içeren bir
   <literal>if</literal> yapısıdır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
if ($a == 5):
    echo "a eşittir 5";
    echo "...";
elseif ($a == 6):
    echo "a eşittir 6";
    echo "!!!";
else:
    echo "a ne 5 ne de 6";
endif;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Daha fazla örnek için <link linkend="control-structures.while">while</link>,
    <link linkend="control-structures.for">for</link>, ve <link
    linkend="control-structures.if">if</link> bölümlerine bakabilirsiniz.
   </para>
  </sect1>

  <sect1 xml:id="control-structures.while">
   <title><literal>while</literal></title>
   <para>
    <literal>while</literal> döngüsü PHP'de yer alan en basit döngü tipidir.
    C'deki karşılığı ile aynı şekilde çalışır. Bir <literal>while</literal> deyiminin
    basit kullanımı:
    <informalexample>
     <programlisting>
<![CDATA[
while (ifade)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   <literal>While</literal> deyiminin anlamı basittir. Kendi kapsama
   alanı içinde tanımlanmış deyimlerin tekrar tekrar çalıştırılmasını
   sağlar. Tekrar çalıştırma işlemi <literal>while</literal> deyimine
   ait ifadenin karşılığı &true; oldukça devam eder. İfadenin değeri döngü
   her tekrarlandığında yeniden hesaplanır, deyimlerin çalıştırılması
   sırasında bu ifadenin değeri değişse bile, döngü içindeki deyimler
   en son adıma kadar çalıştırılmaya devam edilir (PHP'nin döngü içindeki
   deyimleri her çalıştırışı bir döngüyü ifade etmektedir). Bazen,
   <literal>while</literal> ifadesi daha ilk tekrardan önce &false; değerini
   verir, bu durumda <literal>while</literal> kapsamındaki deyimler
   tek bir defa bile çalıştırılmazlar.
   </simpara>
   <para>
   <literal>If</literal> deyiminde olduğu gibi, birden çok deyimi aynı
   <literal>while</literal> döngüsü içinde köşeli parantez kullanarak ya da
   alternatif sözdimi yönteminden faydalanarak gruplayabilirsiniz:
   <informalexample>
     <programlisting>
<![CDATA[
while (ifade):
    deyimler
    ...
endwhile;
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Aşağıdaki örnekler birbirleri ile aynıdırlar, her ikisi de 1'den 10'a kadar
   rakamları yazacaktır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* yazdırılan değer $i
                    değerinin artıştan önceki
                    değeridir (sonda-arttırım) */
}

/* örnek 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.do.while">
   <title><literal>do-while</literal></title>
   <simpara>
    <literal>do-while</literal> döngüsü,
    <literal>while</literal> döngüsü ile oldukça benzerdir.
    <literal>do-while</literal> döngüsünün farkı, kontrol edilecek
    ifadenin tekrarların başında değil sonunda kontrol ediliyor olmasıdır.
    <literal>while</literal> döngüsü ile temek farklılık, <literal>do-while</literal>
    kullanıldığında ilk tekrarın çalışmasının garanti altına alınıyor olmasıdır
    (ifadenin doğruluğu yalnızca tekrarın sonunda kontrol edilecektir). 
    <literal>while</literal> döngüsü, ifadenin kontrolünü her bir tekrardan önce
    yapmaktadır, ilk tekrar öncesinde &false; değeri alındığı takdirde, döngü daha
    başlamadan sona erecektir.
   </simpara>
   <para>
   <literal>do-while</literal> döngüsü için yalnızca tek bir sözdizimi mevcuttur:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Yukarıdaki döngü tam olarak bir defa çalışacaktır, ilk tekrardan sonra ifadenin
   doğruluğu kontrol edildiğinde, &false; değerini verecek ($i büyük değildir 0) ve
   döngünün çalışması sonlanacaktır.
   </simpara>
   <para>
   İleri seviye C kullanıcıları <literal>do-while</literal> döngüsünün
   farklı kullanımlarına aşina olabilirler. Bu döngü, kod bloklarının çalıştırıldıkları
   esnada çalışmanın ortasında sonlandırılmalarını sağlamak için kullanılabilir.
   Bu işlem kod bloğunu <literal>do-while</literal> (0) döngüsü içine alıp
   <link linkend="control-structures.break"><literal>break</literal></link> deyimi
   kullanılarak yapılabilmektedir. Aşağıdaki kod parçası bu durumu örneklemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
do {
    if ($i < 5) {
        echo "i yeterince büyük değil";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "i uygun";

    /* i değerini işle */

} while (0);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Bu yöntemi anlamadıysanız endişelenmeyin. Bu 'özelliği' kullanmadan
   da oldukça gelişmiş ve güçlü uygulamalar geliştirebilirsiniz.
   </simpara>
  </sect1>

  <sect1 xml:id="control-structures.for">
   <title><literal>for</literal></title>
   <para>
    <literal>for</literal> döngüsü, PHP dahilindeki en karmaşık döngü
    yapısıdır. C'deki karşılığı ile aynı biçimde çalışır. <literal>for</literal>
    döngüsünün sözdimi şu şekildedir:
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   İlk ifade (<varname>expr1</varname>) döngünün en başında
   tek bir defa koşulsuz olarak çalıştırılır.
   </simpara>
   <simpara>
   Her bir tekrarın başında, <varname>expr2</varname> çalıştırılır.
   Bu ifadeden &true; sonucu elde edilirse, döngüye devam edilir ve döngü
   dahilindeki deyimler çalıştırılır. Bu ifadeden &false; sonucu elde edilirse,
   döngünün çalışması sonlandırılır.
   </simpara>
   <simpara>
   Her bir tekrarın sonunda, <varname>expr3</varname>
   çalıştırılır.
   </simpara>
   <simpara>
   İfadelerin herbiri için boş kullanım mümkündür.
   <varname>expr2</varname> ifadesinin boş olması, döngünün
   sonsuza kadar çalıştırılacağı anlamına gelir (PHP C'deki gibi bu durumu
   &true; olarak değerlendirir). Döngüleri sıklıkla bir şarta bağlı olarak
   <link linkend="control-structures.break"><literal>break</literal></link>
   deyimi ile sonlandırmak isteyeceğiniz düşünüldüğünde, bu durum
   düşündüğünüz kadar kullanışsız değildir. Bu kullanım size
   <literal>for</literal> deyiminin imkanlarından daha fazla esneklik
   sağlayabilir.
   </simpara>
   <para>
   Aşağıdaki örnekleri inceleyin ve karşılaştırın. Hepsi de 1'den 10'a kadar
   rakamları görüntülemektedir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* örnek 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* örnek 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* örnek 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

/* örnek 4 */

for ($i = 1; $i <= 10; print $i, $i++);
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Elbette, kullandığımız ilk örnek en güzel örnek olarak gözükmektedir (
   ya da belki dördüncü örnek), ancak birçok durumda <literal>for</literal>
   döngüsü içerisinde boş ifadeler kullanmanın oldukça kullanışlı olduğu
   sonucuna varabilirsiniz.
   </simpara>
   <para>
   PHP, alternatif "iki nokta üst üste" sözdimi şeklini
   <literal>for</literal> döngüleri için de desteklemektedir.
    <informalexample>
     <programlisting>
<![CDATA[
for (ifade1; ifade2; ifade3):
    deyimler
    ...
endfor;
]]>
     </programlisting>
     </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.foreach">
   <title><literal>foreach</literal></title>
   <para>
   PHP 4 ile birlikte Perl ve bazı diğer dillerde mevcut olan
   <literal>foreach</literal> yapısı da kullanıma sunulmuştur.
   Bu deyimi dizi-değişkenler üzerinde tekrar işlemleri yapmayı
   kolaylaştırmaktadır. <literal>foreach</literal> yalnızca
   diziler için kullanılabilir; farklı bir değişken veri tipi ile ya da henüz
   oluşturulmamış bir değişken ile kullanmak istediğinizde hata oluşturacaktır.
   İki türlü sözdizimi mevcuttur; ikinci kullanım şekli birinciden biraz daha uzun
   ama biraz daha kullanışlıdır:
    <informalexample>
     <programlisting>
<![CDATA[
foreach (array_expression as $value)
    deyimler
foreach (array_expression as $key => $value)
    deyimler
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   İlk yöntem <literal>array_expression</literal> ile belirtilen
   dizinin üzerinde döngü oluşturur. Her tekrarda, mevcut elemanın
   değeri <literal>$value</literal> değişkenine atanır ve dizinin
   iç imleci bir ilerletilir (böylece sonraki tekrarda, son elemana
   bakılıyor olması sağlanır).
   </simpara>
   <simpara>
   İkinci yöntem aynı şeyi yapar, yalnızca her tekrarda mevcut elemanın
   anahtar değeri <literal>$key</literal> değişkenine atanır.
   </simpara>
   <simpara>
   PHP 5'den itibaren, <link linkend="language.oop5.iterations">nesneler üzerinde tekrar yapmak</link>
   mümkün olmuştur.
   </simpara>
   <para>
    <note>
     <para>
     <literal>foreach</literal> ilk çalışmaya başladığında, dizinin iç imleci
     otomatik olarak ilk elemanı gösterecek biçimde sıfırlanır. Bu sebeple
     <literal>foreach</literal> deyiminden önce <function>reset</function>
     fonksiyonunu çalıştırmanıza gerek yoktur.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
     Dizi <link linkend="language.references">referans edilmiş</link> olmadığı
     sürece, <literal>foreach</literal> dizinin kendisi üzerinde çalışmaz,
     bir kopyası üzerinde çalışır. Bundan dolayı dizi imleci <function>each</function>
     yapısında olduğu gibi değiştirilmez, ve döndürülen dizi elemanı üzerinde yapılan
     değişiklikler orijinal diziye yansıtılmaz. Öte yandan, orijinal dizinin imleci
     dizi üzerinde işlem yapıldıkça <emphasis>ilerler</emphasis>. foreach döngüsünün
     çalışması tamamlandığında, dizinin iç imleci de dizinin sonuna gelmiş olacaktır.
     </para>
     <para>
     PHP 5'den itibaren, dizinin elemanları üzerinde <literal>$value</literal> değişkeninin
     önüne &amp; koyarak değişiklik yapabilirsiniz. Bu kullanım değerin bir kopyasını kullanmak
     yerine kendisine bir <link linkend="language.references">referans</link> atanmasını
     sağlayacaktır:
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(1, 2, 3, 4);
foreach ($arr as &$value) {
    $value = $value * 2;
}
// $arr şimdi array(2, 4, 6, 8) olmuştur
?>
]]>
       </programlisting>
      </informalexample>
      Bu durum yalnızca üzerinde çalışılan dizi referans oluşturulabilir
      türde ise mümkündür (örn. bir değişkense).
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
      <literal>foreach</literal> ile hata mesajlarının '@' kullanılarak
      gözardı edilmesi mümkün değildir.
     </para>
    </note>
   </para>
   <para>
   İşlevsel olarak aşağıdakilerin birbirleri ile aynı olduğunu tespit
   etmiş olabilirsiniz:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("bir", "iki", "üç");
reset($arr);
while (list(, $value) = each($arr)) {
    echo "Değer: $value<br />\n";
}

foreach ($arr as $value) {
    echo "Değer: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
    Aşağıdakiler de işlevsel olarak aynıdır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array("bir", "iki", "üç");
reset($arr);
while (list($key, $value) = each($arr)) {
    echo "Anahtar: $key; Değer: $value<br />\n";
}

foreach ($arr as $key => $value) {
    echo "Anahtar: $key; Değer: $value<br />\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   Değişik kullanımlara örnekler:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* foreach örnek 1: yalnızca değer */

$a = array(1, 2, 3, 17);

foreach ($a as $v) {
   echo "\$a değişkeninin şu anki değeri: $v.\n";
}

/* foreach örnek 2: değer (örnek olması için anahtar ile birlikte yazdırılmıştır) */

$a = array(1, 2, 3, 17);

$i = 0; /* for yalnızca örnekleme için */

foreach ($a as $v) {
    echo "\$a[$i] => $v.\n";
    $i++;
}

/* foreach örnek 3: anahtar ve değer */

$a = array(
    "bir" => 1,
    "iki" => 2,
    "üç" => 3,
    "on yedi" => 17
);

foreach ($a as $k => $v) {
    echo "\$a[$k] => $v.\n";
}

/* foreach örnek 4: çok boyutlu diziler */
$a = array();
$a[0][0] = "a";
$a[0][1] = "b";
$a[1][0] = "y";
$a[1][1] = "z";

foreach ($a as $v1) {
    foreach ($v1 as $v2) {
        echo "$v2\n";
    }
}

/* foreach örnek 5: dinamik diziler */

foreach (array(1, 2, 3, 4, 5) as $v) {
    echo "$v\n";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.break">
   <title><literal>break</literal></title>
   <simpara>
    <literal>break</literal> deyimi,
    <literal>for</literal>, <literal>foreach</literal>,
    <literal>while</literal>, <literal>do-while</literal> veya
    <literal>switch</literal> yapılarının çalışmasını durdurmak için kullanılır.
   </simpara>
   <simpara>
    <literal>break</literal> deyimi ile seçime bağlı bir sayısal argüman
    kullanılabilir. Bu argüman iç içe kaç tane yapının aynı anda durdurulacağını
    belirler.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr = array('sifir', 'bir', 'iki', 'üç', 'dur', 'dört', 'beş');
while (list(, $val) = each($arr)) {
    if ($val == 'dur') {
        break;    /* Aynı zamanda 'break 1;' de yazabilirsiniz. */
    }
    echo "$val<br />\n";
}

/* Seçime bağlı argümanın kullanımı. */

$i = 0;
while (++$i) {
    switch ($i) {
    case 5:
        echo "5'de<br />\n";
        break 1;  /* Yalnızca switch'ten çıkar. */
    case 10:
        echo "10'da; çıkılıyor<br />\n";
        break 2;  /* switch ve while'dan birlikte çıkılır. */
    default:
        break;
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.continue">
   <title><literal>continue</literal></title>
   <simpara>
    <literal>continue</literal> deyimi döngü yapılarının arasında kullanılır.
    Bu deyim kullanıldığında, döngünün kalan kısmı atlanır ve
    sonraki döngü tekrarına başlanılır.
   </simpara>
   <note>
    <simpara>
    PHP'de
     <link linkend="control-structures.switch">switch</link> deyimi
     <literal>continue</literal> deyiminin kullanılabileceği döngülerden
     biri olarak kabul edilmektedir.
    </simpara>
   </note>
   <simpara>
    <literal>continue</literal> deyime ile seçime bağlı sayısal bir argüman
    kullanılarak, kaç seviye üstteki döngüye kadar atlama işleminin uygulanacağı
    belirtilebilir.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
while (list($key, $value) = each($arr)) {
    if (!($key % 2)) { // tek sayıları atla
        continue;
    }
    do_something_odd($value);
}

$i = 0;
while ($i++ < 5) {
    echo "Dış<br />\n";
    while (1) {
        echo "&nbsp;&nbsp;Orta<br />\n";
        while (1) {
            echo "&nbsp;&nbsp;İç<br />\n";
            continue 3;
        }
        echo "Bu hiçbir zaman çıktı vermez.<br />\n";
    }
    echo "Bundan da çıktı alamazsınız.<br />\n";
}
?>
]]>
     </programlisting>
     </informalexample>
    </para>
    <para>
    <literal>continue</literal> deyiminden sonra noktalı virgül konmazsa
    bu durum karışıklığa yol açabilir. Yapmamanız gereken ile ilgili bir örnek:
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
  for ($i = 0; $i < 5; ++$i) {
      if ($i == 2)
          continue
      print "$i\n";
  }
?>
]]>
      </programlisting>
      <para>
       Þu biçimde bir çıktı almayı bekleyebilirsiniz:
      </para>
      <screen>
<![CDATA[
0
1
3
4
]]>
      </screen>
      <para>
       Ancak beklenen çıktı şu şekilde olacaktır:
      </para>
      <screen>
<![CDATA[
2
]]>
      </screen>
      <para>
      Bunun sebebi <function>print</function> fonksiyonundan dönen
      değerin <literal>int(1)</literal> olması ve bu dönen değerin
      PHP tarafından yukarıda bahsedilen seçime sağlı sayısal argüman
      olarak algılanmasıdır.
      </para>
     </informalexample>
    </para>
  </sect1>

  <sect1 xml:id="control-structures.switch">
   <title><literal>switch</literal></title>
   <simpara>
    <literal>switch</literal> deyimi, aynı ifade içersinde yer alan bir dizi
    IF deyimine benzer. Birçok durumda, aynı değişkeni (ya da ifadeyi)
    birden çok değerle karşılaştırmak ve her karşılaştırmanın sonucunu
    ayrı bir kod parçası çalıştırarak değerlendirmek istersiniz. Bu tam olarak
    <literal>switch</literal> deyiminin varlık sebebidir.
   </simpara>
   <note>
    <simpara>
    Başka bazı dillerden farklı olarak, <link linkend="control-structures.continue">continue</link>
    deyimi switch ile uygulanabilir ve <literal>break</literal> ile benzerlik
    gösterir. Bir döngü içerisinde switch kullandıysanız ve kodun yürütülmesine
    dıştaki döngünün tekrarlanmasıyla devam etmek istiyorsanız, <literal>continue 2</literal>
    sözdizimini kullanabilirsiniz.
    </simpara>
   </note>
   <para>
   Aşağıdaki iki örnek aynı şeyi yazmanın iki farklı yolunu göstermektedir.
   Birincisi bir dizi <literal>if</literal> ve  <literal>elseif</literal>
   deyiminin kullanımını, ikincisi ise <literal>switch</literal>
   deyiminin kullanımını örneklemektedir:
    <example>
     <title><literal>switch</literal> yapısı</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($i == 0) {
    echo "i eşittir 0";
} elseif ($i == 1) {
    echo "i eşittir 1";
} elseif ($i == 2) {
    echo "i eşittir 2";
}

switch ($i) {
case 0:
    echo "i eşittir 0";
    break;
case 1:
    echo "i eşittir 1";
    break;
case 2:
    echo "i eşittir 2";
    break;
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>switch</literal> ile karakter dizisi kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case "elma":
    echo "i bir elmadır";
    break;
case "çikolata":
    echo "i bir çikolatadır";
    break;
case "kek":
    echo "i bir kektir";
    break;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
   Hatalardan kaçınmak için <literal>switch</literal> deyiminin
   nasıl çalıştığını anlamak önemlidir. <literal>Switch</literal>
   deyimi satır satır çalışır (yani deyim deyim). Başlangıçta,
   hiçbir kod çalıştırılmaz. Yalnızca <literal>switch</literal> 
   ifadesiyle birlikte verilen değer ile uyuşan <literal>case</literal>
   deyimi bulunduğunda PHP ilgili deyimleri çalıştırmaya başlar.
   PHP <literal>switch</literal> bloğu sonlanana kadar ya da
   ilk <literal>break</literal> deyimi ile karşılaşıncaya kadar
   çalışmasına devam eder. Bir case bloğunun sonuna
   <literal>break</literal> koymazsanız, PHP bu bloktan sonra
   gelen kodları çalıştırmaya devam eder. Örneğin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eşittir 0";
case 1:
    echo "i eşittir 1";
case 2:
    echo "i eşittir 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Burada, <varname>$i</varname> 0'a eşit ise, PHP tüm echo deyimlerini
   çalıştıracaktır! <varname>$i</varname> 1'e eşit ise, PHP sondaki iki echo
   deyimini çalıştıracaktır! Beklediğiniz sonucu ('i eşittir 2' metninin görüntülenmesi) yalnızca
   <varname>$i</varname> 2'ye eşitse almanız mümkün olacaktır. Bu durumu engellemek
   için, <literal>break</literal> deyimini kullanmayı unutmamanız önemlidir (bazı durumlarda
   break deyimini kullanmak istemeyebilirsiniz).
   </simpara>
   <simpara>
    Bir <literal>switch</literal> deyiminde, koşul yalnızca bir defa sorgulanır
    ve sonuç her bir <literal>case</literal> deyimi ile karşılaştırılır. Bir
    <literal>elseif</literal> deyiminde, koşul tekrar sorgulanır. Kullanmak istediğiniz
    koşul basit bir karşılaştırma işleminden daha karmaşıksa ve/veya bir döngü
    içerisindeyse, <literal>switch</literal> kullanmak daha hızlı olabilir.
   </simpara>
   <para>
   Case bloğu kod içermeyebilir ve amacı yalnızca kontrolü bir sonraki case
   bloğuna geçirmek olabilir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
case 1:
case 2:
    echo "i 3'ten küçüktür ama negatif değildir";
    break;
case 3:
    echo "i eşittir 3";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   <literal>Default</literal> durumu özel bir durumdur. Bu durum diğer
   hiçbir <literal>case</literal> ile uyuşmayan değerle için kullanılır ve
   en sonda yer almalıdır. Örneğin:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i) {
case 0:
    echo "i eşittir 0";
    break;
case 1:
    echo "i eşittir 1";
    break;
case 2:
    echo "i eşittir 2";
    break;
default:
    echo "i eşit değildir 0, 1 ya da 2";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>Case</literal> ile kullanılan ifade, basit tip olması kaydıyla herhangi
    bir tip olabilir, tam sayı (integer), kayan noktalı sayı (floating point) ve karakter dizisi (string) gibi.
    Diziler ya da objeler, basit tipte bir değere indirgenmedikleri sürece kullanılamazlar.
   </para>
   <para>
   Kontrol yapıları için alternatif söz dizimi, switch deyimi için de desteklenmektedir.
   Daha fazla bilgi için, <link
    linkend="control-structures.alternative-syntax">Kontrol yapıları için alternatif
    söz dizimi</link> bölümünü inceleyebilirsiniz.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
switch ($i):
case 0:
    echo "i eşittir 0";
    break;
case 1:
    echo "i eşittir 1";
    break;
case 2:
    echo "i eşittir 2";
    break;
default:
    echo "i eşit değildir 0'a, 1'e ya da 2'ye";
endswitch;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="control-structures.declare">
   <title><literal>declare</literal></title>
   <para>
   <literal>Declare</literal> yapısı bir kod bloğunun
   çalıştırılması esnasında uygulanacak direktifleri belirlemek
   için kullanılır. <literal>Declare</literal> yapısının söz dizimi
   diğer akış kontrol yapılarının söz dizimi ile benzerdir:
    <informalexample>
     <programlisting>
<![CDATA[
declare (direktif)
    deyim
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
   <literal>Directive</literal> bölümü, <literal>declare</literal>
   bloğunun nasıl davranacağını belirlemek için kullanılır.
   Þu an için yalnızca bir direktif kullanılabilmektedir:
    <literal>Ticks</literal> direktifi. (<link linkend="control-structures.declare.ticks">Ticks</link>
    hakkında daha fazla bilgi edinmek istiyorsanız aşağıya gözatın.
   </para>
   <para>
   <literal>Declare</literal> bloğunun <literal>deyim</literal>
   bölümünün nasıl çalıştırılacağı ve çalışma esnasındaki yan
   etkilerinin ne olacağı <literal>directive</literal> bloğunda
   belirtilir.
   </para>
   <para>
   <literal>Declare</literal> yapısı global kapsamda kullanılabilir ve
   kendisinden sonra gelen tüm kodu etkilemesi sağlanabilir.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// aşağıdaki iki örnek aynıdır:

// bunu kullanabilirsiniz:
declare(ticks=1) {
    // bütün uygulama kodunuz
}

// ya da bunu kullanabilirsiniz:
declare(ticks=1);
// bütün uygulama kodunuz
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <sect2 xml:id="control-structures.declare.ticks">
    <title>Tick'ler</title>
    <para>Tick, <literal>declare</literal>
    bloğu içerisinde tanımlanmış kodun
    PHP tarayıcısı tarafından her bir
    <varname>N</varname>  alt-seviye deyimi için
    çalıştırıldığı eyleme verilen isimdir. <varname>N</varname>
    için belirlenen değer 
    <literal>ticks=N</literal>
    biçiminde <literal>declare</literal> bloğunun
    <literal>directive</literal> bölümünde tanımlanır.
   </para>
   <para>
   Her bir tick ile oluşturulacak eylem <function>register_tick_function</function>
   fonksiyonu ile belirtilir. Aşağıdaki örneği inceleyerek daha detaylı bilgi
   edilenebilirsiniz. Her bir tick için birden fazla eylem oluşturulabilir.
   </para>
   <para>
    <example>
     <title>PHP kodunun bir bölümünün profili</title>
     <programlisting role="php">
<![CDATA[
<?php
// Çağrıldığında saati kaydeden bir fonksiyon
function profile($dump = FALSE)
{
    static $profile;

    // Profilde saklanmış saati döndürür, sonra siler
    if ($dump) {
        $temp = $profile;
        unset($profile);
        return $temp;
    }

    $profile[] = microtime();
}

// Tick yönlendiricisini kur
register_tick_function("profile");

// Declare bloğundan önce fonksiyonu kur
profile();

// Bir kod bloğu çalıştır, her iki deyimde bir, bir tick çalıştır
declare(ticks=2) {
    for ($x = 1; $x < 50; ++$x) {
        echo similar_text(md5($x), md5($x*$x)), "<br />;";
    }
}

// Profil verisini görüntüle
print_r(profile(TRUE));
?>
]]>
     </programlisting>
    </example>
    Örnekte, 'declare' bloğu içindeki kod incelenerek,
    kaç saniyede bir deyim içerisindeki alt-seviye bir bloğun
    çalıştırıldığı görüntülenmektedir. Bu bilgi daha sonra
    belli bir kod parçacığında yavaşlığa sebep olan bölümlerin
    tespit edilmesi amacıyla kullanılabilir. Bu proses başka
    yöntemler kullanılarak da uygulanabilir: Tick kullanımı
    daha basit ve kullanışlı bir yöntemdir.
   </para>
   <simpara>
   Tickler hata ayıklama, basit çokgörevli uygulamalar geliştirme,
   arkaplanda çalışan I/O (input/output - girdi/çıktı) ve benzeri
   birçok işlem için kullanılabilir.
   </simpara>
   <simpara>
   <function>register_tick_function</function> ve
   <function>unregister_tick_function</function> fonksiyonlarını
   da inceleyin.
   </simpara>
   </sect2>
  </sect1>

  <sect1 xml:id="function.return">
   <title>return</title>
   <simpara>
   Bir fonksiyonun içinden çağrıldığında, <function>return</function>
   deyimi çalışmakta olan fonksiyonu hemen sonlandırır ve kendisine
   ait argümanı fonksiyonun değeri olarak döndürür. <function>return</function>
   aynı zamanda <function>eval</function> fonksiyonu ile çalıştırılan
   bir deyimi ya da betiği de sonlandırır.
   </simpara>
   <simpara>
   Global kapsamda çağrıldığında, mevcut çalışmakta olan betik dosyasının
   çalışması sonlandırılır. Mevcut betik dosyası <function>include</function>
   ya da <function>require</function> ile çağrılmış bir dosya ise, kontrol tekrar
   bu dosyayı çağıran ana dosyaya geçirilir. Dahası, mevcut betik dosyası
   <function>include</function> edilmişse, <function>return</function>
   ile birlikte döndürülen değer <function>include</function> çağrısının
   değeri olarak döndürülecektir. <function>return</function> ana betik
   dosyasının içinden çağrıldığı takdirde, betiğin çalışması sonlandırılacaktır.
   Mevcut betik dosyası &php.ini; içerisindeki <link
    linkend="ini.auto-prepend-file">auto_prepend_file</link> ya da
    <link
    linkend="ini.auto-append-file">auto_append_file</link> yapılandırma
    seçenekleri içinde belirtilmişse, bu betik dosyasının çalışması sonlandırılır.
   </simpara>
   <simpara>Daha fazla bilgi için, <link
   linkend="functions.returning-values">Dönüş değerleri</link> bölümünü
   ziyaret edin.
   </simpara>
   <para>
    <note>
     <simpara>
     <function>return</function> bir fonksiyon değil bir dil yapısı olduğundan,
     argümanlarını çevreleyen parantez <emphasis>yalnızca</emphasis>
     argüman bir ifade içeriyorsa zorunludur. Bir değişken döndürürken genellikle
     parantez kullanılmaz, PHP'de de bu yöntemi izlemeniz gerekir.
     </simpara>
    </note>
    <note>
     <simpara>
     Bir değişkeni referans olarak döndürüyorsanız, <emphasis>asla</emphasis>
     parantez kullanmamalısınız, bu çalışmayacaktır. Bir deyimin sonucunu referans olarak
     döndüremezsiniz, yalnızca değişkenler referans olarak döndürülebilir.
     <literal>return ($a);</literal> kullanıyorsanız, bir değişken döndürmüyor ama bir ifadenin
     sonucunu <literal>($a)</literal> döndürüyorsunuz demektir (bu da elbette, <varname>$a</varname>
     değişkeninin değeridir).
      </simpara>
     </note>
   </para>
  </sect1>


 <sect1 xml:id="function.require">
   <title><function>require</function></title>

   <simpara>
    <function>require</function> deyimi belirtilen dosyayı ekler ve çalıştırır.
   </simpara>
   <simpara>
     <function>require</function> istenen dosyayı ekler ve çalıştırır.
     Ekleme işleminin nasıl gerçekleştiğine dair detaylı bilgilendirme
     <function>include</function> bölümünde anlatılmıştır.
   </simpara>
   <simpara>
     <function>require</function> ve <function>include</function>
     birçok yönden birbirlerinin aynısıdırlar. Farklı oldukları yön, başarısızlık
     durumunda ne yaptıklarıdır. <function>include</function> bir
     <link linkend="errorfunc.constants.errorlevels.e-warning">Uyarı</link> üretirken,
     <function>require</function> bir <link linkend="errorfunc.constants.errorlevels.e-error">
     Ölümcül Hata</link> üretir. Başka bir deyişle, kayıp bir dosyanın tüm işleyişi
     durdurmasını istiyorsanız <function>require</function> fonksiyonunu
     kullanmaktan çekinmeyin. <function>include</function> bu şekilde
     davranmayarak betiğin çalışmaya devam etmesine izin vermektedir.
     <link linkend="ini.include-path">include_path</link> ayarının doğru
     yapıldığından emin olmanız faydalı olacaktır.
   </simpara>
   <para>
    <example>
     <title>Temel <function>require</function> örnekleri</title>
     <programlisting role="php">
<![CDATA[
<?php

require 'prepend.php';

require $somefile;

require ('somefile.txt');

?>
]]>
     </programlisting>
   </example>
   </para>
   <simpara>
    Daha fazla örnek için kılavuzun <function>include</function> bölümüne bakabilirsiniz.
   </simpara>
   <para>
    <note>
     <simpara>
     PHP 4.0.2'den önce, kullanım şu şekildeydi: <function>require</function>
     komutunun bulunduğu satış çalıştırılacak satırlar arasında olmasa bile
     hedef dosyanın okunması mutlaka denenir. 
     Koşula bağlı deyimler <function>require</function> deyimini etkilemeyecektir.
     Ancak, <function>require</function> deyiminin bulunduğu satır çalıştırılmazsa,
     hedef dosya içindeki hiçbir kod çalıştırılmayacaktır.Benzer şekilde,
     döngüsel yapılar <function>require</function> fonksiyonunun bu çalışma
     şeklini değiştirmemektedir. Hedef dosyanın içerisindeki kod halen döngü tarafından
     çalıştırılacak olsa da, <function>require</function> deyiminin kendisi yalnızca
     bir defa çalıştırılır.
     </simpara>
    </note>
   </para>

   &note.language-construct;

   &warn.no-win32-fopen-wrapper;

   <simpara>
   Bakabileceğiniz diğer kaynaklar:
    <function>include</function>, <function>require_once</function>,
    <function>include_once</function>, <function>eval</function>,
    <function>file</function>, <function>readfile</function>,
    <function>virtual</function> ve <link linkend="ini.include-path">include_path</link>.
   </simpara>
  </sect1>

 <sect1 xml:id="function.include">
   <title><function>include</function></title>
   <simpara>
    <function>include</function> deyimi belirtilen dosyayı okur ve işler.
   </simpara>
   <simpara>
   Aşağıdaki dokümantasyon aynı zamanda<function>require</function> için de
   geçerlidir. <function>include</function> ile <function>require</function>
   arasındaki fark, okunacak ve işlenecek dosya bulunamadığında,
   <function>include</function> tarafından <link linkend="errorfunc.constants.errorlevels.e-warning">Uyarı</link>,
   <function>require</function> tarafından <link linkend="errorfunc.constants.errorlevels.e-warning">Ölümcül Hata</link>
   sonucunun üretilmesidir. Başka bir deyişle, okunup işlenmek istenen dosya bulunamıyorsa,
   sayfanın işlenmesini durdurmak için <function>require</function> kullanmanız gerekmektedir.
   <function>include</function> bu şekilde hareket etmez ve betiğin çalışmaya devam etmesine
   izin verir. Bu deyimi kullanmadan önce <link linkend="ini.include-path">include_path</link>
   ayarınızın doğru olduğundan emin olun. PHP 4.3.5'den önceki sürümlerde, include edilen dosyadaki
   okuma hatası uygulamanın çalışmasını durdurmuyordu. Bu sürümden itibaren, uygulamanın
   çalışması durdurulmaktadır.
   </simpara>
   <simpara>
   Include edilecek dosyalar için öncelikle include_path direktifinin mevcut çalışma klasörüne göreceli
   konumuna bakılır, istenen dosya bulunamazsa mevcut betiğin bulunduğu klasöre göreceli konumda
   dosya aranır. Örneğin, include_path direktifinizin değeri <literal>.</literal>, mevcut çalışma klasörü
   <filename class="directory">/www/</filename>, <filename>include/a.php</filename> include
   edilmiş ve bu dosyanın içinde <literal>include "b.php"</literal> komutu var ise, <filename>b.php</filename>
   dosyası için önce <filename class="directory">/www/</filename> klasörüne bakılır ve ardından
   <filename class="directory">/www/include/</filename> klasörü taranır. Dosya ismi <literal>./</literal>
   ile ya da <literal>../</literal> ile başlıyorsa, dosya yalnızca mevcut çalışma klasörüne göreceli include_path
   içersinde aranır.
   </simpara>
   <simpara>
   Bir dosya include edildiğinde, bu dosyanın içerdiği kod include deyiminin
   kullanıldığı satır itibariyle geçerli olan
   <link linkend="language.variables.scope">değişken kapsamını</link>
   miras alır. Include komutunun çalıştırıldığı satıra kadar olan tüm değişkenler,
   include edilen dosyada da kullanılabilir olacaktır.
   </simpara>
   <para>
     <example>
      <title>Temel <function>include</function> örneği</title>
      <programlisting role="php">
<![CDATA[
vars.php
<?php

$renk = 'yeşil';
$meyve = 'elma';

?>

test.php
<?php

echo "Bir $color $fruit"; // A

include 'vars.php';

echo "Bir $color $fruit"; // Bir yeşil elma

?>
]]>
      </programlisting>
     </example>
   </para>
   <simpara>
   Include deyimi, deyimin kullanıldığı dosya içindeki bir fonksiyonda
   kullanılırsa, include edilen dosyanın içindeki tüm kodlar sanki o fonksiyon
   içinde tanımlanmış gibi çalıştırılacaktır. Özetle, fonksiyonun değişken
   kapsamına dahil olacaklardır.
   </simpara>
   <para>
     <example>
     <title>Fonksiyon içi Include kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php

function foo()
{
    global $renk;

    include 'vars.php';

    echo 'Bir $color $fruit';
}

/* vars.php foo() fonksiyonunun kapsamı
 * içindedir, dolayısıyla $fruit bu kapsamın
 * dışında kullanılamamaktadır. $color
 * kullanılabilir çünkü global olarak tanımlanmıştır
 
foo();                    // Bir yeşil elma
echo 'Bir $color $fruit';   // A green

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
   Bir dosya include edildiğinde, PHP kipinden çıkılır ve HTML kipine
   geçilir. Bu sebeple hedef dosyada çalıştırılmak istenen PHP kodu varsa
   <link linkend="language.basic-syntax.phpmode">
   geçerli bir PHP başlangıç ve sonlandırma etiketi</link> arasına
   konması gereklidir. Include edilen dosya sonlandığında, okuyucu
   tekrar HTML kipinden PHP kipine geçmektedir.
   </simpara>
   <simpara>
   "<link linkend="ini.allow-url-fopen">URL fopen wrappers</link>"
   PHP'de etkinleştirilmiş ise (öntanımlı yapılandırmada etkindirler),
   yerel dosya yolu belirtmek yerine
   URL (HTTP ya da desteklenen başka bir protokol üzerinden - 
   protokol listesi için <xref linkend="wrappers"/> bölümünü inceleyin)
   kullanarak include işlemini gerçekleştirebilirsiniz. Hedef sunucu
   hedef dosyayı PHP kodu olarak çalıştırabiliyorsa, değişkenler include
   edilen dosyaya bir URL karakter dizisi olarak HTTP GET ile aktarılabilir.
   Bu durum dosyayı include edip ana dosyanın değişken kapsamını miras
   almaktan çok farklı değildir; betik gerçekte uzaktaki sunucuda çalışmakta
   ve sonuçları yereldeki betiğe include edilmektedir.
      </simpara>
   &warn.no-win32-fopen-wrapper;
   <para>
    <example>
     <title>HTTP üzerinden <function>include</function></title>
     <programlisting role="php">
<![CDATA[
<?php

/* Bu örnek www.example.com sitesinin .php uzantılı dosyaları çalıştırabildiğini
 * ve .txt uzantılıları çalıştırmadığını kabul eder. Ayrıca, 'Çalışır' ifadesi burada 
 * $foo ve $bar değişkenlerinin include edilen dosyada kullanılabilir olup
 * olmadığını ifade eder. */

// Çalışmaz; file.txt dosyası www.example.com sitesinde PHP tarafından işlenmez
include 'http://www.example.com/file.txt?foo=1&bar=2';

// Çalışmaz; yerel dosya sisteminde 'file.php?foo=1&bar=2' isminde bir dosya arar
include 'file.php?foo=1&bar=2';

// Çalışır.
include 'http://www.example.com/file.php?foo=1&bar=2';

$foo = 1;
$bar = 2;
include 'file.txt';  // Çalışır.
include 'file.php';  // Çalışır.

?>
]]>
     </programlisting>
    </example>
   </para>
   <warning>
    <title>Güvenlik uyarısı</title>
    <para>
    Uzaktaki dosya uzaktaki sunucu tarafından işlenebilir (dosyanın uzantısına
    ve uzaktaki sunucunun PHP çalıştırıp çalıştırmadığına bağlı olarak).
    Ancak bu işlemenin sonucu yine mutlaka geçerli bir PHP betiği olmalıdır
    çünkü elde edilen çıktı yine yerel sunucu tarafından işlenecektir. Dosyanın
    uzaktaki sunucuda işlenmesini ve işlemlerin o sunucu üzerinde kalmasını
    istiyorsanız, <function>readfile</function> daha iyi bir seçim olacaktır.
    Aksi takdirde, uzakta çalıştırılan betiğin geçerli ve istenen kodu üretebilmesini
    güvence altına alabilmek için özel çaba harcamak gerekir.
    </para>
   </warning>
   <para>
   Ayrıca bakın <link linkend="features.remote-files">Uzaktaki dosyalar</link>,
    <function>fopen</function> ve <function>file</function>.
   </para>
   <para>
   <function>include</function> ve <function>require</function> özel
   dil yapıları olduklarından, koşula bağlı bir blok içinde kullandığınızda bu deyimleri
   deyim bloğu parantezleri ile kapatmanız gerekmektedir.
   </para>
   <para>
    <example>
     <title>include() ve koşula bağlı bloklar</title>
     <programlisting role="php">
<![CDATA[
<?php

// Bu YANLIÞTIR ve istenildiği gibi çalışmayacaktır.
if ($kosul)
    include $file;
else
    include $other;


// Bu DOÐRUDUR.
if ($kosul) {
    include $file;
} else {
    include $other;
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
   Return kullanımı: Include edilmiş bir dosyanın içersinde, bu dosyanın işlenmesi
   durdurmak ve include eden betiğe geri dönmek için <function>return</function>
   fonksiyonu kullanılabilir. Ayrıca, include edilen dosyalardan değer döndürmek
   de mümkündür. Normal fonksiyonda olduğu gibi, include çağrısından elde edilen
   değeri bir değişkene atayabilirsiniz. Ancak bu durum, uzaktaki dosyalar için
   tek bir koşul dışında mümkün değildir: Uzaktaki dosyanın çıktısı
   <link linkend="language.basic-syntax.phpmode">geçerli PHP başlangıç
   ve sonlandırma etiketlerine</link> sahipse (herhangi yerel bir dosyada olduğu
   gibi), bu özellik uzaktaki dosyalar için de kullanılabilir. Gerekli değişkenleri
   bu etiketlerin arasında tanımlayabilirsiniz, bu şekilde dosyanın include edildiği
   andan itibaren kullanılabilir olacaklardır.
   </simpara>
   <para>
    <function>include</function> özel bir dil yapısı olduğundan,
    bu argümanın etrafında parantez bulunmasına gerek yoktur. Dönen değerle
    ilgili bir karşılaştırma yaparken dikkatli olmalısınız.
    <example>
     <title>Include işleminden dönen değerin karşılaştırılması</title>
     <programlisting role="php">
<![CDATA[
<?php
// Çalışmaz, include(('vars.php') == 'TAMAM') olarak değerlendirilir, örn. include('')
if (include('vars.php') == 'TAMAM') {
    echo 'TAMAM';
}

// Çalışır
if ((include 'vars.php') == 'TAMAM') {
    echo 'TAMAM';
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <note>
     <simpara>
     PHP 3 sürümünde, sözkonusu blok bir fonksiyon bloğu olmadığı sürece
     return deyiminin blok içinde kullanılması gerekli değildir, bu durumda
     <function>return</function> yalnızca ilgili fonksiyona uygulanır ve
     dosyanın tümüne uygulanmaz.
     </simpara>
    </note>
   </para>
   <para>
    <example>
     <title><function>include</function> ve <function>return</function> deyimleri</title>
      <programlisting role="php">
<![CDATA[
return.php
<?php

$var = 'PHP';

return $var;

?>

noreturn.php
<?php

$var = 'PHP';

?>

testreturns.php
<?php

$foo = include 'return.php';

echo $foo; // 'PHP' yazdırır

$bar = include 'noreturn.php';

echo $bar; // 1 yazdırır

?>
]]>
      </programlisting>
    </example>
   </para>
   <simpara>
    <literal>$bar</literal>, <literal>1</literal> değerini taşıyor çünkü
    include işlemi başarıyla sonuçlandı. Yukarıdaki örnekler arasındaki farklara
    dikkat edin. Birincisi <function>return</function> deyimini include
    edilen dosyada kullanırken ikincisi kullanmıyor. Dosya include edilemediği durumda,
    &false; döndürülüyor ve <literal>E_WARNING</literal> üretiliyor.
   </simpara>
   <para>
   Include edilen dosyanın içinde tanımlanmış fonksiyonlar varsa, 
   <function>return</function>'den önce ya da sonra olduğundan bağımsız olarak
   ana dosya içersinde kullanılabilirler. Dosya iki defa include edilmişse, PHP 5
   ölümcül hata üretir çünkü fonksiyonlar halihazırda deklare edilmiştir, PHP 4 ise
   <function>return</function>'den sonra tanımlanmış fonksiyonlar için
   şikayet etmeyecektir. Dosyanın halihazırda include edilip edilmediğini kendiniz
   tespit edip koşula bağlı return çalıştırmak yerine, <function>include_once</function>
   fonksiyonunu kullanmanız önerilir.
   </para>
   <simpara>
   Bir PHP dosyasını bir değişkene "include" etmenin diğer bir yolu, çıktıyı
   <link linkend="ref.outcontrol">Çıktı Kontol Fonksiyonları</link>
   ile yakalamak ve <function>include</function> ile birlikte kullanmaktır.
   Örneğin:
   </simpara>
   <para>
    <example>
     <title>Include ve Çıktı Tamponlama Kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
$string = get_include_contents('somefile.php');

function get_include_contents($filename) {
    if (is_file($filename)) {
        ob_start();
        include $filename;
        $contents = ob_get_contents();
        ob_end_clean();
        return $contents;
    }
    return false;
}

?>
]]>
      </programlisting>
    </example>
   </para>
   <para>
   Uygulamanızda dosyaları otomatik include etmek için,
    <link linkend="ini.auto-prepend-file">auto_prepend_file</link> ve
    <link linkend="ini.auto-append-file">auto_append_file</link>
    &php.ini; içersindeki yapılandırma seçeneklerini inceleyebilirsiniz.
   </para>

   &note.language-construct;

   <simpara>
    Ayrıca bakın <function>require</function>, <function>require_once</function>,
    <function>include_once</function>, <function>readfile</function>,
    <function>virtual</function>, ve
    <link linkend="ini.include-path">include_path</link>.
   </simpara>
 </sect1>

 <sect1 xml:id="function.require-once">
   <title><function>require_once</function></title>
   <para>
    <function>require_once</function> deyimi belirtilen dosyayı betiğin çalışması
    esnasında okur ve çalıştırır. Bu deyimin çalışma biçimi
    <function>require</function> deyimi ile benzerdir,tek fark ilgili dosya içerisindeki
    kod tekrar include edilmek isteniyorsa, tekrar include etme işleminin yapılmamasıdır.
    Daha fazla bilgi için <function>require</function> dokümantasyonuna bakabilirsiniz.
   </para>
   <para>
    <function>require_once</function> deyimi, bir betiğin çalışması esnasında aynı
    dosyanın birden fazla defa include edilme ihtimaline karşılık, bu dosyanın yalnızca
    bir defa include edileceğinden emin olmak istediğinizde kullanılmalıdır. Bu sayede
    fonksiyonların yeniden tanımlanmaya çalışılması, değişkenlere tekrar değer atanması
    gibi sorunlardan korunmuş olursunuz.
   </para>
   <para>
    <function>require_once</function> ve
     <function>include_once</function> ile ilgili örnekler için, PHP'nin en son
     kaynak kodu dağıtımında yer alan
     <link xlink:href="&url.php.pear;">PEAR</link> kodlarını inceleyebilirsiniz.
   </para>
   <para>
   Dönen değerlerin yönetimi <function>include</function> fonksiyonu ile aynıdır.
   Dosya halihazırda include edilmişse, bu fonksiyon &true; değerini döndürür.
   </para>
   <para>
    <note>
     <para>
      <function>require_once</function> PHP 4.0.1pl2 ile eklenmiştir.
     </para>
    </note>
   </para>
   <para>
    <note>
     <para>
     Büyük-küçük harf duyarlı olmayan işletim sistemlerinde (Windows gibi),
     <function>require_once</function> ve <function>include_once</function>
     deyimlerinin beklediğiniz sonucu üretmeyebileceğine dikkat edin.
      <example>
       <title><function>require_once</function> Windows'ta büyük-küçük harf duyarsızdır</title>
       <programlisting role="php">
<![CDATA[
<?php
require_once("a.php"); // bu a.php dosyasını include edecektir
require_once("A.php"); // bu Windows altında yine a.php dosyasını include edecektir! (yalnızca PHP 4)
?>
]]>
        </programlisting>
      </example>
      Bu davranış PHP 5'te değişmiştir - öncelikle yol normalize edilir, böylece
      <filename>C:\PROGRA~1\A.php</filename> ile <filename>C:\Program Files\a.php</filename>
      aynı kapsamda değerlendirilir ve dosya yalnızca bir defa işlenir.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Ayrıca bakın <function>require</function>,
    <function>include</function>, <function>include_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>, ve
    <function>virtual</function>.
   </para>
  </sect1>

 <sect1 xml:id="function.include-once">
   <title><function>include_once</function></title>
   <para>
    <function>include_once</function> betiğin çalışması esnasında belirtilen
    dosyayı okur ve işler.
    Bu çalışma biçimi <function>include</function> deyimi ile benzerdir,
    tek fark dosyanın içindeki kod halihazırda include edilmişse, include işlemi
    tekrarlanmaz. İsimden de anlaşılabileceği gibi, dosya yalnızca bir defa
    include edilir.
   </para>
   <para>
    <function>include_once</function> deyimi, bir betiğin çalışması esnasında aynı
    dosyanın birden fazla defa include edilme ihtimaline karşılık, bu dosyanın yalnızca
    bir defa include edileceğinden emin olmak istediğinizde kullanılmalıdır. Bu sayede
    fonksiyonların yeniden tanımlanmaya çalışılması, değişkenlere tekrar değer atanması
    gibi sorunlardan korunmuş olursunuz.
   </para>
   <para>
   <function>require_once</function> ve <function>include_once</function>
   kullanımı ile ilgili daha fazla örnek için, PHP'nin en son
     kaynak kodu dağıtımında yer alan
     <link xlink:href="&url.php.pear;">PEAR</link> kodlarını inceleyebilirsiniz.
   </para>
   <para>
   Dönen değerlerin yönetimi <function>include</function> fonksiyonu ile aynıdır.
   Dosya halihazırda include edilmişse, bu fonksiyon &true; değerini döndürür.
   </para>
   <para>
    <note>
     <para>
      <function>include_once</function> PHP 4.0.1pl2 sürümü ile eklenmiştir.
     </para>
    </note>
   </para>
   <para>
   <note>
     <para>
     Büyük-küçük harf duyarlı olmayan işletim sistemlerinde (Windows gibi),
     <function>require_once</function> ve <function>include_once</function>
     deyimlerinin beklediğiniz sonucu üretmeyebileceğine dikkat edin.
      <example>
       <title><function>include_once</function> Windows'ta büyük-küçük harf duyarsızdır</title>
       <programlisting role="php">
<![CDATA[
<?php
include_once("a.php"); // bu a.php dosyasını include edecektir
include_once("A.php"); // bu Windows altında yine a.php dosyasını include edecektir! (yalnızca PHP 4)
?>
]]>
        </programlisting>
      </example>
      Bu davranış PHP 5'te değişmiştir - öncelikle yol normalize edilir, böylece
      <filename>C:\PROGRA~1\A.php</filename> ile <filename>C:\Program Files\a.php</filename>
      aynı kapsamda değerlendirilir ve dosya yalnızca bir defa işlenir.
     </para>
    </note>
   </para>
   &warn.no-win32-fopen-wrapper;
   <para>
    Ayrıca bakın <function>include</function>,
    <function>require</function>, <function>require_once</function>,
    <function>get_required_files</function>,
    <function>get_included_files</function>, <function>readfile</function>,
    ve <function>virtual</function>.
   </para>
  </sect1>
  
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
