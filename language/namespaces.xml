<?xml version="1.0" encoding="UTF-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 283798 Maintainer: nilgun Status: ready -->
<chapter xml:id="language.namespaces" xmlns="http://docbook.org/ns/docbook"
 version="1.1">
 <title>İsim Alanları</title>

 <sect1 xml:id="language.namespaces.rationale">
  <title>Giriş</title>
  <simpara>
   İsim alanı nedir? En dar tanımıyla, öğeleri sarmalamanın bir yoludur.
   Çoğu bakımdan bu soyut bir kavram gibi görünebilir. Örneğin, bir işletim
   sisteminin dizinleri bir birleriyle ilgili dosyaları gruplamaya yarar ve
   içerdiği dosyalar için bir isim alanı görevi yapar. Daha belirgin bir
   örnek olarak, <literal>/home/ali</literal> ve <literal>/home/veli</literal>
   dizinlerinde <literal>mesela.txt</literal>  adında birer dosya bulunduğunu
   varsayalım. <literal>/home/ali</literal> dizinindeki dosyaya dizin dışından
   erişmek istersek dosyanın önüne dizin ayracı ile dizin adını
   yerleştiririz. Programcılık dünyasındaki isim alanlarına da aynı kurallar
   uygulanır.
  </simpara>
  <simpara>
    PHP dünyasında isim alanları, kütüphane ve uygulama yazarlarının
    aşağıdaki gibi sınıflar ve işlevler gibi yeniden kullanılabilir
    elemanları oluşturken karşılaştıkları iki soruna çözüm getirmek amacıyla
    tasarlanmıştır:
  </simpara>
  <para>
   <orderedlist>
    <listitem>
     <simpara>
      Yazdığınız kod ile yerleşik PHP sınıfları/işlevleri/sabitleri veya
      üçüncü şahısların sınıfları/işlevleri/sabitleri arasındaki isim
      çakışmaları.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      İlk sorunu hafifletmek ve kaynak kodun okunabilirliğini arttırmak için
      epeyce_uzun_isimlere takma ad tanımlama (veya kısaltma) yeteneği.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <simpara>
   PHP isim alanları birbirleriyle ilişkili sınıflar, sabitler ve işlevleri
   gruplamak için bir yol sunar. PHP'deki isim alanı söz dizimi için bir
   örnek:
  </simpara><example>
     <title>- İsim alanı söz dizimi örneği</title>
     <programlisting role="php">
     <![CDATA[
<?php
namespace isim\alanım; // "İsim Alanlarının Tanımlanması" bölümüne bakınız

class Sınıfım {}
function işlevim() {}
const SABİTİM = 1;

$a = new Sınıfım;
$c = new \isim\alanım\Sınıfım; // "Küresel Etki Alanı" bölümüne bakınız

$a = strlen('selam'); // "İsim alanlarının kullanımı: Son çare olarak
                      // küresel işlev ve sabitler" bölümüne bakınız

$d = \isim\alanım\SABİTİM;        // isim alanı işleci ve __NAMESPACE__
$d = __NAMESPACE__ . '\SABİTİM';  // sabiti" bölümüne bakınız
echo constant($d); // "İsim alanları ve devingen dil özellikleri"
                   // bölümüne bakınız
?>
]]>
    </programlisting>
  </example>
  <simpara>
   İsim alanları PHP 5.3.0 sürümünden beri mevcuttur.
  </simpara>
 </sect1>

 <sect1 xml:id="language.namespaces.definition">
  <title>İsim Alanlarının Tanımlanması</title>
  <para>
   İsim alanları içinde her çeşit PHP kodu bulunabilirse de sadece üç tür
   kod isim alanlarından etkilenir: Sınıflar, işlevler ve sabitler.
  </para>
  <para>
    İsim alanları, <literal>namespace</literal> anahtar sözcüğü ile
    bildirilirler. Bir isim alanını içeren bir dosyada isim alanı bütün
    diğer kodlardan önce (ama bir
    <xref linkend="control-structures.declare" /> satırından önce değil)
    dosyanın başlarında bildirilmelidir.
   <example>
    <title>- Tek bir isim alanı bildirimi</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem;

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   Bir isim alanı bildiriminden önce bulunmasına izin verilen tek oluşum,
   kaynak dosyanın kodlamasının tanımlandığı <literal>declare</literal> deyimidir.
   Bunun dışında, baştaki fazladan boşluklar da dahil hiçbir PHP-dışı kod,
   bir isim alanı bildiriminden önce yer alamaz. Örnek:
   <example>
    <title>- Tek bir isim alanı bildirimi</title>
    <programlisting role="php">
     <![CDATA[
<html>
<?php
namespace Sınıfım; // ölümcül hata - namespace, betikteki ilk deyim olmalıdır
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
    Diğer tüm PHP oluşumlarının tersine, isim alanının dosya sistemi içinde
    parçalara bölünebilmesi için aynı isim alanı birden fazla dosyada
    tanımlanabilir.
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.nested">
  <title>Alt İsim Alanlarının Bildirilmesi</title>
  <para>
    Dizinler ve dosyalardaki gibi PHP isim alanı isimleri arasında da bir
    hiyeraraşi belirtmek mümkündür. Bu bakımdan, bir isim alanı başka isim
    alanlarının altında tanımlanabilir:
   <example>
    <title>- Tek bir isim alanının hiyerarşik bildirimi</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem\Alt\Seviye;

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }

?>
]]>
    </programlisting>
   </example>
   Yukarıdaki örnekte, <literal>Projem\Alt\Seviye\BAĞLANTI_TAMAM</literal> sabiti,
   <literal>Projem\Alt\Seviye\Bağlantı</literal> sınıfı ve
   <literal>Projem\Alt\Seviye\bağlan</literal> işlevi oluşturulmaktadır.
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.definitionmultiple">
  <title>Birden Fazla İsim Alanının Aynı Dosyada Tanımlanması</title>
  <para>
    Birden fazla isim alanı aynı dosya içinde bildirilebilir. İki çeşit söz
    dizimine izin verilir.
  </para>
  <para>
   <example>
    <title>- Birden fazla isim alanın ayrımsız ardarda bildirilmesi</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem;

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }

namespace DiğerProjem;

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Bu söz dizimi aynı dosya içinde birden fazla isim alanı bildirimi için
   önerilmez. Bunun yerine ayraçlı söz dizimi önerilir.
  </para>
  <para>
   <example>
    <title>- Birden fazla isim alanın ayraçlı olarak bildirilmesi</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem {

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }
}

namespace DiğerProjem {

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Aynı dosya içinde birden fazla isim alanını birleştirmek iyi bir kodlama
   uygulaması olarak teşvik edilmektedir. Çoğunlukla çok sayıda PHP betiğini
   aynı dosyada birleştirmek amacıyla kullanılır.
  </para>
  <para>
   İsim alansız küresel kodu isim alanlı kodla bir arada kullanmanın tek
   yolu ayraçlı söz dizimini kullanmaktır (diğerine izin verilmemektedir).
   Küresel kod isimsiz bir isim alanı bildirimi ile aynı dosyada şöyle
   bildirilebilir:
   <example>
    <title>- Birden fazla isim alanın isim alansız kodla birlikte
      bildirilmesi</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem {

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }
}

namespace { // küresel kod
session_start();
$a = Projem\bağlan();
echo Projem\Bağlantı::başlat();
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   İsim alanı ayraçlarının dışında, kodlama belirten <code>declare</code>
   deyimi dışında hiçbir PHP kodu bulunamaz.
   <example>
    <title>- Birden fazla isim alanın isim alansız kodla birlikte
      bildirilmesi</title>
    <programlisting role="php">
     <![CDATA[
<?php
declare(encoding='UTF-8');
namespace Projem {

const BAĞLANTI_TAMAM = 1;
class Bağlantı { /* ... */ }
function bağlan() { /* ... */  }
}

namespace { // küresel kod
session_start();
$a = Projem\bağlan();
echo Projem\Bağlantı::başlat();
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.basics">
  <title>İsim alanlarının kullanımı: Temeller</title>
  <para>
   İsim alanlarının kullanımından önce PHP'nin kodunuzdaki hangi isim alanlı
   kodu isteğinizi nasıl anlayabildiğinden bahsetmek gerekir. Bunu daha
   kolay anlayabilmek için PHP isim alanları ile dosya sistemleri arasındaki
   benzerlikten yola çıkılabilir. Bir dosya sistemindeki bir dosyaya üç
   yolla erişilebilir:
   <orderedlist>
    <listitem>
     <simpara>
      <literal>fan.txt</literal> şeklinde göreli dosya ismiyle.  Bu isim dosya
      sisteminde içinde bulunulan dizin  <code>geçerlidizin/</code> olmak
      üzere <literal>geçerlidizin/fan.txt</literal> olarak çözümlenir. Dolayısıyla
      geçerli dizin <literal>/home/veli</literal> ise dosya ismi
      <literal>/home/veli/fan.txt</literal> olarak çözümlenecektir.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>altdizin/fan.txt</literal> şeklinde göreli dosya yolu. Bu isim
      dosya sisteminde içinde bulunulan dizin  <code>geçerlidizin/</code>
      olmak üzere <literal>geçerlidizin/altdizin/fan.txt</literal> olarak
      çözümlenir.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>/home/veli/fan.txt</literal> şeklinde mutlak dosya yolu. Bu,
      <literal>/home/veli/fan.txt</literal> olarak çözümlenir.
     </simpara>
    </listitem>
   </orderedlist>
   Aynı kurallar PHP'deki isim alanlı elemanlara da uygulanabilir. Örneğin
   bir sınıf ismine üç şekilde başvurulabilir:
   <orderedlist>
    <listitem>
     <simpara>
      <literal>$a = new fan();</literal> veya
      <literal>fan::durukyöntem();</literal> gibi bir nitelenmemiş isim veya
      öneksiz bir sınıf ismi.  Eğer geçerli isim alanı ismi
      <literal>geçerlisimalanı</literal> ise bu isim,
      <literal>geçerlisimalanı\fan</literal> olarak çözümlenir. Eğer kod küresel
      ve isim alansız ise, isim <literal>fan</literal> olarak çözümlenecektir.
     </simpara>
     <simpara>
      Bir ayrıntı: Eğer isim alanlı işlev ve sabitler tanımlı ise
      nitelenmemiş isimli işlevler ve sabitler küresel işlevler ve sabitler
      olarak çözümlenir. Ayrıntılar için <link
      linkend="language.namespaces.fallback">İsim alanlarının kullanımı: Son
      çare olarak küresel işlev ve sabitler</link> bölümüne bakınız.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>$a = new altisimalanı\fan();</literal> veya
      <literal>altisimalanı\fan::durukyöntem();</literal> gibi bir nitelenmemiş
      isim veya öneksiz bir sınıf ismi. Eğer geçerli isim alanı ismi
      <literal>geçerlisimalanı</literal> ise bu isim,
      <literal>geçerlisimalanı\altisimalanı\fan</literal> olarak çözümlenir. Eğer
      kod küresel ve isim alansız ise, isim <literal>altisimalanı\fan</literal>
      olarak çözümlenecektir.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal>$a = new \geçerlisimalanı\fan();</literal> veya
      <literal>\geçerlisimalanı\fan::durukyöntem();</literal> gibi tamamen
      nitelenmiş isim veya küresel önekli bir isim. Bu isim daima kodda
      belirtildiği gibi <literal>geçerlisimalanı\fan</literal> olarak çözümlenir.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   Üç söz dizimi aşağıda örneklenmiştir:
   <informalexample>
    <simpara>dosya1.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Fan\Fin\altisimalanı;

const FAN = 1;
function fan() {}
class fan
{
    static function durukyöntem() {}
}
?>
     ]]>
    </programlisting>
    <simpara>dosya2.php</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Fan\Fin;
include 'dosya1.php';

const FAN = 2;
function fan() {}
class fan
{
    static function durukyöntem() {}
}

/* Nitelenmemiş isim */
fan();              // Fan\Fin\fan işlevine çözümlenir
fan::durukyöntem(); // Fan\Fin\fan sınıfının durukyöntem yöntemine çözümlenir
echo FAN;           // Fan\Fin\FAN sabitine çözümlenir

/* Nitelenmiş isim */
altisimalanı\fan(); // Fan\Fin\altisimalanı\fan işlevine çözümlenir
altisimalanı\fan::durukyöntem(); // Fan\Fin\altisimalanı\fan sınıfının
                                 // durukyöntem yöntemine çözümlenir
echo altisimalanı\FAN; // Fan\Fin\altisimalanı\FAN sabitine çözümlenir

/* Tamamen nitelenmiş isim */
\Fan\Fin\fan();              // Fan\Fin\fan işlevine,
\Fan\Fin\fan::durukyöntem(); // Fan\Fin\fan sınıfının durukyöntem yöntemine,
echo \Fan\Fin\FAN;           // Fan\Fin\FAN sabitine çözümlenir
?>
     ]]>
    </programlisting>
   </informalexample>
  </para>
  <para>
   Herhangi bir küresel sınıf, işlev veya sabite
   <function>\strlen</function>, <classname>\Exception</classname> veya
   <literal>\INI_ALL</literal> gibi tamamen nitelenmiş isimleriyle
   erişilebileceğine dikkat ediniz.
   <example>
    <title>- Küresel sınıf, işlev ve sabitlere bir isim alanı içinden erişim
    </title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Fan;

function strlen() {}
const INI_ALL = 3;
class Exception {}

$a = \strlen('merhaba');      // strlen küresel işlevini çağırır
$b = \INI_ALL;                // INI_ALL küresel sabitini çağırır
$c = new \Exception('error'); // Exception küresel sınıfını örnekler
?>
     ]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.dynamic">
  <title>İsim alanları ve devingen dil özellikleri</title>
  <para>
   PHP'nin isim alanları gerçeklenimi bir programlama dili olarak PHP'nin
   kendi devingen doğasından etkilenir. Örnek olarak aşağıdaki kodu isim
   alanlı koda dönüştürmek istersek:
   <example>
    <title>- Devingen olarak erişilen elemanlar</title>
    <simpara>örnek1.php:</simpara>
    <programlisting role="php">
     <![CDATA[
<?php
class sınıfadı
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function işlevadı()
{
    echo __FUNCTION__,"\n";
}
const sabitadı = "küresel";

$a = 'sınıfadı';
$obj = new $a;                   // sınıfadı::__construct basar
$b = 'işlevadı';
$b();                            // işlevadı basar
echo constant('sabitadı'), "\n"; // küresel basar
?>
    ]]>
    </programlisting>
   </example>
   Tamamen nitelenmiş isim kullanmak gerekir (isim alanı önekli sınıf adı).
   Bir devingen sınıf, işlev veya sabit ismi içinde bir nitelenmiş isim ile
   tamamen nitelenmiş isim arasında bir fark olmadığından baştaki ters
   bölünün gereksiz oluşuna dikkat edin.
   <example>
    <title>- Devingen olarak erişilen isim alanlı elemanlar</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace isimalanıadı;
class sınıfadı
{
    function __construct()
    {
        echo __METHOD__,"\n";
    }
}
function işlevadı()
{
    echo __FUNCTION__,"\n";
}
const sabitadı = "isimalanlı";

include 'örnek1.php';

$a = 'sınıfadı';
$obj = new $a;                    // sınıfadı::__construct basar
$b = 'işlevadı';
$b(); // prints funcname
echo constant('sabitadı'), "\n"; // küresel basar

/* çift tırnakları kullanacaksanız, "\\isimalanıadı\\sınıfadı"
   biçiminde olmalıdır */
$a = '\isimalanıadı\sınıfadı';
$obj = new $a; // isimalanıadı\sınıfadı::__construct basar
$a = 'isimalanıadı\sınıfadı';
$obj = new $a; // bu da isimalanıadı\sınıfadı::__construct basar
$b = 'isimalanıadı\işlevadı';
$b(); // isimalanıadı\işlevadı basar
$b = '\isimalanıadı\işlevadı';
$b(); //bu da isimalanıadı\işlevadı basan
echo constant('\isimalanıadı\sabitadı'), "\n"; // isimalanlı basar
echo constant('isimalanıadı\sabitadı'), "\n"; // bu da isimalanlı basar
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   SSS arasındaki <link linkend="language.namespaces.faq.quote">Dizgelerdeki
   isim alanı adlarının öncelenmesi</link>  konusuna da bakmayı unutmayın.
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.nsconstants">
  <title><code>namespace</code> sözcüğü ve <code>__NAMESPACE__</code> sabiti
  </title>
  <para>
   PHP, geçerli isim alanı içindeki elemanlara mutlak olarak iki yolla
   erişimi destekler: sihirli <constant>__NAMESPACE__</constant> sabiti ve
   <literal>namespace</literal> anahtar sözcüğü.
  </para>
  <para>
   <constant>__NAMESPACE__</constant> sabitinin değeri içinde bulunulan isim
   alanının adını içeren bir dizgedir. Küresel alandaki isim alansız kod
   için sabitin değeri boş dizgedir.
   <example>
    <title>- İsim alanlı kod, __NAMESPACE__ örneği</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem;

echo '"', __NAMESPACE__, '"'; // "Projem" basar
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>- Küresel kod, __NAMESPACE__ örneği</title>
    <programlisting role="php">
     <![CDATA[
<?php

echo '"', __NAMESPACE__, '"'; // "" basar
?>
]]>
    </programlisting>
   </example>
   <constant>__NAMESPACE__</constant> sabiti devingen olarak oluşturulan
   isimler için kullanışlıdır.
   <example>
    <title>- Devingen isim oluşturmak için __NAMESPACE__ kullanımı</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem;

function get($sınıfadı)
{
    $a = __NAMESPACE__ . '\\' . $sınıfadı;
    return new $a;
}
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   <literal>namespace</literal> sözcüğü, geçerli isim alanından veya bir alt isim
   alanından doğrudan doğruya bir eleman isteği yaparken kullanılabilir.
   Sınıflardaki <literal>self</literal> işlecinin isim alanlarındaki karşılığıdır.
   <example>
    <title>- Bir isim alanı içinde <code>namespace</code> işleci</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace Projem;

use fan\fin as fon;  // "İsim alanlarının kullanımı: ithal/rumuz"

fin\fon();           // Projem\fin\fon() işlevini çağırır
namespace\fin\fon(); // Projem\fin\fon() işlevini çağırır

namespace\işlev();   // Projem\işlev() işlevini çağırır
namespace\alt\işlev();    // Projem\alt\işlev() işlevini çağırır
namespace\isim::yöntem(); // Projem\isim sınıfının duruk "yöntem"
                          // yöntemini çağırır
$a = new namespace\alt\isim(); // Projem\alt\isim sınıfını örnekler
$b = namespace\SABİT;     // Projem\SABİT sabitinin değerini $b'ye atar
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>- Küresel kod içinde <code>namespace</code> işleci</title>
    <programlisting role="php">
     <![CDATA[
<?php

namespace\işlev();        // işlev() işlevini çağırır
namespace\alt\işlev();    // alt\işlev() işlevini çağırır
namespace\isim::yöntem(); // isim sınıfının duruk "yöntem" yöntemini çağırır
$a = new namespace\alt\isim(); // alt\isim sınıfını örnekler
$b = namespace\SABİT;     // SABİT sabitinin değerini $b'ye atar
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.importing">
  <title>İsim alanlarının kullanımı: İthal/Rumuz</title>
  <para>
    Dış kaynaklı tamamen nitelenmiş bir isme bir takma adla veya ithal
    ederek başvurma yeteneği isim alanlarının önemli bir özelliğidir. Bu
    özellik, Unix dosya sistemlerinin bir dizin veya dosyaya bir sembolik
    bağ oluşturma yeteneğine benzer.
  </para>
  <para>
   PHP isim alanları iki çeşit takma ad kullanımını veya ithalini destekler:
   bir sınıf adına takma ad ve bir isim alanı adına takma ad. Bir işlevin
   veya sabitin ithalinin desteklenmediğine dikkat ediniz.
  </para>
  <para>
   PHP'da takma ad kullanımı <code>use</code> işleci üzerinden sağlanır.
   Aşağıda 3 çeşit ithal örneğine yer verilmiştir:
   <example>
    <title>- <code>use</code> işleci ile ithal/rumuz kullanımı</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace fan;
use Bir\Tam\Sınıfadı as BirBaşkası;

// use Bir\Tam\iAadı as iAadı ile aynıdır
use Bir\Tam\iAadı;

// küresel bir sınıfın ithali
use \DiziNesnesi;

$nesne = new namespace\BirBaşkası; // fan\BirBaşkası sınıfını örnekler
$nesne = new BirBaşkası; // Bir\Tam\Sınıfadı  sınıfını örnekler
iAadı\altia\işlev(); // Bir\Tam\iAadı\altia\işlev işlevini çağırır
$a = new DiziNesnesi(array(1)); // DiziNesnesi sınıfını örnekler
// "use \DiziNesnesi" olmasaydı fan\DiziNesnesi sınıfını örneklerdik
?>
]]>
    </programlisting>
   </example>
   İsim alanlı adlar için baştaki terbölü gereksiz olup izin verilmediği
   gibi bunlar geçerli isim alanına göre işlenmezler. İthal edilen isimler
   ise tamamen nitelenmiş olmalıdır. (Tamamen nitelenmiş isimler
   <literal>Fan\Fin</literal> şeklinde isim alanı ayracı içermelerine karşın
   küresel isimler <literal>FanFin</literal> şeklinde isim alanı ayracı
   içermezler.)
  </para>
  <para>
   PHP bunlara ek olarak çok sayıda <code>use</code> deyiminin aynı satırda
   kullanılmasına imkan veren bir kısayola da sahiptir.
   <example>
    <title>- <code>use</code> işleci ile rumuz/ithal, çoklu <code>use</code>
      kullanımı</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Bir\Tam\Sınıfadı as BirBaşkası, Bir\Tam\iAadı;

$nesne = new BirBaşkası; // Bir\Tam\Sınıfadı sınıfını örnekler
iAadı\altia\işlev();     // Bir\Tam\iAadı\altia\işlev işlevini çağırır
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   İthal işlemi derleme sırasında yerine getirilir ve dolayısıyla devingen
   sınıf, işlev ve sabit isimlerini etkilemez.
   <example>
    <title>- İthal işlemi ve devingen isimler</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Bir\Tam\Sınıfadı as BirBaşkası, Bir\Tam\iAadı;

$nesne = new BirBaşkası; // Bir\Tam\Sınıfadı sınıfını örnekler
$a = 'BirBaşkası';
$nesne = new $a;         // BirBaşkası sınıfını örnekler
?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Bunlara ek olarak, ithal işlemi sadece nitelenmemiş ve nitelenmiş
   isimleri etkiler. Tamamen nitelenmiş isimler mutlak olup ithal işleminden
   etkilenmez.
   <example>
    <title>- İthal işlemi ve tamamen nitelenmiş isimler</title>
    <programlisting role="php">
     <![CDATA[
<?php
use Bir\Tam\Sınıfadı as BirBaşkası, Bir\Tam\iAadı;

$nesne = new BirBaşkası;       // Bir\Tam\Sınıfadı sınıfını örnekler
$nesne = new \BirBaşkası;        // BirBaşkası sınıfını örnekler
$nesne = new BirBaşkası\birşey;  // Bir\Tam\Sınıfadı\birşey sınıfını örnekler
$nesne = new \BirBaşkası\birşey; // BirBaşkası\birşey sınıfını örnekler
?>
]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.global">
  <title>Küresel Alan</title>
  <para>
   Herhangi bir isim alanı tanımı olmaksızın, tüm sınıf ve işlev tanımları
   PHP'de isim alanlarının desteklenmediği zamanlardaki gibi küresel alana
   yerleştirilir. Bir ismin önüne doğrudan doğruya <literal>\</literal> konulması,
   bu ismin bir isim alanı bağlamında bile küresel alandan bir isim olarak
   işlem görmesini sağlar.
   <example>
    <title>- Küresel alan belirtiminin kullanımı</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

/* A\B\C\fopen işlevidir */
function fopen() {
     /* ... */
     $f = \fopen(...); // küresel fopen çağrılır
     return $f;
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>
 <sect1 xml:id="language.namespaces.fallback">
  <title>İsim alanlarının kullanımı: son çare olarak küresel işlev ve
    sabitler</title>
  <para>
   Bir isim alanı içinde PHP, bir sınıf ismi, işlev veya sabitin bağlamında
   nitelenmemiş isimlere rastlarsa bunları farklı önceliklerle ele alır.
   Sınıf isimleri daima geçerli isim alanı ismine çözümlenir. Dolayısıyla
   yerleşik veya isim alansız kullanıcı sınıflarına erişmek için, bunların
   aşağıdaki gibi tamamen nitelenmiş isimlerinin kullanılması gerekir:
   <example>
    <title>- Küresel sınıflara bir isim alanı içinde erişim</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;
class Exception extends \Exception {}

$a = new Exception('hi'); // $a, A\B\C\Exception sınıfının bir nesnesidir
$b = new \Exception('hi'); // $b, Exception sınıfının bir nesnesidir

$c = new ArrayObject; // ölümcül hata, A\B\C\ArrayObject yoktur
?>
    ]]>
    </programlisting>
   </example>
  </para>
  <para>
   İşlevler ve sabitler açısından PHP, bir isim alanlı işlev veya sabit
   mevcut değilse son çare olarak küresel işlevlere ve sabitlere başvurur.
   <example>
    <title>- Bir isim alanı içinde son çare olarak küresel işlev ve
      sabitlerin kullanımı</title>
    <programlisting role="php">
     <![CDATA[
<?php
namespace A\B\C;

const E_ERROR = 45;
function strlen($str)
{
    return \strlen($str) - 1;
}

echo E_ERROR, "\n"; // "45" basar
echo INI_ALL, "\n"; // "7" basar - son çare olarak küresel INI_ALL

echo strlen('hi'), "\n"; // "1" basar
if (is_array('hi')) { // "dizi değil" basar
    echo "dizi\n";
} else {
    echo "dizi değil\n";
}
?>
    ]]>
    </programlisting>
   </example>
  </para>
 </sect1>

 <sect1 xml:id="language.namespaces.rules">
  <title>İsim çözünürlük kuralları</title>
  <para>
   İsim çözünürlük kurallarının amaçları gereği bazı önemli tanımlar:
   <variablelist>
    <title>İsim alanı adı tanımları</title>
    <varlistentry>
     <term>Nitelenmemiş isim</term>
     <listitem>
      <para>
       <literal>Fan</literal> gibi bir isim alanı ayracı içermeyen bir betimleyici.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Nitelenmiş isim</term>
     <listitem>
      <para>
       <literal>Fan\Fin</literal> gibi bir isim alanı ayracı içeren bir
       betimleyici.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Tamamen nitelenmiş isim</term>
     <listitem>
      <para>
       <literal>\Fan\Fin</literal> gibi bir isim alanı ayracı ile başlayan isim
       alanı ayraçlı bir betimleyici.  <literal>namespace\Fan</literal> da tamamen
       nitelenmiş bir isimdir.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
  <para>
   İsimler şu kurallara göre çözümlenir:
   <orderedlist>
    <listitem>
     <simpara>
      Tamamen nitelenmiş işlev, sınıf ve sabit isimleri derleme sırasında
      çözümlenir. Örneğin, <literal>new \A\B</literal> deyimi <literal>A\B</literal>
      sınıfı olarak çözümlenir.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Tamamen nitelenmemiş (nitelenmemiş ve nitelenmiş) isimlerin tamamı
      derleme sırasında geçerli ithal kurallarına göre dönüştürülür.
      Örneğin, <literal>A\B\C</literal> isim alanı <literal>C</literal> olarak ithal
      edilmişse bir <literal>C\D\e()</literal> çağrısı  <literal>A\B\C\D\e()</literal>
      çağrısına dönüştürülür.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Bir isim alanı içinde ithal kurallarına göre dönüştürülmeyen tüm
      nitelenmiş isimlerin önüne geçerli isim alanı ismi getirilir. Örneğin,
      <literal>A\B</literal> isim alanında yapılmış bir <literal>C\D\e()</literal>
      çağrısı <literal>A\B\C\D\e()</literal> çağrısına dönüştürülecektir.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      Nitelenmemiş sınıf isimleri derleme sırasında geçerli ithal
      kurallarına göre dönüştürülür (kısa ithal ismi için tam isim
      kullanılır). Örneğin, <literal>A\B\C</literal> isim alanı <literal>C</literal>
      olarak ithal edilmişse <literal>new C()</literal> deyimi <literal>new
        A\B\C()</literal> deyimine dönüştürülür.
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      İsim alanı içindeki (A\B olsun), nitelenmemiş işlev çağrıları çalışma
      anında çözümlenir. <literal>fan()</literal> diye bir işlev şöyle çözümlenir:
     </simpara>
      <orderedlist>
       <listitem>
        <simpara>
         Geçerli isim alanında <literal>A\B\fan()</literal> işlevi aranır.
        </simpara>
       </listitem>
       <listitem>
        <simpara>
         Küresel <literal>fan()</literal> işlevi bulunmaya ve çağrılmaya çalışılır.
        </simpara>
       </listitem>
      </orderedlist>
    </listitem>
    <listitem>
     <simpara>
      İsim alanı içindeki (A\B olsun), nitelenmemiş (tamamen nitelenmemiş)
      veya nitelenmiş  sınıf ismi çağrıları çalışma anında çözümlenir.
      <literal>new C()</literal> ve <literal>new D\E()</literal> deyimlerinin
      çözümlenişi aşağıda verilmiştir.
     </simpara>
     <simpara>
      <literal>new C()</literal> için:
     </simpara>
     <orderedlist>
      <listitem>
       <simpara>
         Geçerli isim alanında <literal>A\B\C</literal> sınıfı aranır.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <literal>A\B\C</literal> özdevinimli olarak yüklenmeye çalışılır.
       </simpara>
      </listitem>
     </orderedlist>
     <simpara>
      <literal>new D\E()</literal> için:
     </simpara>
     <orderedlist>
      <listitem>
       <simpara>
        Geçerli isim alanı ile öncelenmiş olarak <literal>A\B\D\E</literal> sınıfı
        aranır.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <literal>A\B\D\E</literal>  özdevinimli olarak yüklenmeye çalışılır.
       </simpara>
      </listitem>
     </orderedlist>
     <simpara>
      Küresel isim alanındaki bir küresel sınıfa başvururken <literal>new
        \C()</literal> şeklinde tamamen nitelenmiş isim kullanılmalıdır.
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <example>
   <title>- Örneklerle İsim Çözünürlüğü</title>
   <programlisting role="php">
<![CDATA[
<?php
namespace A;
use B\D, C\E as F;

// işlev çağrıları

fan();      // Varsa "A" isim alanında tanımlı "fan", yoksa küresel "fan"

\fan();     // Küresel alanda tanımlı "fan" çağrılır

my\fan();   // "A\my" isim alanında tanımlı "fan" çağrılır

F();        // Varsa "A" isim alanında tanımlı "F", yoksa küresel "F"

//sınıf adı çağrıları

new B();    // Varsa "A" isim alanında tanımlı "B" örneklenir
            // Yoksa "A\B" sınıfı özdevinimli olarak yüklenmeye çalışılır

new D();    // ithal kuralları ile, "B" isim alanında tanımlı "D" örneklenir
            // yoksa "B\D" sınıfı özdevinimli olarak yüklenmeye çalışılır

new F();    // ithal kuralları ile, "C" isim alanında tanımlı "E" örneklenir
            // yoksa "C\E" sınıfı özdevinimli olarak yüklenmeye çalışılır

new \B();   // Varsa küresel alanda tanımlı "B" örneklenir
            // yoksa "B" sınıfı özdevinimli olarak yüklenmeye çalışılır

new \D();   // Varsa küresel alanda tanımlı "D" örneklenir
            // yoksa "D" sınıfı özdevinimli olarak yüklenmeye çalışılır

new \F();   // Varsa küresel alanda tanımlı "F" örneklenir
            // yoksa "F" sınıfı özdevinimli olarak yüklenmeye çalışılır

// başka bir isim alanından duruk yöntem/isim alanı işlevleri

B\fan();    // "A\B" isim alanında tanımlı "fan" çağrılır

B::fan();   // "A" isim alanında tanımlı "B" sınıfının "fan" yöntemi çağrılır
            // "A\B" sınıfı yoksa, "A\B" özdevinimli yüklenmeye çalışılır

D::fan();   // ithal kuralları ile, "B" isim alanında tanımlı "D" sınıfının
            // "fan" yöntemi çağrılır; "B\D"  sınıfı yoksa, "B\D"
            // özdevinimli yüklenmeye çalışılır

\B\fan();   // "B" isim alanında tanımlı "fan" çağrılır

\B::fan();  // Küresel alandaki "B" sınıfının "fan" yöntemi çağrılır
            // "B" sınıfı yoksa, "B" özdevinimli yüklenmeye çalışılır

// geçerli isim alanının duruk yöntemleri ve isim alanı işlevleri

A\B::fan();   // "A\A" isim alanında tanımlı "B" sınıfının "fan" yöntemi
              // çağrılır; "A\A\B" sınıfı yoksa, "A\A\B" özdevinimli
              // yüklenmeye çalışılır

\A\B::fan();  // "A\B" isim alanında tanımlı "B" sınıfının "fan" yöntemi
              // çağrılır; "A\B" sınıfı yoksa, "A\B" özdevinimli yüklenmeye
              // çalışılır
?>
]]>
   </programlisting>
  </example>
 </sect1>
 <sect1 xml:id="language.namespaces.faq">
  <title>SSS: İsim alanları hakkında bilinmesi gerekenler</title>
  <para>
   Bu SSS iki bölüme ayrılır: genel sorular ve isim alanlarını tamamen
   anlamaya yardımcı olacak gerçeklenime özgü ayrıntılar.
  </para>
  <para>
   Önce genel sorularla başlıyoruz.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shouldicare">İsim alanlarını
        kullanmayacak olsam bile bu konuyla yine de ilgilenmeli miyim?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.globalclass">Yerleşik ve
      küresel sınıfları bir isim alanı içinde nasıl kullanabilirim?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.innamespace">İsim alanlarının
      sınıflarını, işlevlerini ve sabitlerini kendi isim alanlarında nasıl
      kullanabilirim?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.full"><literal>\bir\isim</literal>
      veya <literal>\isim</literal> gibi bir isim nasıl çözümlenir?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.qualified"
      ><literal>bir\isim</literal> gibi bir isim nasıl çözümlenir?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname1"><literal>isim</literal>
      gibi bir nitelenmemiş sınıf ismi nasıl çözümlenir?</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.shortname2"><literal>isim</literal>
      gibi bir nitelenmemiş işlev veya sabit ismi nasıl çözümlenir?</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <para>
   İsim alanları gerçeklenimini tamamen anlamaya yardımcı olacak
   gerçeklenime özgü bir kaç ayrıntı vardır.
   <orderedlist>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.conflict">İthal edilen isimler
      aynı dosyada tanımlı sınıf isimleriyle çakışmamalıdır.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.nested">İç içe isim alanlarına
      izin verilmez.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.nofuncconstantuse"
      ><literal>use</literal> deyimi üzerinden ne işlevler ne de sabitler ithal
      edilebilir.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.quote">Devingen isim alanları
      isimlerinin (tırnak içine alınmış betimleyiciler) içindeki
      tersbölülerin öncelenmesi gerekir.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.constants">Tersbölü
      kullanılarak atıf yapılan tanımsız sabitler ölümcül hataya sebep
      olur.</link>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <link linkend="language.namespaces.faq.builtinconst">Özel NULL, TRUE,
      FALSE, ZEND_THREAD_SAFE ve ZEND_DEBUG_BUILD sabitleri geçersiz
      kılınamaz.</link>
     </simpara>
    </listitem>
   </orderedlist>
  </para>
  <sect2 xml:id="language.namespaces.faq.shouldicare">
   <title>İsim alanlarını kullanmayacak olsam bile bu konuyla yine de
     ilgilenmeli miyim?</title>
   <para>
    Hayır. Ne isim alanları mevcut koddan etkilenir ne de isim alanlarını
    içermeyen kodlar isim alanlarından etkilenir. İsterseniz kodu böyle
    yazabilirsiniz:
   </para>
   <para>
    <example>
     <title>- Küresel sınıflara bir isim alanı dışından erişim</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new \stdClass;
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Bu kod şuna eşdeğerdir:
   </para>
   <para>
    <example>
     <title>-  Küresel sınıflara bir isim alanı dışından erişim</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = new stdClass;
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.globalclass">
   <title>Yerleşik ve küresel sınıfları bir isim alanı içinde nasıl
     kullanabilirim?</title>
   <para>
    <example>
     <title>- İsim alanı içinden yerleşik sınıflara erişim</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace fan;
$a = new \stdClass;

function test(\ArrayObject $typehintexample = null) {}

$a = \DirectoryIterator::CURRENT_AS_FILEINFO;

// Bir yerleşik veya küresel sınıfın genişletilmesi
class MyException extends \Exception {}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.innamespace">
   <title>İsim alanlarının sınıflarını, işlevlerini ve sabitlerini kendi
     isim alanlarında nasıl kullanabilirim?</title>
   <para>
    <example>
     <title>- İsim alanındaki dahili sınıf, işlev ve sabitlere erişim
     </title>
     <programlisting role="php">
<![CDATA[
<?php
namespace fan;

class Sınıfım {}

// bir ipucu yazdırmak için geçerli isim alanındaki bir sınıfın kullanımı
function dnm(Sınıfım $biripucuörneği = null) {}
// ipucu yazdırmak için geçerli isim alanındaki bir sınıfın başka
// bir yolla kullanımı
function dnm(\fan\Sınıfım $biripucuörneği = null) {}

// geçerli isim alanındaki bir sınıfın genişletilmesi
class AltSınıfım extends Sınıfım {}

// bir küresel işleve erişim
$a = \küreselişlev();

// bir küresel sabite erişim
$b = \INI_ALL;
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.full">
   <title><literal>\bir\isim</literal> veya <literal>\isim</literal> gibi bir isim nasıl
     çözümlenir?</title>
   <para>
    <literal>\</literal> ile başlayan isimler daima yazıldıkları gibi
    çözümlenirler, bu bakımdan <literal>\bir\isim</literal> aslında
    <literal>bir\isim</literal>'dir; <literal>\Exception</literal> da aslında
    <literal>Exception</literal>'dır.
    <example>
     <title>- Tamamen nitelenmiş isimler</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace fan;
$a = new \bir\isim(); // "bir\isim" sınıfını örnekler
echo \strlen('hi');   // "strlen" işlevini çağırır
$a = \INI_ALL;        // $a değişkenine "INI_ALL" sabitinin değeri atanır
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.qualified">
   <title><literal>bir\isim</literal> gibi bir isim nasıl çözümlenir?</title>
   <para>
    Bir tersbölü içeren, ancak tersbölü ile başlamayan <literal>bir\isim</literal>
    gibi isimler iki farklı yolla çözümlenebilir.
   </para>
   <para>
    <literal>bir</literal> ismini başka bir isimle ithal eden bir deyim varsa bu
    takma isim <literal>bir\isim</literal> içindeki <literal>bir</literal>'e uygulanır.
   </para>
   <para>
    Aksi takdirde, <literal>bir\isim</literal> isminin önüne geçerli isim alanı
    adı getirilir.
   </para>
   <para>
    <example>
     <title>- Nitelenmiş isimler</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace fon;
use fan\fin as fon;

$a = new bir\isim(); // "fon\bir\isim" sınıfını örnekler
fon\bar::isim(); // "fan\fin\bar" sınıfının "isim" duruk yöntemi çağrılır
bir\bar();        // "fon\bir\bar" işlevi çağrılır
$a = bir\BAR;    // $a değişkenine "fon\bir\BAR" sabitinin değeri atanır
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname1">
   <title><literal>isim</literal> gibi bir nitelenmemiş sınıf ismi nasıl
     çözümlenir?</title>
   <para>
    <literal>isim</literal> gibi tersbölü içermeyen sınıf isimleri 2 farklı yolla
    çözümlenebilir.
   </para>
   <para>
    <literal>isim</literal> ismini başka bir isimle ithal eden bir deyim varsa bu
    takma isim <literal>isim</literal>'e uygulanır.
   </para>
   <para>
    Aksi takdirde, <literal>isim</literal> ismininin önüne geçerli isim alanı
    getirilir.
   </para>
   <para>
    <example>
     <title>- Nitelenmemiş sınıf isimleri</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace fon;
use fan\fin as fon;

$a = new isim(); // "fon\isim" sınıfı örneklenir
fon::isim();     // "fan\fin" sınıfının "isim" duruk yöntemi çağrılır
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.shortname2">
   <title><literal>isim</literal> gibi bir nitelenmemiş işlev veya sabit ismi
     nasıl çözümlenir?</title>
   <para>
    <literal>isim</literal> gibi tersbölü içermeyen işlev ve sabit isimleri 2
    farklı yolla çözümlenebilir.
   </para>
   <para>
    Önce <literal>isim</literal> isminin önüne geçerli isim alanı ismi getirilir.
   </para>
   <para>
    Son olarak, eğer isim alanında <literal>isim</literal> diye bir işlev veya
    sabit yoksa ve <literal>isim</literal> diye bir küresel işlev veya sabit varsa
    küresel alandaki kullanılır.
   </para>
   <para>
    <example>
     <title>- Nitelenmemiş işlev veya sabit isimleri</title>
     <programlisting role="php">
<![CDATA[
<?php
namespace fon;
use fan\fin as fon;

const FON = 1;

function bir() {}
function fon() {}
function sort(&$a)
{
    sort($a);
    $a = array_flip($a);
    return $a;
}

bir(); // "fon\bir" çarılır
$a = strlen('hi');  // "fon\strlen" mevcut olmadığından küresel
                    // "strlen" işlevi çağrılır
$arr = array(1,3,2);
$b = sort($arr);    // "fon\sort" işlevi çağrılır
$c = fon(); // "fon\fon" işlevi çağrılır - ithal işlemi uygulanmaz

$a = FON;     // $a değişkenine "fon\FON" sabitinin değeri
              // atanır - ithal işlemi uygulanmaz
$b = INI_ALL; // $b değişkenine "INI_ALL" küresel sabitinin değeri atanır
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.conflict">
   <title>İthal edilen isimler aynı dosyada tanımlı sınıf isimleriyle
     çakışmamalıdır.</title>
   <para>
    Aşağıdaki iki betik birlikte kurallara uygundur:
    <informalexample>
     <simpara>dosya1.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace bir\isim;
class Sınıfım {}
?>
     ]]>
     </programlisting>
     <simpara>dosya2.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace diğer;
class BirŞey {}
?>
     ]]>
     </programlisting>
     <simpara>dosya.php</simpara>
     <programlisting role="php">
     <![CDATA[
<?php
namespace bir\isim;
include 'dosya1.php';
include 'dosya2.php';

use diğer\BirŞey as Sınıfım;
$a = new Sınıfım; // "diğer" isim alanındaki "BirŞey" sınıfını örnekler
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    <literal>Sınıfım</literal> sınıfı <literal>bir\isim</literal> isim alanında mevcut
    olduğu halde <literal>Sınıfım</literal> ayrı bir dosyada tanımlandığından
    herhangi bir isim çakışması olmaz. Ancak, sonraki örnekte,
    <literal>Sınıfım</literal> sınıfı <literal>use</literal> deyimi ile aynı dosyada
    tanımlandığından isim çakışmasından dolayı ölümcül hata oluşur.
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace bir\isim;
use diğer\BirŞey as Sınıfım;
class Sınıfım {} // ölümcül hata: Sınıfım ithal edilen sınıfla çakışır
$a = new Sınıfım;
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.nested">
   <title>İç içe isim alanlarına izin verilmez.</title>
   <para>
    PHP isim alanlarının böyle iç içe tanımlanmasına izin vermez:
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace bir\isim {
    namespace içiçe {
        class fan {}
    }
}
?>
     ]]>
     </programlisting>
    </informalexample>
    Bununla birlikte, isim alanlarını birbirinin içinde şöyle tanımlamak
    mümkündür:
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace bir\isim\içiçe {
    class fan {}
}
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.nofuncconstantuse">
   <title><literal>use</literal> deyimi üzerinden ne işlevler ne de sabitler ithal
     edilebilir.</title>
   <para>
    <literal>use</literal> deyimlerinden sadece isim alanları ve sınıf isimleri
    etkilenir. Uzunca bir işlev veya sabit ismini kısaltmak için kendilerini
    içeren isim alanını ithal etmeniz yeterlidir.
    <informalexample>
     <programlisting role="php">
     <![CDATA[
<?php
namespace benimki;
use epeyce\fazla\uzun\isim;

$a = isim\SABİT;
isim\işlev();
?>
     ]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.quote">
   <title>Devingen isim alanları isimlerinin (tırnak içine alınmış
     betimleyiciler) içindeki tersbölülerin öncelenmesi gerekir.</title>
   <para>
    Tersbölü imi dizgelerin içinde bir önceleme karakteri olarak
    kullanıldığından çift tırnaklar arasına alınmış bir dizge içindeki bir
    tersbölü karakterinin tersbölü ile öncelenmesi gerekir. Aksi takdirde,
    istenmeyen durumlar ortaya çıkabilir:
    <example>
     <title>- İsim alanlı isimleri çift tırnaklar arasında kullanmak
       tehlikelidir</title>
     <programlisting role="php">
      <![CDATA[
<?php
$a = new "tehlikeli\nesne"; // \n, çift tırnaklı dizge içinde
                            // satırsonu karakteridir!
$obj = new $a;

$a = new 'bu\tamamen\tehlikesiz\nesne'; // burada sorun yok.
$obj = new $a;
?>
      ]]>
     </programlisting>
    </example>
    Tersbölüleri tek tırnakları arasına alınmış bir dizge içinde kullanmak
    daha güvenli olsa da her iki dizge türünde de tersbölüleri öncelemek en
    güvenlisidir.
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.constants">
   <title>Tersbölü kullanılarak atıf yapılan tanımsız sabitler ölümcül
     hataya sebep olur.</title>
   <para>
    <literal>FAN</literal> gibi nitelenmemiş olarak tanımsız sabitlere
    rastlandığında PHP, bunun <literal>FAN</literal> değerli bir sabit
    varsayıldığını belirten bir uyarı üretecektir. İster nitelenmiş olsun
    ister tamamen nitelenmiş olsun tanımsız bir sabit daima ölümcül hataya
    sebep olur.
    <example>
     <title>- Tanımsız sabitler</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
$a = FAN;  // uyarı üretir - "FAN" sabit olarak tanımsız olduğundan
           // bir sabit ismi değil, bir sabit değer olarak ele alınır.
$a = \FAN;     // ölümcül hata, isim alanlı tanımsız sabit: FAN
$a = Fin\FAN;  // ölümcül hata, isim alanlı tanımsız sabit: bar\Fin\FAN
$a = \Fin\FAN; // ölümcül hata, isim alanlı tanımsız sabit: Fin\FAN
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
  <sect2 xml:id="language.namespaces.faq.builtinconst">
   <title>Özel NULL, TRUE, FALSE, ZEND_THREAD_SAFE ve ZEND_DEBUG_BUILD
     sabitleri geçersiz kılınamaz.</title>
   <para>
    Bir özel, yerleşik sabiti bir isim alanlı sabit olarak tanımlamaya
    kalkışmak ölümcül hatayla sonuçlanır.
    <example>
     <title>- Tanımsız sabitler</title>
     <programlisting role="php">
      <![CDATA[
<?php
namespace bar;
const NULL = 0;       // ölümcül hata;
const true = 'ahmak'; // bu da ölümcül hata;
// etc.
?>
      ]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
 Local variables:
 mode: sgml
 sgml-omittag:t
 sgml-shorttag:t
 sgml-minimize-attributes:nil
 sgml-always-quote-attributes:t
 sgml-indent-step:1
 sgml-indent-data:t
 indent-tabs-mode:nil
 sgml-parent-document:nil
 sgml-default-dtd-file:"../../manual.ced"
 sgml-exposed-tags:nil
 sgml-local-catalogs:nil
 sgml-local-ecat-files:nil
 End:
 vim600: syn=xml fen fdm=syntax fdl=2 si
 vim: et tw=78 syn=sgml
 vi: ts=1 sw=1
-->
