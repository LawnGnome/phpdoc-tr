<?xml version="1.0" encoding="iso-8859-9"?>
<!-- $Revision: 1.1 $ -->
 <chapter id="language.functions">
  <title>Fonksiyonlar</title>

  <sect1 id="functions.user-defined">
   <title>Kullanýcý-tanýmlý fonksiyonlar</title>
 
   <para>
   Bir fonksiyon, aþaðýdakine benzer bir söz dizimi kullanýlarak tanýmlanabilir:
   </para>
   <para>
    <example>
     <title>Fonksiyon kullanýmýný gösteren sözde kod</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Örnek fonksiyon.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <simpara>
   Bir fonksiyonun içerisinde geçerli her tür PHP kodu kullanýlabilir,
   buna baþka fonksiyonlar ve <link linkend="keyword.class">sýnýf</link>
   tanýmlamalarý da dahildir.
   </simpara>
   <para>
   Fonksiyon isimleri, PHP'deki diðer isimlerle ayný kurallara tabidir.
   Geçerli bir fonksiyon ismi bir harf ya da alt çizgi ile baþlar,
   herhangi bir sayýda geçerli harf, sayý ya da alt çizgi ile devam eder.
   Düzenli ifade olarak yazmak istersek, þu þekilde ifade edebiliriz:
   <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   <simpara>
   PHP 3'te, fonksiyonlarýn referans edilmeden önce tanýmlanmasý gerekliydi.
   PHP 4 itibariyle bu gereksinim aþaðýdaki iki örnekte gösterilen
   <emphasis>istisna</emphasis> durum haricinde ortadan kalkmýþtýr.
   </simpara>
   <para>
   Bir fonksiyon aþaðýdaki iki örnekte gösterildiði gibi koþullu olarak tanýmlandýysa,
   bu fonksiyonun tanýmlamasýnýn fonksiyon çaðrýlmadan <emphasis>önce</emphasis>
   yapýlmasý gerekmektedir.
   </para>
   <para>
    <example>
     <title>Koþula baðlý fonksiyonlar</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Henüz varolmadýðý için foo() buradan çaðrýlamaz,
   ancak bar() çaðrýlabilir */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Uygulamanýn çalýþmasý bana eriþene kadar ben yokum.\n";
  }
}

/* Artýk foo() çaðrýlabilir çünkü $makefoo deðiþkenine true deðeri atandý */

if ($makefoo) foo();

function bar() 
{
  echo "Program baþlatýldýðý anda ben de varolurum.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Fonksiyon içinde fonksiyon</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "foo() çaðrýlana kadar yokum.\n";
  }
}

/* Henüz varolmadýðý için
   bar() çaðrýlamaz. */

foo();

/* Artýk bar() çaðrýlabilir,
   foo() iþlendiðinde bar()
   eriþilebilir hale gelir */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
   PHP'de tüm fonksiyonlar ve sýnýflar global kapsamdadýr - Bir fonksiyonun
   içinden bile tanýmlanmýþ olsalar ya da tam tersi de olsa bu durum geçerlidir.
   </para>
   <simpara>
   PHP fonksiyon overloading iþlemini desteklemez, önceden tanýmlanmýþ bir
   fonksiyonun yeniden tanýmlanmasý ya da tanýmsýz kýlýnmasý mümkün deðildir.
   </simpara>
   <note>
    <simpara>
    Fonksiyon isimleri büyük-küçük harf duyarsýzdýr, ancak fonksiyon isimlerini
    tanýmlandýklarý þekilde kullanmak iyi bir alýþkanlýk olabilir.
    </simpara>
   </note>   
   <simpara>
   PHP 3 fonksiyona geçirilen argüman sayýsýný deðiþken olarak verebilme özelliðine
   sahip deðildir, ancak öntanýmlý argümanlar desteklenmektedir (bakýnýz
   <link linkend="functions.arguments.default">Öntanýmlý argüman deðerleri</link>).
   PHP 4'den itibaren her iki özellik de desteklenmektedir. Daha fazla bilgi için
   <link linkend="functions.variable-arg-list">Deðiþken-uzunluðu argüman listeleri</link>
   bölümüne ve fonksiyon referanslarý için <function>func_num_args</function>,
   <function>func_get_arg</function> ve <function>func_get_args</function>
   bölümlerine bakabilirsiniz.
   </simpara>
   
   <para>
   PHP'de tekrarlanan fonksiyonlar çaðýrmak mümkündür. Ancak 100-200 seviyeli
   tekrar içeren fonksiyonlardan kaçýnmalýsýnýz, bu tür bir kullaným belleði
   zorlar ve mevcut betiðin çalýþmasýnýn durmasýna sebep olabilir.
    <example>
     <title>Tekrarlanan fonksiyonlar</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>Fonksiyon argümanlarý</title>
 
   <simpara>
   Bilgi, noktalarla ayrýlmýþ bir ifadeler listesi olarak ilgili fonksiyona argüman
   listesi olarak geçirilir.
   </simpara> 
   <para>
   PHP, deðer bazlý argüman geçirmeyi (öntanýmlý olarak), <link
    linkend="functions.arguments.by-reference">referans bazlý deðer geçirmeyi</link> ve
    <link linkend="functions.arguments.default">öntanýmlý argüman deðerlerini</link>
    destekler. Deðiþken-uzunluklu argüman listeleri yalnýzca PHP 4 ve sonrasýnda desteklenir;
    <link linkend="functions.variable-arg-list">Deðiþken-uzunluklu argüman listeleri</link>
    bölümünü ve <function>func_num_args</function>, <function>func_get_arg</function> ve
    <function>func_get_args</function> bölümlerini inceleyerek daha fazla bilgi edinebilirsiniz.
    PHP 3'te benzer bir etki, fonksiyona bir argüman dizisi geçirilerek saðlanabilir:
   </para>
   <para>
    <example>
     <title>Fonksiyonlara dizi geçirmek</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>Argümanlarýn referans bazlý geçirilmesini saðlamak</title>
 
    <simpara>
    Öntanýmlý olarak, fonksiyon argümanlarý deðer bazlý geçirilmektedir
    (bu durumda fonksiyon içerisinde argümanlardan birinin deðerini
    deðiþtirdiðinizde, fonksiyonun dýþýndaki argüman deðeri bundan
    etkilenmemektedir). Fonksiyonun argümanlarý üzerinde deðiþiklik
    yapabilmesini istiyorsanýz, bu argümanlarý referans bazlý geçirmelisiniz.
    </simpara>
    <para>
    Bir argümanýn bir fonksiyona her zaman referans bazlý geçirilmesini istiyorsanýz,
    fonksiyon tanýmlamasýnda o argümanýn baþýna ampersan (&amp;) koyarak bunu saðlayabilirsiniz:
    </para>
    <para>
     <example>
      <title>Fonksiyon parametrelerini referans bazlý geçirmek</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 've biraz daha karakter.';
}
$str = 'Bu bir karakter dizisidir, ';
add_some_extra($str);
echo $str;    // 'Bu bir karakter dizisidir, ve biraz daha karakter.' çýktýsýný verir.
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>Öntanýmlý argüman deðerleri</title>
 
    <para>
    Bir fonksiyon, sayýl (scalar) argümanlar için C++ türünde
    öntanýmlý deðerleri aþaðýdaki biçimde tanýmlayabilir:
    </para>
    <para>
     <example>
      <title>Fonksiyon içerisinde öntanýmlý parametre kullanýmý</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Bir bardak $type yapalým.\n";
}
echo makecoffee();
echo makecoffee("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Yukarýdaki koddan alýnacak çýktý:
    </para>
    <para>
     <screen>
     Bir bardak cappuccino yapalým.
     Bir bardak espresso yapalým.
     </screen>
    </para>
    <para>
    PHP öntanýmlý deðer olarak dizileri ve özel bir tip olan NULL'ý da
    kullanmanýza izin verir, örneðin:
    </para>
    <para>
     <example>
      <title>Sayýl olmayan tiplerin öntanýmlý deðer olarak kullanýmý</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Bir bardak ".join(", ", $types)." $device kullanýlarak yapýldý.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    
    </para>
    <simpara>
    Öntanýmlý deðerler deðiþmez bir ifade olmalýdýr, (örneðin) bir deðiþken,
    bir sýnýf üyesi ya da bir fonksiyon çaðrýmý olmamalýdýr.
    </simpara>
    <para>
    Öntanýmlý argümanlar kullanýrken, öntanýmlama yapýlmýþ tüm argümanlarýn
    öntanýmlama yapýlmamýþ argümanlarýn saðýnda yer almasý gerektiðini unutmayýn.
    Aksi takdirde, iþler beklediðiniz gibi geliþmeyebilir. Aþaðýdaki kod parçasýný
    inceleyin:
    </para>
    <para>
     <example>
      <title>Öntanýmlý fonksiyon argümanlarýnýn hatalý kullanýmý</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Bir kase $type $flavour yapýlýþý.\n";
}
 
echo makeyogurt("ahududu");   // beklendiði gibi çalýþmayacaktýr
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Yukarýdaki örnekten alýnan çýktý:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Bir kase ahududu yapýlýþý.
     </screen>
    </para>
    <para>
    Þimdi, yukarýdakini bununla karþýlaþtýralým:
    </para>
    <para>
     <example>
      <title>Öntanýmlý fonksiyon argümanlarýnýn doðru kullanýmý</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "acidophilus")
{
    return "Bir kase $type $flavour yapýlýþý.\n";
}
 
echo makeyogurt("ahududu");   // beklendiði gibi çalýþýr
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     Bu örnekten alýnan çýktý:
    </para>
    <para>
     <screen>
Bir kase acidophilus ahududu yapýlýþý.
     </screen>
    </para>
    
    <note>
     <simpara>
     PHP 5'den itibaren, öntanýmlý deðerler referans bazlý geçirilebilmektedir.
     </simpara>
    </note>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>Deðiþken-uzunluklu argüman listeleri</title>

    <simpara>
    PHP 4 ve üstü, kullanýcý-tanýmlý fonksiyonlarda deðiþken-uzunluklu argüman listelerini
    desteklemektedir. Bu özelliðin kullanýmý oldukça basittir,
     <function>func_num_args</function>,
     <function>func_get_arg</function>, ve
     <function>func_get_args</function> fonksiyonlarýný inceleyerek bu özelliðin
     nasýl kullanýldýðýný görebilirsiniz.
    </simpara>

    <simpara>
    Özel bir söz dizimi gerekli deðildir, argüman listelerinin açýk bir þekilde
    fonksiyon tanýmlamasý ile birlikte yapýlmasýna devam edilecek ve normal
    biçimde çalýþma iþlemi sürdürülecektir.
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>Dönen deðerler</title>
 
   <para>
   Deðerlerin döndürülmesi, kullanýmý seçime baðlý olan return deyimi ile saðlanýr.
   Bir fonksiyondan herhangi bir tipte deðer döndürülebilir, buna diziler ve nesneler
   de dahildir. Bu deyim kullanýldýðýnda fonksiyonun çalýþmasý aniden durdurulur
   ve kontrol fonksiyonun çaðrýldýðý satýra iade edilir. <function>return</function>
   bölümünü inceleyerek daha fazla bilgiye ulaþabilirsiniz.
   </para>
   <para>
    <example>
     <title><function>return</function> kullanýmý</title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // '16' çýktýsýný verir.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
   Bir fonksiyondan birden fazla deðer döndüremezsiniz, ancak benzer bir sonuç
   bir dizi döndürülerek elde edilebilir.
   </para>
   <para>
    <example>
     <title>Birden fazla deðer elde etmek için dizi döndürmek</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
   Bir fonksiyondan referans döndürmek için, hem fonksiyon tanýmlamasýnda
   hem de fonksiyondan dönen deðeri bir deðiþkene atama aþamasýnda
   &amp; referans operatörünü kullanmalýsýnýz:
   </para>
   <para>
    <example>
     <title>Bir fonksiyondan referans döndürmek</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
   Referanslar hakkýnda daha fazla bilgi için, lütfen <link
    linkend="language.references">Referanslar Açýklanýyor</link> bölümünü inceleyin.
   </simpara>
  </sect1>
 
  <sect1 id="functions.variable-functions">
   <title>Deðiþken fonksiyonlar</title>

   <para>
   PHP deðiþken fonksiyon kavramýný desteklemektedir. Bir deðiþken isminin
   sonuna parantez eklenmiþse, PHP ayný isimde bir fonksiyon olup olmadýðýna bakar ve
   bulduðu takdirde bu fonksiyonu çalýþtýrmaya çalýþýr. Baþka olasý iþlemlerin yanýnda,
   bu özellik geriçaðrýmlarýn (callbacks), fonksiyon tablolarýnýn ve bir dizi baþka
   iþlemin hayata geçirilmesinde kullanýlabilir.
   </para>
   <para>
   Deðiþken fonksiyonlar, aþaðýdakine benzer dil yapýlarýnda çalýþmayacaktýr:
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> ve benzerleri. Bu yapýlarý deðiþken fonksiyon
    olarak kullanmak istediðiniz takdirde, kendi sarýcý (wrapper) fonksiyonunuzu
    yazmak durumundasýnýz.
   </para>
   <para>
    <example>
     <title>Deðiþken fonksiyon örneði</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// Bu echo için sarýcý bir fonksiyondur
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // foo() çaðrýlýr

$func = 'bar';
$func('test');  // bar() çaðrýlýr

$func = 'echoit';
$func('test');  // echoit() çaðrýlýr
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
   Deðiþken fonksiyon özelliðini kullanarak bir nesnenin metodunu da
   çaðýrabilmeniz mümkündür.
    <example>
     <title>Deðiþken metod örneði</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Bu Bar() metodunu çaðýracaktýr
    }
    
    function Bar()
    {
        echo "Bu bir Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Bu $foo->Variable() fonksiyonunu çaðýracaktýr

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Ayrýca bakýnýz: <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    deðiþkenin deðiþkeni</link> ve <function>function_exists</function>.
   </para>
  </sect1>
  
  <sect1 id="functions.internal">
   <title>Ýç (yerleþik) fonksiyonlar</title>
   
   <para>
   PHP standart olarak birçok fonksiyon ve yapý ile birlikte gelmektedir.
   Bunun yanýnda, özel PHP uzantýlarýna ihtiyaç duyan ve aksi takdirde
   "tanýmlanmamýþ fonksiyon" hatasý üreten fonksiyonlar da mevcuttur.
   Örneðin, <function>imagecreatetruecolor</function> gibi <link linkend="ref.image">resim</link>
   fonksiyonlarýný kullanabilmeniz için, PHP'yi <productname>GD</productname> desteði
   ile birlikte derlemiþ olmanýz gereklidir. Ya da, <function>mysql_connect</function>
   fonksiyonunu kullanabilmek için, PHP'nin <link linkend="ref.mysql">MySQL</link> desteði
   ile derlenmiþ olmasý gerekmektedir. Bütün PHP sürümlerine eklenen <link linkend="ref.strings">karakter dizisi</link>
   ve <link linkend="ref.var">deðiþkenler</link> gibi birçok çekirdek fonksiyon mevcuttur.
   <function>phpinfo</function> ya da <function>get_loaded_extensions</function> fonksiyonlarýna
   yapýlacak bir çaðrý ile PHP'ye hangi uzantýlarýn yüklenmiþ olduðunu görebilirsiniz.
   Birçok uzantý öntanýmlý olarak etkinleþtirilmiþtir ve PHP kullaným kýlavuzu bu eklentilerle
   ilgili geniþ bilgi içermektedir. <link linkend="configuration">Yapýlandýrma</link>,
   <link linkend="install">kurulum</link> ve uzantýlara özel bölümleri inceleyerek,
   PHP'nizi nasýl yapýlandýrmanýz gerektiði hakkýnda daha fazla bilgiye eriþebilirsiniz.
   </para>
   <para>
   Kýlavuzun <link linkend="about.prototypes">fonksiyon tanýmý nasýl okunur</link>
   bölümünde fonksiyon prototipleri ile ilgili bilgilendirme bulunmaktadýr.
   Bir fonksiyonun bir deðer mi döndürdüðü ya da yalnýzca deðer geçirilerek iþlem
   mi yaptýðýný anlamak önemlidir.Örneðin, <function>str_replace</function>
   iþlenen karakter dizisini döndürürken, <function>usort</function> kendisine
   geçirilen deðer üzerinde çalýþýr. Herbir kýlavuz sayfasý ayný zamanda
   herbir fonksiyon ile ilgili fonksiyon parametreleri, davranýþ deðiþimleri,
   baþarý ya da baþarýsýzlýk durumunda döndürülen deðerler ve mevcudiyet bilgilerini
   de içermektedir. Bu önemli (ve sýklýkla algýlanmasý güç) farklýlýklarýn
   bilinmesi, doðru PHP kodunun yazýlabilmesi için çok önem taþýmaktadýr.
   </para>
   <para>
    Ayrýca bakýnýz <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function>, ve 
    <function>dl</function>.
   </para>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
