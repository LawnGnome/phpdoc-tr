<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.6 $ -->
<!-- EN-Revision: 1.69 Maintainer: nilgun Status: ready -->
<!-- CREDITS: tpug, sezer -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>İşlevler</title>

  <sect1 xml:id="functions.user-defined">
   <title>Kullanıcı tanımlı işlevler</title>

   <para>
   Bir işlev, şöyle bir söz dizimi kullanılarak tanımlanabilir:
   </para>
   <para>
    <example>
     <title>- İşlev kullanımını gösteren sözde kod</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Örnek işlev.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Bir işlevin içerisinde geçerli her tür PHP kodu kullanılabilir, buna
    başka işlevler ve <link linkend="keyword.class">sınıf</link> tanımları da
    dahildir.
   </simpara>
   <para>
    İşlev isimleri, PHP'deki diğer isimlerle aynı kurallara tabidir. Geçerli
    bir işlev ismi bir harf ya da alt çizgi ile başlar, herhangi bir sayıda
    geçerli harf, sayı ya da alt çizgi ile devam eder. Düzenli ifade olarak,
    şu şekilde ifade edebiliriz:
   <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   <simpara>
    İşlevlerin çağrılmadan önce tanımlanmaları, aşağıdaki iki örnekte
    görüldüğü gibi koşullu olarak tanımlandıkları durumlar haricinde gerekmez.
   </simpara>
   <para>
    Bir işlev aşağıdaki iki örnekte gösterildiği gibi koşullu olarak
    tanımlandıysa, bu işlev tanımının işlev çağrılmadan <emphasis>önce</emphasis> yapılması gerekmektedir.
   </para>
   <para>
    <example>
     <title>- Koşula bağlı işlevler</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Henüz varolmadığı için foo() buradan çağrılamaz,
   ancak bar() çağrılabilir */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Uygulamanın çalışması bana erişene kadar ben yokum.\n";
  }
}

/* $makefoo doğru olduğundan
   artık foo() çağrılabilir */

if ($makefoo) foo();

function bar()
{
  echo "Program başlatıldığı anda ben de varolurum.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>- İşlev içinde işlev</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "foo() çağrılana kadar yokum.\n";
  }
}

/* Henüz varolmadığı için
   bar() çağrılamaz. */

foo();

/* Artık bar() çağrılabilir,
   foo() çağrıldığında bar()
   erişilebilir hale gelir */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP'de tüm işlevler ve sınıflar betik genelinde geçerlidir - bir işlevin
    içinden bile tanımlanmış olsalar işlevin dışından çağrılabilirler.
   </para>
   <simpara>
    PHP işlevlerin farklı değiştirgeli yeni tanımlarının yapılmasını
    desteklemediği gibi, işlevler yeniden tanımlanamaz veya tanımsız
    kılınamaz.
   </simpara>
   <note>
    <simpara>
      İşlev isimleri büyük-küçük harf duyarsızdır, ancak işlev isimlerini
      tanımlandıkları halleriyle kullanmak daha iyidir.
    </simpara>
   </note>
   <simpara>
    <link linkend="functions.variable-arg-list">Değiştirge sayısı değişken
    işlevler</link> desteklendiği gibi işlevlerde <link
    linkend="functions.arguments.default">öntanımlı değiştirge</link>
    kullanımı da desteklenmektedir. Daha ayrıntılı bilgi edinmek için
    <function>func_num_args</function>, <function>func_get_arg</function> ve
    <function>func_get_args</function> işlevlerine de bakınız.
   </simpara>

   <para>
    PHP'de işlevlerin kendilerini çağırması da mümkündür. Ancak 100-200
    iç içe çağrıdan kaçınmalısınız, bu tür kullanım yığıtın dolmasına ve
    betiğin sonlandırılmasına sebep olabilir.
    <example>
     <title>- Kendini çağıran işlev</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   </para>

  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>İşlev değiştirgeleri</title>

   <simpara>
    Bir işleve veri, virgül ayraçlı ifadelerden oluşan bir değiştirge listesi
    ile aktarılır.
   </simpara>
   <para>
    PHP, değiştirgelerin değerleriyle aktarılmalarını (öntanımlı), <link
    linkend="functions.arguments.by-reference">gönderimli aktarım</link>ı ve
    <link linkend="functions.arguments.default">öntanımlı değiştirge
    kullanımı</link>nı destekler. <link
    linkend="functions.variable-arg-list">Değiştirge sayısı değişken
    işlevler</link> de desteklenmektedir; daha ayrıntılı bilgi edinmek için
    <function>func_num_args</function>, <function>func_get_arg</function> ve
    <function>func_get_args</function> işlevlerini de inceleyiniz.
   </para>
   <para>
    <example>
     <title>- İşlevlere dizi aktarımı</title>
     <programlisting role="php">
<![CDATA[
<?php
function dizi_kabul_eder($girdi)
{
    echo "$girde[0] + $girdi[1] = ", $girdi[0]+$girdi[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Gönderimli değiştirge kullanımı</title>

    <simpara>
      Öntanımlı olarak, işlev değiştirgeleri değerleriyle aktarılırlar (bu
      durumda bir değiştirgenin değeri işlev içinde değiştirildiğinde işlevin
      çağrıldığı yerdeki değeri bundan etkilenmez. İşlevin çağrıldığı yerdeki
      değerinin de değişmesini istiyorsanız gönderimli değiştirge
      kullanmalısınız.
    </simpara>
    <para>
      Bir işleve bir değiştirgenin daima gönderimli olarak aktarılmasını
      istiyorsanız, işlev tanımladığınız yerde o değiştirgenin başına &amp;
      karakterini koyarak bunu sağlayabilirsiniz:
    </para>
    <para>
     <example>
      <title>- Gönderimli işlev değiştirgelerinin aktarımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function şunu_da_ekle(&$dizge)
{
    $dizge .= 've bir kaç karakter eklenmiştir.';
}
$dzg = 'Bu bir dizgedir ';
şunu_da_ekle($dzg);
echo $dzg;    // 'Bu bir dizgedir ve bir kaç karakter eklenmiştir.'
              //  çıktısını verir.
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Öntanımlı değiştirge değerleri</title>

    <para>
      Bir işlevde, sayıl değiştirgeler için C++ tarzı öntanımlı değerler
      aşağıdaki biçimde tanımlanabilir:
    </para>
    <para>
     <example>
      <title>- İşlev içinde öntanımlı değiştirge kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function kahveyap($hangisi = "orta şekerli")
{
    return "Bir fincan $hangisi kahve yapalım.\n";
}
echo kahveyap();
echo makecoffee(null);
echo kahveyap("az şekerli");
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Yukarıdaki koddan alınacak çıktı:
    </para>
    <para>
     <screen>
Bir fincan orta şekerli kahve yapalım.
Bir fincan kahve yapalım.
Bir fincan az şekerli kahve yapalım.
     </screen>
    </para>
    <para>
      PHP ayrıca, öntanımlı değer olarak dizilerin ve özel &null; türünün
      kullanımına da izin verir, örneğin:
    </para>
    <para>
     <example>
      <title>- Sayıl olmayan türlerin öntanımlı değer olarak kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function kahveyap($hangi = array("orta şekerli"), $neyde = NULL)
{
    $neyde = is_null($neyde) ? "ocakta" : $neyde;
    return "Bir fincan ".join(", bir fincan ", $hangi)." kahve $neyde yapıldı.\n";
}
echo kahveyap();
echo kahveyap(array("çok şekerli", "az şekerli"), "mangalda");
?>
]]>
      </programlisting>
     </example>

    </para>
    <simpara>
      Öntanımlı değer bir değişken, bir sınıf üyesi ya da bir işlev çağrısı
      değil, bir sabit ifadesi olmalıdır.
    </simpara>
    <para>
      Öntanımlı değiştirgeleri kullanırken, öntanımlama yapılmış tüm
      değiştirgelerin öntanımlama yapılmamış tüm değiştirgelerin sağında yer
      almasına gerektiğine dikkat edin. Aksi takdirde işler yolunda
      gitmeyebilir. Aşağıdaki kod parçasını inceleyin:
    </para>
    <para>
     <example>
      <title>- Öntanımlı değiştirgelerin hatalı kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($nekadar = "az", $neli)
{
    return "Bir kase $nekadar $neli yoğurt yap.\n";
}

echo yoğurtyap("çilekli");   // beklendiği gibi çalışmayacaktır
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Yukarıdaki örnekten alınan çıktı:
    </para>
    <para>
     <screen>
Warning: Missing argument 2 for yoğurtyap(), called in
/home/nilgun/dnm/php-dnm on line 7 and defined in
/home/nilgun/dnm/php-dnm on line 2
Bir kase çilekli  yoğurt yap.
     </screen>
    </para>
    <para>
      Şimdi, yukarıdakini bununla karşılaştıralım:
    </para>
    <para>
     <example>
      <title>- Öntanımlı değiştirgelerin doğru kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($nekadar= "az", $neli)
{
    return "Bir kase $nekadar $neli yoğurt yap.\n";
}

echo yoğurtyap("çilekli");   // beklendiği gibi çalışır
?>
]]>
      </programlisting>
     </example>
    </para>

    <para>
     Bu örnekten alınan çıktı:
    </para>
    <para>
     <screen>
Bir kase az çilekli yoğurt yap.
     </screen>
    </para>

    <note>
     <simpara>
     PHP 5'den itibaren, öntanımlı değerler gönderimli aktarılabilmektedir.
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Değiştirge sayısı değişken işlevler</title>

    <simpara>
      PHP 4 ve sonrasında, değiştirge sayısı değişken kullanıcı tanımlı
      işlevler desteklenmektedir. <function>func_num_args</function>,
      <function>func_get_arg</function> ve <function>func_get_args</function>
      işlevleri sayesinde bu özelliği kolayca kullanabilirsiniz.
    </simpara>

    <simpara>
      Özel bir sözdizimi gerekli değildir, değiştirge listesini işlev
      tanımında açıkça belirtirseniz normal davranışını gösterecektir.
    </simpara>

   </sect2>

  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Dönen değerler</title>

   <para>
    Değerler, kullanımı seçime bağlı olan <command>return</command> deyimi
    kullanılarak döndürülür. Her türde değer döndürülebilir, buna diziler ve
    nesneler dahildir. <function>return</function> kullanıldığında işlevin
    çalışması o noktada hemen durdurulur ve denetim işlevin çağrıldığı satıra
    aktarılır. Daha ayrıntılı bilgi için <function>return</function> bölümüne
    bakınız.
   </para>
   <para>
    <example>
     <title>- <code>return</code> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // '16' çıktılar.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Bir işlevden birden fazla değer döndüremezsiniz, ancak böyle bir sonucu
    bir dizi döndürülerek elde edebilirsiniz.
   </para>
   <para>
    <example>
     <title>- Bir diziyle birden fazla değerin döndürülmesi</title>
     <programlisting role="php">
<![CDATA[
<?php
function küçük_sayılar()
{
    return array (0, 1, 2);
}
list ($sıfır, $bir, $iki) = küçük_sayılar();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Bir işlevden gönderimli bir değer döndürmek için, &amp; işlecini hem
    işlev bildiriminde hem de dönen değeri bir değişkene atarken
    kullanmalısınız:
   </para>
   <para>
    <example>
     <title>- Bir işlevden gönderimli değer döndürmek</title>
     <programlisting role="php">
<![CDATA[
<?php
function &gönderimli_döndür()
{
    return $gönderim;
}

$yenigönderim =& gönderimli_döndür();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Gönderimler hakkında daha fazla bilgi edinmek için <link
    linkend="language.references">Gönderimler Hakkında</link> bölümüne
    bakınız.
   </simpara>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>Değişken işlevler</title>

   <para>
    PHP değişken işlev kavramını desteklemektedir. Yani, bir değişken isminin
    sonuna parantez eklenmişse, PHP aynı isimde bir işlev olup olmadığına
    bakar ve bulduğu takdirde bu işlevi çalıştırmaya çalışır. Başka olası
    işlemlerin yanında, bu özellik geri çağırımların, işlev tablolarının ve
    benzerlerinin gerçeklenmesinde kullanılabilir.
   </para>
   <para>
    Değişken işlevler,
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> ve benzeri dil yapılarında çalışmayacaktır.
    Bu yapıları değişken işlev olarak kullanmak istediğiniz takdirde, gerekli
    sarmalayıcı işlevleri kendiniz yazmalısınız.
   </para>
   <para>
    <example>
     <title>- Değişken işlev örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// Bu echo için sarmalayıcı işlevdir
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // foo() çağrılır

$func = 'bar';
$func('test');  // bar() çağrılır

$func = 'echoit';
$func('test');  // echoit() çağrılır
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Değişken işlev özelliğini kullanarak bir nesnenin bir yöntemini de
    çağırabilmeniz mümkündür.
    <example>
     <title>- Değişken yöntem örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Bu Bar() yöntemini çağıracaktır
    }

    function Bar()
    {
        echo "Bu bir Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Bu $foo->Variable() işlevini çağıracaktır

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Ayrıca bakınız: <function>call_user_func</function>,
    <link linkend="language.variables.variable"> değişken değişkenleri</link>
    ve <function>function_exists</function>.
   </para>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Yerleşik işlevler</title>

   <para>
    PHP standart olarak birçok işlev ve oluşum ile birlikte gelmektedir.
    Bunun yanında, özel PHP eklentilerinin derlenmesini gerektiren, aksi
    takdirde "tanımsız işlev" hatası üreten işlevler de mevcuttur. Örneğin,
    <function>imagecreatetruecolor</function> gibi <link linkend="ref.image"
    >resim</link> işlevlerini kullanabilmek için, PHP'yi
    <productname>GD</productname> desteğiyle derlemiş olmanız gerekir. Ya da,
    <function>mysql_connect</function> işlevini kullanabilmek için, PHP'nin
    <link linkend="ref.mysql">MySQL</link> desteği ile derlenmiş olması
    gerekmektedir. Bunların yanında, bütün PHP sürümlerine eklenen <link
    linkend="ref.strings">dizge</link> ve <link linkend="ref.var"
    >değişken</link> işlevleri gibi birçok çekirdek işlev de mevcuttur.
    <function>phpinfo</function> ya da
    <function>get_loaded_extensions</function> işlevlerine yapılacak bir
    çağrı ile PHP'ye hangi eklentilerin yüklenmiş olduğunu görebilirsiniz.
    Birçok uzantı öntanımlı olarak etkinleştirilmiş olup PHP Kılavuzunda bu
    eklentilerle ilgili geniş bilgi verilmiştir. PHP'yi nasıl yapılandırmanız
    gerektiğiyle ilgili bilgiyi <link linkend="configuration"
    >yapılandırma</link> ve <link linkend="install">kurulum</link> bölümleri
    ile eklerdeki özel bölümlerde bulabilirsiniz.
   </para>
   <para>
    Kılavuzun <link linkend="about.prototypes">işlev tanımı nasıl
    okunur</link> bölümünde bir işlev tanımının nasıl okunup anlaşılabileceği
    ile ilgili bilgiler bulunmaktadır. Bir işlevin bir değer mi döndürdüğü
    yoksa aktarılan değerlerle sadece işlem mi yaptığını anlamak önemlidir.
    Örneğin, <function>str_replace</function> değiştirilmiş dizgeyle
    dönerken, <function>usort</function> sadece kendisine aktarılan değer
    üzerinde çalışır. Ayrıca, her kılavuz sayfasında her işlevin
    değiştirgeleri, davranış değişiklikleri, başarı ya da başarısızlık
    durumunda döndürülen değerler ve kullanılabilirlik bilgileri
    bulunmaktadır. Bu önemli (ve sıklıkla algılanması güç) farklılıkların
    bilinmesi, doğru PHP kodunun yazılabilmesi için büyük önem taşımaktadır.
   </para>
   <para>
    Ayrıca bakınız: <function>function_exists</function>,
    <link linkend="funcref">İşlev Başvuru Kılavuzu</link>,
    <function>get_extension_funcs</function> ve
    <function>dl</function>.
   </para>
  </sect1>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
