<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.2 $ -->
<!-- EN-Revision: 1.39 Maintainer: nilgun Status: ready -->
<!-- Last translator: Nilgün Belma Bugüner -->
 <sect1 xml:id="language.oop5.reflection" xmlns="http://docbook.org/ns/docbook">
  <title>Yansıtma</title>
  <sect2 xml:id="language.oop5.reflection.toc">
   <title>İçindekiler</title>
   <simplelist>
    <member><link linkend="language.oop5.reflection.introduction"
      >Giriş</link></member>
    <member><link linkend="language.oop5.reflection.reflector"
      ><code>Reflector</code> Arayüzü</link></member>
    <member><link linkend="language.oop5.reflection.reflectionexception"
      ><code>ReflectionException</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionfunction"
      ><code>ReflectionFunction</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionparameter"
      ><code>ReflectionParameter</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionclass"
      ><code>ReflectionClass</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionobject"
      ><code>ReflectionObject</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionmethod"
      ><code>ReflectionMethod</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionproperty"
      ><code>ReflectionProperty</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.reflectionextension"
      ><code>ReflectionExtension</code> Sınıfı</link></member>
    <member><link linkend="language.oop5.reflection.extending"
      >Yansıtma sınıflarının genişletilmesi</link></member>
   </simplelist>
  </sect2>
  <sect2 xml:id="language.oop5.reflection.introduction">
   <title>Giriş</title>
   <para>
    PHP 5, sınıflar, arayüzler, işlevler, yöntemler ve hatta eklentiler
    üzerinde  tersine mühendislik yapabilmeyi sağlayan eksiksiz bir yansıtma
    arayüzü ile gelmektedir. Buna ek olarak, yansıtma arayüzü, işlevler,
    sınıflar ve yöntemler için belgeleme açıklamalarının elde edilmesini
    sağlayan yollar içerir.
   </para>
   <para>
    Yansıtma arayüzü Zend Motorunun bir nesne yönelimli eklentisi olup şu
    sınıflardan oluşur:
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Reflection { }
interface Reflector { }
class ReflectionException extends Exception { }
class ReflectionFunction extends ReflectionFunctionAbstract implements Reflector { }
class ReflectionParameter implements Reflector { }
class ReflectionMethod extends ReflectionFunctionAbstract implements Reflector { }
class ReflectionClass implements Reflector { }
class ReflectionObject extends ReflectionClass { }
class ReflectionProperty implements Reflector { }
class ReflectionExtension implements Reflector { }
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     Bu sınıflarla ilgili ayrıntılı bilgi edinmek için sonraki bölümlere
     bakınız.
    </simpara>
   </note>
   <para>
      Aşağıdaki örnek kodu çalıştırdığımızı varsayalım:
    <example>
     <title>- Yansıtma Arayüzünün basit kullanımı</title>
     <programlisting role='php'>
<![CDATA[
<?php
Reflection::export(new ReflectionClass('Exception'));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Class [ <internal> class Exception ] {

  - Constants [0] {
  }

  - Static properties [0] {
  }

  - Static methods [0] {
  }

  - Properties [6] {
    Property [ <default> protected $message ]
    Property [ <default> private $string ]
    Property [ <default> protected $code ]
    Property [ <default> protected $file ]
    Property [ <default> protected $line ]
    Property [ <default> private $trace ]
  }

  - Methods [9] {
    Method [ <internal> final private method __clone ] {
    }

    Method [ <internal, ctor> public method __construct ] {

      - Parameters [2] {
        Parameter #0 [ <optional> $message ]
        Parameter #1 [ <optional> $code ]
      }
    }

    Method [ <internal> final public method getMessage ] {
    }

    Method [ <internal> final public method getCode ] {
    }

    Method [ <internal> final public method getFile ] {
    }

    Method [ <internal> final public method getLine ] {
    }

    Method [ <internal> final public method getTrace ] {
    }

    Method [ <internal> final public method getTraceAsString ] {
    }

    Method [ <internal> public method __toString ] {
    }
  }
}
]]>
     </screen>
    </example>
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflector">
   <title><classname>Reflector</classname> Arayüzü</title>
   <para>
    <classname>Reflector</classname> arayüzü, tüm ihraç edilebilir yansıtma
    sınıflarınca gerçeklenmiş bir arayüzdür.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
interface Reflector
{
    public string __toString()
    public static string export()
}
?>
]]>
    </programlisting>
   </informalexample>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionexception">
   <title><classname>ReflectionException</classname> Sınıfı</title>
   <para>
    <classname>ReflectionException</classname> sınıfı, yansıtma arayüzü
    tarafından oluşturulmuş olup standard <link
    linkend="language.exceptions">Exception</link> sınıfını genişletir.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionfunction">
   <title><classname>ReflectionFunction</classname> Sınıfı</title>
   <para>
    <classname>ReflectionFunction</classname> sınıfı, işlevler üzerinde
    tersine mühendisliği mümkün kılar.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionFunction extends ReflectionFunctionAbstract implements Reflector
{
    final private __clone()
    public void __construct(string name)
    public string __toString()
    public static string export(string name, bool return)
    public string getName()
    public bool isInternal()
    public bool isDisabled()
    public mixed getClosure() /* PHP 5.3.0 ve sonrası */
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public mixed invoke([mixed args [, ...]])
    public mixed invokeArgs(array args)
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
}
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Ebeveyn <classname>ReflectionFunctionAbstract</classname> sınıfı
    <function>invoke</function>, <function>invokeArgs</function>,
    <function>export</function> ve <function>isDisabled</function> yöntemleri
    hariç aynı yöntemlere sahiptir.
   </para>
   <note>
    <simpara>
     <function>getNumberOfParameters</function> ve
     <function>getNumberOfRequiredParameters</function>, PHP 5.0.3 ile,
     <function>invokeArgs</function> ise PHP 5.1.0 ile eklenmiştir.
    </simpara>
   </note>
   <para>
    Bir işlevi incelemek için önce <classname>ReflectionFunction</classname>
    sınıfının bir örneğini oluşturmalısınız. Yukarıdakı yöntemleri ancak
    böyle bir örnek üzerinden çağırabilirsiniz.
   </para>
   <example>
    <title>- <classname>ReflectionFunction</classname> sınıfının
    kullanımı</title>
    <programlisting role='php'>
<![CDATA[
<?php
/**
 * Basit bir sayaç
 *
 * @return    int
 */
function sayaç()
{
    static $c = 0;
    return $c++;
}

// ReflectionFunction sınıfının bir örneğini oluşturalım
$işlev = new ReflectionFunction('sayaç');

// İşlev hakkında bilgi alalım
printf(
    "===> %s işlevi %s bir işlev olup,\n".
    "     %s dosyasının\n".
    "     %d ve %d satırları arasında tanımlanmıştır.\n",
    $işlev->getName(),
    $işlev->isInternal() ? 'yerleşik' : 'kullanıcı tanımlı',
    $işlev->getFileName(),
    $işlev->getStartLine(),
    $işlev->getEndline()
);

// Belgeleme açıklamalarını alalım
printf("---> Belgeleme:\n %s\n", var_export($işlev->getDocComment(), 1));

// Mevcutsa duruk değişkenleri görelim
if ($statics = $işlev->getStaticVariables())
{
    printf("---> Duruk değişkenler: %s\n", var_export($statics, 1));
}

// İşlevi çağıralım
printf("---> Çağrı sonucu: ");
var_dump($işlev->invoke());


// belki export() yöntemini kullanmak istersiniz
echo "\nReflectionFunction::export() sonuçları:\n";
echo ReflectionFunction::export('sayaç');
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     <function>invoke</function> yöntemi, tıpkı
     <function>call_user_func</function> işlevi gibi değişken sayıda
     değiştirge kabul eder.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionparameter">
   <title><classname>ReflectionParameter</classname> Sınıfı</title>
   <para>
    <classname>ReflectionParameter</classname> sınıfı bir işlev veya yöntemin
    değiştirgeleri hakkında bilgi edinilmesini sağlar.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionParameter implements Reflector
{
    final private __clone()
    public void __construct(string function, string parameter)
    public string __toString()
    public static string export(mixed function, mixed parameter, bool return)
    public string getName()
    public bool isPassedByReference()
    public ReflectionClass getDeclaringClass()
    public ReflectionClass getClass()
    public bool isArray()
    public bool allowsNull()
    public bool isPassedByReference()
    public bool isOptional()
    public bool isDefaultValueAvailable()
    public mixed getDefaultValue()
    public int getPosition()
}
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <para>
     <function>getDefaultValue</function>,
     <function>isDefaultValueAvailable</function> ve
     <function>isOptional</function> PHP 5.0.3, <function>isArray</function>
     PHP 5.1.0, <function>getDeclaringFunction</function> ve
     <function>getPosition</function> ise PHP 5.2.3 sürümünde eklenmiştir.
    </para>
   </note>
   <para>
    Bir işlevin değiştirgelerini incelemek için önce
    <classname>ReflectionFunction</classname> veya
    <classname>ReflectionMethod</classname> sınıfının bir örneğini
    oluşturmalı, sonra da bu sınıfların <function>getParameters</function>
    yöntemini kullanarak değiştirge dizisini almalısınız.
   </para>
   <example>
    <title>- <classname>ReflectionParameter</classname> sınıfının
    kullanımı</title>
    <programlisting role='php'>
<![CDATA[
<?php
function foo($a, $b, $c) { }
function bar(Exception $a, &$b, $c) { }
function baz(ReflectionFunction $a, $b = 1, $c = null) { }
function abc() { }

// ReflectionFunction sınıfının bir örneğini komut
// satırında belirtilen bir değiştirge ile oluşturalım.
$yansıt = new ReflectionFunction($argv[1]);

echo $yansıt;

foreach ($yansıt->getParameters() as $i => $param) {
    printf(
        "-- Değiştirge #%d: %s {\n".
        "   Sınıf: %s\n".
        "   NULL'a izin var: %s\n".
        "   Gönderimli aktarım var: %s\n".
        "   Seçimlik mi?: %s\n".
        "}\n",
        $i, // $param->getPosition() PHP 5.2.3 ve sonrası kullanılır
        $param->getName(),
        var_export($param->getClass(), 1),
        var_export($param->allowsNull(), 1),
        var_export($param->isPassedByReference(), 1),
        $param->isOptional() ? 'evet' : 'hayır'
    );
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionclass">
   <title><classname>ReflectionClass</classname> Sınıfı</title>
   <para>
    <classname>ReflectionClass</classname> sınıfı, sınıflar ve arayüzler
    üzerinde tersine mühendisliği mümkün kılar.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionClass implements Reflector
{
    final private __clone()
    public void __construct(string name)
    public string __toString()
    public static string export(mixed class, bool return)
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public bool isInstantiable()
    public bool hasConstant(string name)
    public bool hasMethod(string name)
    public bool hasProperty(string name)
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public ReflectionMethod getConstructor()
    public ReflectionMethod getMethod(string name)
    public ReflectionMethod[] getMethods()
    public ReflectionProperty getProperty(string name)
    public ReflectionProperty[] getProperties()
    public array getConstants()
    public mixed getConstant(string name)
    public ReflectionClass[] getInterfaces()
    public bool isInterface()
    public bool isAbstract()
    public bool isFinal()
    public int getModifiers()
    public bool isInstance(stdclass object)
    public stdclass newInstance(mixed args)
    public stdclass newInstanceArgs(array args)
    public ReflectionClass getParentClass()
    public bool isSubclassOf(ReflectionClass class)
    public array getStaticProperties()
    public mixed getStaticPropertyValue(string name [, mixed default])
    public void setStaticPropertyValue(string name, mixed value)
    public array getDefaultProperties()
    public bool isIterateable()
    public bool implementsInterface(string name)
    public ReflectionExtension getExtension()
    public string getExtensionName()
}
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     <function>hasConstant</function>, <function>hasMethod</function>,
     <function>hasProperty</function>,
     <function>getStaticPropertyValue</function>
     ve <function>setStaticPropertyValue</function> PHP 5.1.0,
     <function>newInstanceArgs</function> ise PHP 5.1.3 sürümünde eklenmiştir.
    </simpara>
   </note>
   <para>
    Bir sınıfı incelemek için önce <classname>ReflectionClass</classname>
    sınıfının bir örneğini oluşturmalısınız. Yukarıdaki yöntemleri ancak bu
    örnek üzerinden çağırabilirsiniz.
   </para>
   <example>
    <title>- <classname>ReflectionClass</classname> sınıfının kullanımı
    </title>
    <programlisting role='php'>
<![CDATA[
<?php
interface Serileştirilebilir
{
    // ...
}

class Nesne
{
    // ...
}

/**
 * Bir sayaç sınıfı
 */
class Sayaç extends Nesne implements Serileştirilebilir
{
    const START = 0;
    private static $c = Sayaç::START;

    /**
     * Sayacı çağıralım
     *
     * erişim: genel
     * dönen değer: tamsayı
     */
    public function say() {
        return self::$c++;
    }
}

// ReflectionClass sınıfının bir örneğini oluşturalım
$class = new ReflectionClass('Sayaç');

// Temel bilgileri görelim
printf(
    "===> %s%s%s %s '%s' [extends %s]\n" .
    "     %s dosyasının\n" .
    "     %d. ve %d. satırları arasında\n" .
    "     %d [%s] değiştiriciye sahip.\n",
        $class->isInternal() ? 'yerleşik' : 'kullanıcı tanımlı',
        $class->isAbstract() ? ' soyut' : '',
        $class->isFinal() ? ' final' : '',
        $class->isInterface() ? 'arayüz' : 'sınıf',
        $class->getName(),
        var_export($class->getParentClass(), 1),
        $class->getFileName(),
        $class->getStartLine(),
        $class->getEndline(),
        $class->getModifiers(),
        implode(' ', Reflection::getModifierNames($class->getModifiers()))
);

// Belgeleme açıklamalarını görelim
printf("---> Belgeleme:\n %s\n", var_export($class->getDocComment(), 1));

// Bu sınıf tarafından gerçeklenen arayüzleri görelim
printf("---> Gerçeklenenler:\n %s\n", var_export($class->getInterfaces(), 1));

// Sınıf sabitlerini görelim
printf("---> Sabitler: %s\n", var_export($class->getConstants(), 1));

// Sınıf özelliklerini görelim
printf("---> Özellikler: %s\n", var_export($class->getProperties(), 1));

// Sınıf yöntemlerini görelim
printf("---> Yöntemler: %s\n", var_export($class->getMethods(), 1));

// Sınıf örneklenebiliyorsa bir örneğini oluşturalım
if ($class->isInstantiable()) {
    $sayaç = $class->newInstance();

    echo '---> $sayaç bir sınıf örneği mi? ';
    echo $class->isInstance($sayaç) ? 'evet' : 'hayır';

    echo "\n---> new Nesne() bir sınıf örneği mi? ";
    echo $class->isInstance(new Nesne()) ? 'evet' : 'hayır';
    echo "\n";
}
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     <function>newInstance</function> yöntemi, tıpkı
     <function>call_user_func</function> işlevi gibi değişken sayıda
     değiştirge kabul eder.
    </simpara>
   </note>
   <note>
    <simpara>
     <code>$class = new ReflectionClass('Foo');
     $class-&gt;isInstance($arg)</code> ile <code>$arg instanceof Foo</code>
     veya <code>is_a($arg, 'Foo')</code> eşdeğerdir.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionobject">
   <title><classname>ReflectionObject</classname> Sınıfı</title>
   <para>
    <classname>ReflectionObject</classname> sınıfı, nesneler üzerinde tersine
    mühendisliği mümkün kılar.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionObject extends ReflectionClass
{
    final private __clone()
    public void __construct(mixed object)
    public string __toString()
    public static string export(mixed object, bool return)
}
?>
]]>
    </programlisting>
   </informalexample>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionmethod">
   <title><classname>ReflectionMethod</classname> Sınıfı</title>
   <para>
    <classname>ReflectionMethod</classname> sınıfı, yöntemler üzerinde
    tersine mühendisliği mümkün kılar.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionMethod extends ReflectionFunctionAbstract implements Reflector
{
    public void __construct(mixed class, string name)
    public string __toString()
    public static string export(mixed class, string name, bool return)
    public mixed invoke(stdclass object [, mixed args [, ...]])
    public mixed invokeArgs(stdclass object, array args)
    public bool isFinal()
    public bool isAbstract()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isConstructor()
    public bool isDestructor()
    public int getModifiers()
    public mixed getClosure() /* PHP 5.3.0 ve sonrası */
    public ReflectionClass getDeclaringClass()

    // ReflectionFunctionAbstract'tan miras alındı
    final private __clone()
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
}
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Bir yöntemi incelemek için önce <classname>ReflectionMethod</classname>
    sınıfının bir örneğini oluşturmalısınız. Yukarıdaki yöntemleri ancak bu
    örnek üzerinden çağırabilirsiniz.
   </para>
   <example>
    <title>- <classname>ReflectionMethod</classname> sınıfının kullanımı
    </title>
    <programlisting role='php'>
<![CDATA[
<?php
class Sayaç
{
    private static $c = 0;

    /**
     * Artan sayaç
     *
     * final
     * duruk
     * erişim: genel
     * Dönüş değeri: tamsayı
     */
    final public static function say()
    {
        return ++self::$c;
    }
}

// ReflectionMethod sınıfının bir örneğini oluşturalım
$method = new ReflectionMethod('Sayaç', 'say');

// Temel bilgileri alalım
printf(
    "===> %s%s%s%s%s%s%s (%s olarak) '%s' yöntemi\n" .
    "     %s dosyasının\n" .
    "     %d. ve %d. satırları arasında\n" .
    "     %d[%s] değiştirici ile bildirilmiştir.\n",
        $method->isInternal() ? 'Yerleşik' : 'Kullanıcı tanımlı',
        $method->isAbstract() ? ' soyut' : '',
        $method->isFinal() ? ' final' : '',
        $method->isPublic() ? ' genel' : '',
        $method->isPrivate() ? ' özel' : '',
        $method->isProtected() ? ' kormalı' : '',
        $method->isStatic() ? ' duruk' : '',
        $method->isConstructor() ? 'kurucu' : 'sıradan bir yöntem',
        $method->getName(),
        $method->getFileName(),
        $method->getStartLine(),
        $method->getEndline(),
        $method->getModifiers(),
        implode(' ', Reflection::getModifierNames($method->getModifiers()))
);

// Belgeleme açıklamalarını görelim
printf("---> Belgeleme:\n %s\n", var_export($method->getDocComment(), 1));

// Varsa duruk değişkenleri görelim
if ($statics= $method->getStaticVariables()) {
    printf("---> Static variables: %s\n", var_export($statics, 1));
}

// Yöntem çağrısı
printf("---> Çağrı sonuçları: ");
var_dump($method->invoke(NULL));
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>- <classname>ReflectionMethod</classname> sınıfı ile kapanış
    örneği</title>
    <programlisting role='php'>
<![CDATA[
<?php
//Bu örnek PHP 5.3.0 ve sonrasında çalışır

class Example {
    static function printer () {
        echo "Hello World!\n";
    }
}

$class = new ReflectionClass('Example');
$method = $class->getMethod('printer');
$closure = $method->getClosure();
$closure(); // Hello World!

?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Genel, korumalı veya soyut bir yöntemin çağrılması,
     <function>invoke</function> yönteminin oluşturduğu bir istisna ile
     sonuçlanır.
    </simpara>
   </note>
   <note>
    <simpara>
     Yukarıdaki gibi duruk yöntemler için, <function>invoke</function>
     yöntemine ilk değiştirge olarak &null;, duruk olmayan yöntemler için
     ise, sınıfın örneğini aktarmalısınız.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionproperty">
   <title><classname>ReflectionProperty</classname> Sınıfı</title>
   <para>
    <classname>ReflectionProperty</classname> sınıfı, özellikler üzerinde
    tersine mühendisliği mümkün kılar.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionProperty implements Reflector
{
    final private __clone()
    public void __construct(mixed class, string name)
    public string __toString()
    public static string export(mixed class, string name, bool return)
    public string getName()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isDefault()
    public void setAccessible() /* PHP 5.3.0 ve sonrası*/
    public int getModifiers()
    public mixed getValue(stdclass object)
    public void setValue(stdclass object, mixed value)
    public ReflectionClass getDeclaringClass()
    public string getDocComment()
}
?>
]]>
    </programlisting>
   </informalexample>
   <note>
    <simpara>
     <function>getDocComment</function> PHP 5.1.0,
     <function>setAccessible</function> ise PHP 5.3.0 sürümünde eklendi.
    </simpara>
   </note>
   <para>
    Bir özelliği incelemek için önce
    <classname>ReflectionProperty</classname> sınıfının bir örneğini
    oluşturmalısınız. Yukarıdaki yöntemleri ancak bu örnek üzerinden
    çağırabilirsiniz.
   </para>
   <example>
    <title>- <classname>ReflectionProperty</classname> sınıfının kullanımı
    </title>
    <programlisting role='php'>
<![CDATA[
<?php
class Dizge
{
    public $uzunluk  = 5;
}

// ReflectionProperty sınıfının bir örneğini oluşturalım
$prop = new ReflectionProperty('Dizge', 'uzunluk');

// Temel bilgileri görelim
printf(
    "===> %s%s%s%s özellik '%s' (derleme anında %s)\n" .
    "     %s değiştiricilere sahiptir.\n",
        $prop->isPublic() ? 'Genel' : '',
        $prop->isPrivate() ? 'Özel' : '',
        $prop->isProtected() ? 'Korumalı' : '',
        $prop->isStatic() ? ' static' : '',
        $prop->getName(),
        $prop->isDefault() ? 'bildirilen' : 'oluşturulan',
        var_export(Reflection::getModifierNames($prop->getModifiers()), 1)
);

// Dizge'nin bir örneğini oluşturalım
$nesne= new Dizge();

// Mevcut değeri görelim
printf("---> Değeri: ");
var_dump($prop->getValue($nesne));

// Değeri değiştirelim
$prop->setValue($nesne, 10);
printf("---> Değer 10 yapıldı, yeni değer:: ");
var_dump($prop->getValue($nesne));

// Nesneyi dökümleyelim
var_dump($nesne);
?>
]]>
    </programlisting>
   </example>
   <example>
    <title>- <classname>ReflectionProperty</classname> sınıfı ile özel ve
    korumalı özelliklerden değer istemek</title>
    <programlisting role='php'>
<![CDATA[
<?php

class Foo {
    public $x = 1;
    protected $y = 2;
    private $z = 3;
}

$obj = new Foo;

$prop = new ReflectionProperty('Foo', 'y');
$prop->setAccessible(true);                 /* PHP 5.3.0 ve sonrası */
var_dump($prop->getValue($obj)); // int(2)

$prop = new ReflectionProperty('Foo', 'z');
$prop->setAccessible(true);                 /* PHP 5.3.0 ve sonrası */
var_dump($prop->getValue($obj)); // int(2)

?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
      Özel veya korumalı bir sınıf özelliğinin değerini alma veya atama
      girişimi bir istisna oluşması ile sonuçlanır.
    </simpara>
   </note>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.reflectionextension">
   <title><classname>ReflectionExtension</classname> Sınıfı</title>
   <para>
    <classname>ReflectionExtension</classname> sınıfı, eklentiler üzerinde
    tersine mühendisliği mümkün kılar. Yüklü eklentilerin tümünü çalışma
    anında <function>get_loaded_extensions</function> işlevini kullanarak
    öğrenebilirsiniz.
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class ReflectionExtension implements Reflector {
    final private __clone()
    public void __construct(string name)
    public string __toString()
    public static string export(string name, bool return)
    public string getName()
    public string getVersion()
    public ReflectionFunction[] getFunctions()
    public array getConstants()
    public array getINIEntries()
    public ReflectionClass[] getClasses()
    public array getClassNames()
    public string info()
}
?>
]]>
    </programlisting>
   </informalexample>
   <para>
    Bir eklentiyi incelemek için önce
    <classname>ReflectionExtension</classname> sınıfının bir örneğini
    oluşturmalısınız. Yukarıdaki yöntemleri ancak bu örnek üzerinden
    çağırabilirsiniz.
   </para>
   <example>
    <title>- <classname>ReflectionExtension</classname> sınıfının kullanımı
    </title>
    <programlisting role='php'>
<![CDATA[
<?php
// ReflectionExtension sınıfının bir örneğini oluşturalım
$ext = new ReflectionExtension('standard');

// Temel bilgileri görelim
printf(
    "Eklenti ismi  : %s\n" .
    "Sürüm         : %s\n" .
    "İşlevler      : [%d] %s\n" .
    "Sabitler      : [%d] %s\n" .
    "INI girdileri : [%d] %s\n" .
    "Sınıflar      : [%d] %s\n",
        $ext->getName(),
        $ext->getVersion() ? $ext->getVersion() : 'SÜRÜM_YOK',
        sizeof($ext->getFunctions()),
        var_export($ext->getFunctions(), 1),

        sizeof($ext->getConstants()),
        var_export($ext->getConstants(), 1),

        sizeof($ext->getINIEntries()),
        var_export($ext->getINIEntries(), 1),

        sizeof($ext->getClassNames()),
        var_export($ext->getClassNames(), 1)
);
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.reflection.extending">
   <title>Yansıtma Sınıflarının Genişletilmesi</title>
   <para>
    Yerleşik sınıfların özelleştirilmiş sürümlerini oluşturmak istediğiniz
    takdirde (yöntemler yerine üye değişkenlere kolayca erişmek veya aracı
    yöntemlere sahip olmak ya da renkli HTML sürümünü oluşturmak
    istiyorsunuz diyelim), baştan sona hepsini genişletebilirsiniz.
   </para>
   <example>
    <title>- Yerleşik sınıfların genişletilmesi</title>
    <programlisting role='php'>
<![CDATA[
<?php
/**
 * Kendi Reflection_Method sınıfımız
 */
class My_Reflection_Method extends ReflectionMethod
{
    public $visibility = array();

    public function __construct($o, $m)
    {
        parent::__construct($o, $m);
        $this->visibility = Reflection::getModifierNames($this->getModifiers());
    }
}

/**
 * Sınıf denemesi 1
 *
 */
class T {
    protected function x() {}
}

/**
 * Sınıf denemesi 2
 *
 */
class U extends T {
    function x() {}
}

// Bilgiler görelim
var_dump(new My_Reflection_Method('U', 'x'));
?>
]]>
    </programlisting>
   </example>
   <note>
    <simpara>
     Dikkat: Kurucunun üzerine yazıyorsanız, herhangi bir kod yazmadan
     _önce_ ebeveynin kurucusunu çağırmayı unutmayın. Bunu yapmazsanız şöyle
     bir sonuç alırsınız:
     <literal>
      Fatal error: Internal error: Failed to retrieve the reflection object
     </literal> Türkçesi: Ölümcül hata: Dahili hata: reflection nesnesi
     alınamadı
    </simpara>
   </note>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
