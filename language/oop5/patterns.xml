<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.3 $ -->
<!-- $Header: /home/svn/phpsvn_tmp/cvsrepo/phpdoc/tr/language/oop5/patterns.xml,v 1.3 2008-01-11 08:53:45 sezer Exp $ -->
<sect1 xml:id="language.oop5.patterns" xmlns="http://docbook.org/ns/docbook">
 <title>Modeller (Patterns)</title>
 <para>
  Modeller, en iyi uygulamalari ve dogru tasarimlari betimleme yöntemidir.
  Modeller ile genel programlama sorunlarina esnek çözümler aranmaktadir.
 </para>

 <sect2 xml:id="language.oop5.patterns.factory">
  <title>Factory</title>
  <para>
  Factory modeli, çalisma zamaninda (runtime) nesnelerin yaratilmasini saglar.
  Factory modeli olarak adlandirilmasinin sebebi, nesnenin "üretiminden" sorumlu
  olmasidir. Parametrelendirilmis Factory, sinifin ismini argüman olarak alarak
  nesneyi olusturur.
  </para>
  <example>
   <title>Parametrelendirilmis Factory Metodu</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    // Parametrelendirilmis factory metodu
    public static function factory($type)
    {
        if (include_once 'Drivers/' . $type . '.php') {
            $classname = 'Driver_' . $type;
            return new $classname;
        } else {
            throw new Exception ('Sürücü bulunamadi');
        }
    }
}
?>
]]>
   </programlisting>
   <para>
   Bir sinif içerisinde bu metod tanimlanarak, sürücülerin çalisma esnasinda
   yüklenmesi saglanir. <literal>Example</literal> sinifi bir veritabani soyutlama
   sinifi (database abstraction class) olsaydi, <literal>MySQL</literal> ve
   <literal>SQLite</literal> sürücülerinin yüklenmesi islemi asagidaki biçimde
   yapilabilirdi:
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// MySQL sürücüsünü yükle
$mysql = Example::factory('MySQL');

// SQLite sürücüsünü yükle
$sqlite = Example::factory('SQLite');
?>
]]>
   </programlisting>
  </example>
 </sect2>

 <sect2 xml:id="language.oop5.patterns.singleton">
  <title>Singleton</title>
  <para>
  Singleton modeli, bir sinifin tek bir örnegine ihtiyaç duyuldugu durumlarda
  uygulanir. Bu duruma en genel örnek, veritabani baglantisidir. Bu model kullanilarak,
  tek bir örnegin baska birçok nesne tarafindan erisilebilir olmasi saglanabilir.
  </para>
  <example>
   <title>Singleton Fonksiyonu</title>
   <programlisting role="php">
<![CDATA[
<?php
class Example
{
    // Sinifin bir örnegini tasir
    private static $instance;
    
    // Private olarak tanimlanmis bir ilklendirici, nesnenin direk olarak yaratilmasini engeller
    private function __construct() 
    {
        echo 'Ilklendirildim';
    }

    // Singleton metodu
    public static function singleton() 
    {
        if (!isset(self::$instance)) {
            $c = __CLASS__;
            self::$instance = new $c;
        }

        return self::$instance;
    }
    
    // Örnek method
    public function bark()
    {
        echo 'Woof!';
    }

    // Kullanicilarin örnegi klonlamasini engelle
    public function __clone()
    {
        trigger_error('Klon yaratilmasina izin verilmez.', E_USER_ERROR);
    }

}

?>
]]>
   </programlisting>
   <para>
   Asagidaki örnek <literal>Example</literal> sinifi için tek bir örnek
   alinmasini saglar.
   </para>
   <programlisting role="php">
<![CDATA[
<?php
// Bu islem basarisiz olur çünkü ilklendirici private olarak tanimlandi
$test = new Example;

// Bu islem her zaman sinifa ait tek bir örnek verir
$test = Example::singleton();
$test->bark();

// Bu bir E_USER_ERROR mesaji olusturur.
$test_clone = clone($test);

?>
]]>
   </programlisting>
  </example>
 </sect2>

</sect1>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
