<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.5 $ -->
<!-- EN-Revision: 1.20 Maintainer: nilgun Status: ready -->
<!-- CREDITS: tpug, sezer -->
 <sect1 xml:id="language.oop5.magic" xmlns="http://docbook.org/ns/docbook">
  <title>Sihirli Yöntemler</title>
  <para>
   <literal>__construct</literal>, <literal>__destruct</literal>
   (bak: <link linkend="language.oop5.decon">Kurucular ve Yıkıcılar</link>),
   <literal>__call</literal>, <literal>__callStatic</literal>,
   <literal>__get</literal>, <literal>__set</literal>,
   <literal>__isset</literal>, <literal>__unset</literal>
   (bak: <link linkend="language.oop5.overloading">Aşırı yükleme</link>),
   <literal>__sleep</literal>, <literal>__wakeup</literal>,
   <literal>__toString</literal>, <literal>__set_state</literal> ve
   <link linkend="language.oop5.cloning">__clone</link> işlev isimleri PHP
   sınıflarında sihirli işlemler yaparlar. İşlevlerinize sihirli bir
   işlevsellik kazandırmak istemedikçe bu isimleri sınıfınızın içinde işlev
   ismi olarak kullanamazsınız.
  </para>

  <caution>
   <simpara>
   PHP, __ ile baslayan tüm işlev isimlerini sihirli işlevlere ayırmıştır.
   Belgelenmiş bir kaç sihirli işlevsellik dışında __ ile başlayan işlev
   isimleri kullanmamanızı öneririz.
   </simpara>
  </caution>

  <sect2 xml:id="language.oop5.magic.sleep">
   <title><code>__sleep</code> ve <code>__wakeup</code></title>
   <para>
    <function>serialize</function> işlevi, sınıfınızın <code>__sleep</code>
    adında sihirli bir işleve sahip olup olmadığına bakar. Böyle bir işlev
    varsa herhangi bir serileştirme işleminden önce bu işlev çalıştırılır.
    Bu işlev ile nesne üzerinde temizlik yapabilir ve serileştirilmesi
    gereken nesnenin tüm değişken isimlerinin bir dizi halinde döndürülmesini
    sağlayabilirsiniz. Eğer işlev hiçbir şey döndürmemişse &null;
    serileştirilir ve bir E_NOTICE çıktılanır.
   </para>
   <para>
    <code>__sleep</code> işlevinin asıl kullanım amacı askıdaki veriyi
    göndermek gibi temizliğe benzer işlemler yapmaktır. Ayrıca, tümüyle
    kaydedilmesi gerekmeyen büyük veri parçaları sözkonusu olduğunda da bu
    işlevden yararlanabilirsiniz.
   </para>
   <para>
    <function>unserialize</function> işlevi tersine bir işlem yaparak
    <code>__wakeup</code> adında bir sihirli işlevin varlığını araştırır.
    Böyle bir işlev varsa, bu işlev nesnenin sahip olduğu tüm özkaynakları
    yeniden oluşturabilir.
   </para>
   <para>
    <code>__wakeup</code> işlevinin asıl kullanım amacı, serileştirme
    sırasında kaybedilebilen veritabanı bağlantılarını yeniden oluşturmak ve
    diğer ilklendirme işlemlerini yeniden yapmaktır.
   </para>
   <example>
    <title>- Uyutma ve uyandırma</title>
    <programlisting role="php">
<![CDATA[
<?php
class Bağlantı {
    protected $hat;
    private $sunucu, $kullanıcı, $parola, $db;

    public function __construct($sunucu, $kullanıcı, $parola, $db)
    {
        $this->sunucu = $sunucu;
        $this->kullanıcı = $kullanıcı;
        $this->parola = $parola;
        $this->db = $db;
        $this->connect();
    }

    private function bağlan()
    {
        $this->hat = mysql_connect($this->sunucu, $this->kullanıcı, $this->parola);
        mysql_select_db($this->db, $this->hat);
    }

    public function __sleep()
    {
        mysql_close($this->hat);
    }

    public function __wakeup()
    {
        $this->bağlan();
    }
}
?>
]]>
    </programlisting>
   </example>
  </sect2>

  <sect2 xml:id="language.oop5.magic.tostring">
   <title><code>__toString</code></title>
   <para>
    <code>__toString</code> yöntemi, sınıf bir dizgeye dönüştürüldüğünde
    sınıfın nasıl tepki vereceğine karar vermeyi sağlar.
   </para>
   <example>
    <title>- Basit bir örnek</title>
    <programlisting role="php">
<![CDATA[
<?php
// Basit bir sınıf tanımlayalım
class TestClass
{
    public $foo;

    public function __construct($foo) {
        $this->foo = $foo;
    }

    public function __toString() {
        return $this->foo;
    }
}

$class = new TestClass('Merhaba');
echo $class;
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Merhaba
]]>
    </screen>
   </example>
   <para>
    PHP 5.2.0'dan önce <code>__toString</code> yönteminin, doğrudan
    <function>echo</function> ya da <function>print</function> işlevleri ile
    birlikte çağrılmadıkça bir önemi yoktu. PHP 5.2.0'dan beri sadece dizge
    bağlamlarında (<code>%s</code> değiştiricili <function>printf</function>
    gibi) çağrılabilmekte, diğer bağlamlarda (<code>%d</code> değiştiricili
    <function>printf</function> gibi) çağrılamamaktadır. PHP 5.2.0'dan beri
    nesneleri <code>__toString</code> yöntemi olmaksızın dizgeye dönüştürme
    işlemi <constant>E_RECOVERABLE_ERROR</constant> hatasına yol açmaktadır.
   </para>
  </sect2>

  <sect2 xml:id="language.oop5.magic.set-state">
   <title><code>__set_state</code></title>
   <para>
    Bu <link linkend="language.oop5.static">duruk</link> yöntem, PHP 5.1.0
    sürümünden beri <function>var_export</function> tarafından ihraç edilen
    sınıflar için çağrılmaktadır.
   </para>
   <para>
    Bu yöntemin tek değiştirgesi <code>array('özellik' => değer, ...)</code>
    biçeminde ihraç edilen özellikleri içeren bir dizidir.
   </para>
   <example>
    <title>- <code>__set_state</code> kullanımı (PHP 5.1.0 ve sonrası)</title>
    <programlisting role="php">
<![CDATA[
<?php

class A
{
    public $var1;
    public $var2;

    public static function __set_state($bir_dizi) // PHP 5.1.0'dan beri
    {
        $obj = new A;
        $obj->var1 = $bir_dizi['var1'];
        $obj->var2 = $bir_dizi['var2'];
        return $obj;
    }
}

$a = new A;
$a->var1 = 5;
$a->var2 = 'foo';

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var1' => 5,
                                            //    'var2' => 'foo',
                                            // ));
var_dump($b);

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(A)#2 (2) {
  ["var1"]=>
  int(5)
  ["var2"]=>
  string(3) "foo"
}
]]>
    </screen>
   </example>
  </sect2>
 </sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
