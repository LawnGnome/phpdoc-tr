<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.7 $ -->
<!-- EN-Revision: 1.31 Maintainer: tpug Status: ready -->
<!-- CREDITS: Serdar Soydemir, Sezer Yalçın -->
<!-- Last translator: Nilgün Belma Bugüner -->
 <chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
   <title>İfadeler</title>
   <simpara>
    İfadeler, PHP'nin en önemli yapı taşlarındandır. PHP'de, hemen hemen
    yazdığınız her şey bir ifadedir. Bir ifadenin en basit ama en etkili
    tanımı şudur: "Bir değere sahip olan herşey".
   </simpara>
   <simpara>
    İfadelerin en basit şekli sabitler ve değişkenlerdir. "$a = 5"
    yazdığınızda, '5' değerini $a değişkenine atamış olursunuz. '5', açık bir
    şekilde, 5 değerine sahiptir, ya da başka bir deyişle '5', değeri 5 olan
    bir ifadedir (bu durumda, '5' bir tamsayı sabittir).
   </simpara>
   <simpara>
    Bu atamadan sonra, $a'nın değerinin 5 olmasını beklersiniz, dolayısıyla
    $b = $a yazdığınızda, bunun $b = 5 yazmışsınız gibi davranmasını
    beklersiniz. Başka bir deyişle, $a da değeri 5 olan ifadedir. Her şey
    doğru çalışırsa, olması gereken de tam budur.
   </simpara>
   <para>
    İşlevler, ifadelerin biraz daha karmaşık örnekleridir. Örneğin, aşağıdaki
    işleve bakalım:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    İşlev kavramına aşina iseniz (değilseniz, <link
    linkend="language.functions" >işlevler</link> bölümünü
    inceleyebilirsiniz), su örnekten hareketle <literal>$c = foo()</literal>
    yazmak ile <literal>$c = 5</literal> yazmak arasında bir fark olmadığını
    bilirsiniz. İşlevler, değeri dönüş değeri olan ifadelerdir.
    <literal>foo()</literal> işlevi 5 değerini döndürdüğünden, 'foo()'
    ifadesinin değeri 5'tir. İşlevlerin amacı normalde duruk bir değer
    döndürmek değildir, bir hesaplamanın sonucunu döndürürler.
   </simpara>
   <simpara>
    Elbette, PHP'deki değerlerin hep tamsayılar olması gerekmez, zaten
    çoğunlukla değildirler. PHP dört çeşit sayıl değer destekler: Tamsayı
    (<type>integer</type>) değerler, kayan noktalı (<type>float</type>)
    değerler, dizge (<type>string</type>) değerler ve mantıksal
    <type>boolean</type> değerler (sayıl değerler, dizilerin aksine daha
    küçük parçalara bölemeyeceğiniz değerlerdir). PHP ayrıca iki bileşik
    (sayıl olmayan) tür destekler: Diziler ve nesneler. Bu değer türlerinden
    her biri bir değişkene atanabilir ya da bir işlevden döndürülebilir.
   </simpara>
   <simpara>
    PHP, birçok başka dilin yaptığı gibi ifadeleri çok ileriye götürmüştür.
    PHP ifade-yönelimli bir dildir, bunun sebebi hemen hemen her şeyin bir
    ifade olmasıdır. Az önce üzerinde çalıştığımız '$a = 5' örneğini ele
    alalım. Burada iki değer kullanımı sözkonusudur, bir tamsayı sabit olan
    '5' ve 5 olarak değiştirilmiş $a'nın değeri. Ancak gerçek şu ki, burada
    bu ikiliye ek olarak başka bir değer daha vardır, o da atamanın kendi
    değeridir. Atamanın kendisi atanan değerle değerlendirilir, bu örnekte bu
    5'tir. Uygulamada, ne yaptığından bağımsız olarak '$a = 5', değeri 5 olan
    bir ifadedir. Böylece, '$b = ($a = 5)' yazmak, '$a = 5; $b = 5;' yazmak
    gibidir (noktalı virgül deyimin sonlandırıldığını gösterir). Atamalar
    sağdan sola doğru işlendiğinden, '$b = $a = 5' de yazabilirsiniz.
   </simpara>
   <simpara>
    İfade yönelimi ile ilgili diğer güzel bir örnek atama öncesi ve sonrası
    arttırma ve eksiltme işlemleridir. PHP ve diğer birçok dilin
    kullanıcıları, değişken++ ve değişken-- gösterimine az çok aşinadır.
    Bunlar <link linkend="language.operators.increment">arttırma ve eksiltme
    işleçleri</link>dir. PHP/FI 2'de, '$a++' deyiminin bir değeri yoktur (bir
    ifade değildir), bu yüzden onu atayamaz ya da herhangi bir yerde
    kullanamazsınız. PHP, arttırma/eksiltme ifadelerinin yeteneklerini, bu
    ifadeleri C dilindekine benzer şekilde iyileştirerek genişletmiştir.
    PHP'de, C'de olduğu gibi önceden arttırma ve sonradan arttırma diye iki
    tür arttırma vardır. Bunların her ikisi de değişkenin değerini bir
    arttırır ve değişken üzerindeki etkileri aynıdır. Fark, arttırma
    ifadesinin değerindedir. Önceden arttırma, '++$değişken' olarak yazılır
    ve arttırılmış değer öncelik alır (PHP değişkenin değerini önce arttırır,
    sonra okur, bu sebeple önceden arttırma ismi verilmiştir). Sonradan
    arttırma ise, '$değişken++' olarak yazılır ve değer arttırılmadan önceki
    özgün değer önceliklidir (PHP değişkenin değerini okuduktan sonra
    değerini arttırır, bu sebeple sonradan arttırma ismi verilmiştir).
   </simpara>
   <simpara>
    Çok geniş bir kullanıma sahip olan ifade türlerinden birisi de <link
    linkend= "language.operators.comparison">karşılaştırma</link>
    ifadeleridir. Bu ifadeler &false; ya da &true; değerlerinden birini
    alırlar. PHP &gt; (büyüktür), &gt;= (büyüktür ya da eşittir), ==
    (eşittir), != (eşit değildir), &lt; (küçüktür) ve &lt;= (küçüktür ya da
    eşittir) gösterimlerini destekler. Dil aynı zamanda aynılık işleçlerini
    de destekler: === (eşit ve aynı türdedir) ve !== (ne eşit ne de aynı
    türdedir). Bu ifadeler çoğunlukla <literal>if</literal> deyimleri gibi
    koşula bağlı işlemlerde kullanılmaktadırlar.
   </simpara>
   <simpara>
    Vereceğimiz son ifade örneği işleçli atama ifadeleridir. $a'nın değerini
    1 arttırmak istediğinizde, basitçe '$a++' ya da '++$a' yazmanızın yeterli
    olduğunu zaten biliyorsunuz. Ama ya birden daha büyük bir değer, örneğin
    3 eklemek isterseniz? '$a++' ifadesini birkaç kez yazabilirsiniz, ama
    bunun pek verimli ya da kullanışlı yöntem olmadığı oldukça açık. '$a = $a
    + 3' çok daha yaygın bir kullanımdır. '$a + 3' ifadesi $a'nın değerini
    önce 3 arttırır sonra sonucu $a'ya atar, böylece $a'nın değeri 3
    arttırılmış olur. PHP'de, birkaç dilde olduğu gibi C benzeri, daha temiz
    gözükecek ve daha kısa biçimde yazabileceğiniz bir gösterim daha vardır.
    $a'nın mevcut değerine 3 ekleme işlemi '$a += 3' biçiminde yazılabilir.
    Bunun anlamı tam olarak "$a'nın değerini al, 3 ekle ve yeni değeri $a'ya
    ata" olacaktır. Daha kısa ve temiz olmasının yanında, bu kod daha hızlı
    çalıştırılacaktır. '$a += 3' işleminin değeri, normal bir atama işleminde
    olduğu gibi, atanan değerdir. Bu değerin 3 OLMADIĞINA dikkat edin, bu
    değer $a ile 3'ün toplamıdır ($a’ya bu değer atanır). İşleçli atama
    kipinde herhangi bir iki terimli işleç kullanılabilir, örneğin '$a -= 5'
    ($a'nın değerinden 5 çıkarılır), '$b *= 7' ($b'nin değeri 7 ile
    çarpılır), vs.
   </simpara>
   <para>
    Diğer dillerde görmediyseniz size farklı gözükebilecek bir ifade daha
    vardır, o da üç terimli koşul işlecidir:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$birinci ? $ikinci : $üçüncü
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    İlk alt ifadenin değeri &true; (sıfırdan farklı) ise, ikinci alt ifade
    değerlendirilir ve koşullu ifadenin sonucu bu olur. Aksi takdirde, üçüncü
    alt ifade değerlendirilir ve koşullu ifadenin sonucu bu olur.
   </para>
   <para>
    Aşağıdaki örnek, önceden ve sonradan arttırma işleçlerini ve ifadelerini
    genelde biraz daha iyi anlamanıza yardımcı olacaktır:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;    /* beş değerini $a ve $b değişkenlerine atar */
$c = $a++;      /* sonradan arttırma, $a'nın özgün değerini (5) $c'ye atar */
$e = $d = ++$b; /* önceden arttırma, $b'nin arttırılmış değerini (6) $d
                   ve $e'ye atar */

/* bu noktada, $d ve $e 6'ya eşittir */

$f = double($d++);  /* $d'nin değerini arttırmadan önce $d'nin değerinin iki
                       katını $f'ye atar,  2*6 = 12 */
$g = double(++$e);  /* $e'nin değerini arttırdıktan sonra iki katını alıp
                       $g'ye atar,  2*7 = 14 */
$h = $g += 10;      /* önce, $g 10 arttırılır ve değeri 24 olur. Sonra bu
                       değer (24) $h'ye atanır ve onun da değeri 24 olur. */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    Bazı ifadeler deyim olarak ele alınabilir. Bu durumda, deyim 'ifade' ';'
    şeklinde, noktalı virgülle sonlandırılmış bir ifade şeklinde olacaktır.
    '$=$a=5;' olduğunda, $a=5 geçerli bir ifadedir, ancak kendi başına bir
    deyim değildir. '$b=$a=5;' ise geçerli bir deyimdir.
   </simpara>
   <simpara>
    Son olarak bahsetmemiz gereken bir konu da ifadelerin gerçek değeridir.
    Birçok olayda, çoğunlukla da koşula bağlı çalışmalarda ve döngülerde,
    ifadenin kendi değeri ile değil, &true; ya da &false; olması ile
    ilgileniyor olacaksınız.

    <!-- (PHP doesn't have a
    dedicated boolean type) : WRONG, PHP does. -->

    &true; ve &false; sabitleri (büyük-küçük harf duyarsız) olası iki
    mantıksal değerdir. Gerektiğinde, bir ifade özdevinimli olarak mantıksal
    değere dönüştürülür. <link linkend="language.types.typecasting">Tür
    çarpıtma</link> bölümünde bunun nasıl gerçekleştiği ayrıntılı olarak
    anlatılmıştır.
   </simpara>
   <simpara>
    PHP ifadeleri tümüyle ve çok güçlü bir biçimde uygulamaya geçirmiştir ve
    bunların tamamını belgelemek bu kılavuzun kapsamının dışında kalır.
    Yukarıdaki örnekler hangi ifadelerle nasıl kullanışlı ifadeler
    oluşturabileceğiniz hakkında yeterli fikir verecektir. Bu kılavuzun
    geri kalanında, geçerli herhangi bir PHP ifadesini belirtmek için
   <varname>ifade</varname> sözcüğünü kullanacağız.
   </simpara>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
