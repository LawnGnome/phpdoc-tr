<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.5 $ -->
<!-- $Header: /home/svn/phpsvn_tmp/cvsrepo/phpdoc/tr/language/expressions.xml,v 1.5 2008-01-11 08:02:21 sezer Exp $ -->
 <chapter xml:id="language.expressions" xmlns="http://docbook.org/ns/docbook">
   <title>ıfadeler (Expressions)</title>
   <simpara>
  İfadeler, PHP'nin en önemli yapıtaşlarıdır. PHP'de, hemen hemen yazdığınız
   her şey bir ifadedir. Bir ifadenin en basit ama en etkili tanımı şudur:
   "Değeri olan her şey".
   </simpara>
   <simpara>
  İfadelerin en basit şekli değişmezler ve değişkenlerdir. "$a = 5" yazdığınızda,
   '5' değerini $a değişkenine atamış olursunuz. '5', açık bir şekilde, 5 değerine
   sahiptir, ya da başka bir deyişle '5', 5 değerini taşıyan bir ifadedir (bu durumda,
   '5' tamsayı bir değişmezdir).
   </simpara>
   <simpara>
   Bu atamadan sonra, $a'nın değerinin 5 olmasını beklersiniz, dolayısıyla $b = $a yazdığınızda,
   bunun $b = 5 yazmışsınız gibi davranmasını beklersiniz. Başka bir deyişle, $a da 5 değerini
   taşıyan bir ifadedir. Her şey doğru çalıştıysa, olması gereken tam olarak budur.
   </simpara>
   <para>
   Fonksiyonlar, ifadelerin biraz daha karmaşık örnekleri olarak gösterilebilir. Örneğin, aşağıdaki
   fonksiyona bakalım:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function foo ()
{
    return 5;
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Fonksiyon kavramına aşina iseniz (aşina değilseniz,
   <link linkend="language.functions">fonksiyonlar</link> bölümünü
   inceleyebilirsiniz), <literal>$c = foo()</literal> yazmak ile
   <literal>$c = 5</literal> yazmak arasında bir fark olmadığını bilirsiniz.
   Fonksiyonlar, kendilerinden dönen değeri taşıyan ifadelerdir. foo() 5 döndürdüğünden,
   'foo()' ifadesinin değeri 5'tir. Genellikle fonksiyonlar durağan bir değer taşımazlar,
   bir hesaplamanın sonucunu taşırlar.
   </simpara>
   <simpara>
   Elbette, PHP'deki değerlerin tamsayı olması gerekmez, ve çoğunlukla değildirler.
   PHP 4 tip sayıl değeri destekler: <type>integer (tamsayı)</type> değerler,
   kayan noktalı (<type>float</type>) değerler, <type>string (karakter dizisi)</type>
   değerler ve <type>boolean</type> değerler (sayıl değerler, diziler gibi yapıların aksine daha küçük parçalara
   bölemeyeceğiniz değerlerdir). PHP ayrıca iki karma (sayıl olmayan) tipi destekler: diziler (arrays) ve
   nesneler (objects). Bu tiplerden her biri bir değişkene atanabilir ya da bir fonksiyondan döndürülebilir.
   </simpara>
   <simpara>
   PHP, birçok başka dilin yaptığı gibi ifadeleri çok ileriye götürmüştür.
   PHP ifade-yönelimli bir dildir, bunun sebebi hemen hemen her şeyin bir ifade olmasıdır.
   Az önce üzerinde çalıştığımız '$a = 5' örneğini ele alalım. Burada iki değişkenin
   kullanımı sözkonusudur, tamsayı değişmez olan '5' ve 5 olarak güncellenmiş $a'nın değeri.
   Ancak gerçek şu ki, burada bu ikiliye ek olarak başka bir değer daha vardır, o da atamanın
   kendi değeridir. Atamanın kendisi de atanan değeri işletir, bu örnekte bu 5'tir.
   Pratikte, ne yaptığından bağımsız olarak '$a = 5', 5 değerini taşıyan bir ifadedir.
   Böylece, '$b = ($a = 5)' yazmak, '$a = 5; $b = 5;' yazmak gibi olur (noktalı virgül deyimin
   sonlandırıldığını gösterir). Atamalar sağdan sola doğru işlendiğinden, '$b = $a = 5' de yazabilirsiniz.
   </simpara>
   <simpara>
  İfade yönelimi ile ilgili diğer güzel bir örnek ön ve son arttırma ve eksiltme işlemleridir.
   PHP ve diğer birçok dilin kullanıcıları, değişken++ ve değişken-- kullanımı ile az çok aşinadır.
   Bunlar <link linkend="language.operators.increment">arttırma ve eksiltme operatörleri</link>dir.
   PHP/FI 2'de, '$a++' işleminin bir değeri yoktur (bir ifade değildir), bu yüzden bu işlemi
   atayamaz ya da hiçbir şekilde kullanamazsınız. PHP, arttırma/eksiltme ifadelerinin kalitesini,
   bu ifadeleri C dilindekine benzer şekilde iyileştirerek yükseltmiştir. PHP'de, C'de olduğu gibi
   iki tür arttırma vardır - ön arttırma ve son arttırma. Bunların her ikisi de değişkenin değerini
   arttırır ve değişken üzerindeki etkileri aynıdır. Fark, arttırma ifadesinin değerindedir.
   Ön arttırma, '++$variable' olarak yazılır, arttırılan değere doğru çalışır (PHP değişkenin değerini,
   mevcut değerini okumadan önce arttırır, bu sebeple ön arttırma ismi verilmiştir). Son arttırma,
   '$variable++' olarak yazılır, değer arttırılmadan önceki özgün değerle çalışır (PHP değişkenin değerini,
   mevcut değeri okuduktan sonra arttırır, bu sebeple son arttırma ismi verilmiştir).
   </simpara>
   <simpara>
   Çok geniş bir kullanıma sahip olan ifade tiplerinden birisi <link
    linkend= "language.operators.comparison">karşılaştırma</link> ifadeleridir.
    Bu ifadeler &false; ya da &true; değerlerinden birini alırlar. PHP
    &gt; (büyüktür), &gt;= (büyüktür ya da eşittir), == (eşittir),
    != (eşit değildir), &lt; (küçüktür) ve &lt;= (küçüktür ya da eşittir) kullanımlarını
    destekler. Dil aynı zamanda katı eşitlik operatörlerini de destekler:
    === (eşittir ve aynı tiptedir) ve !== (eşit değildir ya da aynı tipte değildir).
    Bu ifadeler çoğunlukla <literal>if</literal> deyimleri gibi koşula bağlı işlemlerde
    kullanılmaktadırlar.
   </simpara>
   <simpara>
   Vereceğimiz son ifade örneği operatör-atama ifadeleri ile birleşiktir.
   $a'nın değerini 1 arttırmak istediğinizde, basitçe '$a++' ya da '++$a'
   yazmanızın yeterli olduğunu zaten biliyorsunuz. Ama ya birden
   fazla bir değer eklemek istiyorsanız, mesela 3? '$a++' ifadesini
   birkaç kez yazabilirsiniz, ama bunun en verimli ya da kullanışlı yöntem
   olmadığı oldukça açık. '$a = $a + 3' çok daha yaygın bir kullanımdır.
   '$a + 3' $a'nın değerini 3 arttırır ve bu değeri $a'ya geri atar,
   böylece $a'nın değeri 3 arttırılmış olur. PHP'de, C benzeri birkaç
   dilde olduğu gibi, bunu daha temiz gözükecek ve daha kısa biçimde
   yazabileceğiniz bir kullanım daha vardır. $a'nın mevcut değerine
   3 ekleme işlemi '$a += 3' biçiminde yazılabilir. Bunun anlamı tam olarak
   "$a'nın değerini al, 3 ekle, ve yeni değeri $a'ya geri ata" olacaktır.
   Daha kısa ve temiz olmasının yanında, bu kod daha hızlı çalıştırılacaktır.
   '$a += 3' işleminin değeri, normal bir atama işleminde olduğu gibi,
   atanan değerdir. Bu değerin 3 OLMADIĞINA dikkat edin, bu değer
   $a artı 3'ün değerlerinin birleşimidir (bu $a'ya atanan değerdir).
   Bu operatör-atama modunda herhangi bir iki kademeli operatör kullanılabilir,
   '$a -= 5' gibi ($a'nın değerinden 5 çıkar) ya da '$b *= 7 gibi ($b'nin değerini
   7 ile çarp).
   </simpara>
   <para>
   Başka bir dilde görmediyseniz size farklı gözükebilecek bir ifade daha vardır,
   o da üçlü koşul operatörüdür:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$birinci ? $ikinci : $ucuncu
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
  İlk altifadenin değeri &true; (sıfırdan farklı) ise, ikinci altifade
   çalıştırılır ve bu koşullu ifadenin sonucu olur. Aksi takdirde,
   üçüncü altifade çalıştırılır ve koşullu ifadenin sonucu bu olur.
   </para>
   <para>
   Aşağıdaki örnek ön ve son arttırma işlemleri ve ifadelerin geneli
   hakkında anlayışınızı geliştirmenizi sağlamanıza biraz daha
   katkı sağlayacaktır:
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function double($i)
{
    return $i*2;
}
$b = $a = 5;        /* beş değerini $a ve $b değişkenlerine atar */
$c = $a++;          /* son-arttırma, $a'nın özgün değerini (5) $c'ye atar */
$e = $d = ++$b;     /* ön-arttırma, $b'nin arttırılmış değerini (6) $d ve $e'ye atar */

/* bu noktada, $d ve $e 6 değerine sahiptir */

$f = double($d++);  /* $d'nin değerini arttırmadan önce $d'nin değerinin iki katını $f'ye atar,
                       2*6 = 12 */
$g = double(++$e);  /* $e'nin değerini arttırdıktan sonra iki katını alıp $g'ye atar,
                       2*7 = 14 */
$h = $g += 10;      /* önce, $g 10 arttırılır ve 24 değerine sahip olur.
                       Atama değeri olan (24) $h'ye atanır ve $h de 24 değerine sahip olur. */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
   Bazı ifadeler deyim olarak kabul edilebilir. Bu durumda, deyim
   'ifade' ';' şeklinde, noktalı virgülle sonlandırılmış bir ifade şeklinde
   olacaktır. '$=$a=5' olduğunda, $a=5 geçerli bir ifadedir, ancak kendi başına
   bir deyim değildir. '$b=$a=5' ise geçerli bir deyimdir.
   </simpara>
   <simpara>
   Son olarak dile getirmemiz gereken bir konu da ifadelerin gerçek değeridir.
   Birçok olayda, çoğunlukla da koşula bağlı çalışmalarda ve döngülerde, ifadenin
   kendi değeri ile değil, &true; ya da &false; olması ile ilgileniyor olacaksınız.
    
    <!-- (PHP doesn't have a
    dedicated boolean type) : WRONG, PHP does. -->
    
    &true; ve &false; değişmezleri (büyük-küçük harf duyarsız) iki olası boolean
    değerdir. Mümkün olduğunda, bir ifade otomatik olarak boolean'a çevrilir.
    <link linkend="language.types.typecasting">tip-çevrimi</link> bölümünden
    bunun nasıl gerçekleştiği ile ilgili detaylara ulaşabilirsiniz.
   </simpara>
   <simpara>
   PHP ifadeleri tümüyle ve çok güçlü bir biçimde uygulamaya geçirmiştir,
   ve bunların tümünü belgelemek bu kılavuzun kapsamının dışında yer
   almaktadır. Yukarıdaki örnekler size ifadelerin ne olduğu ve nasıl kullanışlı
   ifadeler yaratabileceğiniz hakkında yeterli fikri verecektir. Bu kılavuzun
   geri kalanında, geçerli herhangi bir PHP ifadesini belirtmek için
   <varname>expr</varname> sözcüğünü kullanacağız.
   </simpara>
  </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
